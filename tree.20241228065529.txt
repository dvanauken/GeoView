+-- .vscode
|   +-- extensions.json
|   +-- launch.json
|   \-- tasks.json
+-- src
|   +-- app
|   |   +-- components
|   |   |   +-- admin
|   |   |   |   +-- role-detail
|   |   |   |   |   +-- role-detail.component.html: <!-- src/app/components/admin/role-detail/role-detail.component.html --> <div class="form-container"> <div class="form-card"> <h2>Edit Role</h2> <form (ngSubmit)="onSubmit()" #roleForm="ngForm"> <div class="form-group"> <label for="roleName">Role Name</label> <input type="text" id="roleName" name="roleName" [(ngModel)]="role.roleName" class="form-control" required > </div> <div class="form-group"> <label for="roleDescription">Description</label> <textarea id="roleDescription" name="roleDescription" [(ngModel)]="role.roleDescription" class="form-control" rows="3" required ></textarea> </div> <div class="metadata-section"> <div class="metadata-item"> <label>Created By:</label> <span>{{ role.createdBy }}</span> </div> <div class="metadata-item"> <label>Created Date:</label> <span>{{ role.createDate | date:'short' }}</span> </div> <div class="metadata-item"> <label>Updated By:</label> <span>{{ role.updatedBy }}</span> </div> <div class="metadata-item"> <label>Updated Date:</label> <span>{{ role.updateDate | date:'short' }}</span> </div> </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="!roleForm.form.valid">Save Changes</button> </div> </form> </div> </div>
|   |   |   |   |   +-- role-detail.component.scss: // src/app/components/admin/role-detail/role-detail.component.scss .form-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .form-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } } .metadata-section { background-color: #f8f9fa; padding: 1rem; border-radius: 4px; margin: 1.5rem 0; } .metadata-item { display: flex; margin-bottom: 0.5rem; label { font-weight: 500; width: 120px; color: #555; } span { color: #666; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } }
|   |   |   |   |   \-- role-detail.component.ts: // src/app/components/admin/role-detail/role-detail.component.ts import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, Router } from '@angular/router'; @Component({ selector: 'app-role-detail', templateUrl: './role-detail.component.html', styleUrls: ['./role-detail.component.scss'] }) export class RoleDetailComponent implements OnInit { roleId: number; role: any = { roleName: '', roleDescription: '' }; constructor( private route: ActivatedRoute, private router: Router ) { this.roleId = Number(this.route.snapshot.paramMap.get('id')); } ngOnInit(): void { // Simulate fetching role data this.role = { roleId: this.roleId, roleName: 'Admin', roleDescription: 'Full system access and management capabilities', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-15'), createdBy: 'system', updatedBy: 'admin' }; } onSubmit(): void { console.log('Saving role:', this.role); this.router.navigate(['/admin/roles']); } onCancel(): void { this.router.navigate(['/admin/roles']); } }
|   |   |   |   +-- roles
|   |   |   |   |   +-- roles.component.html: <!-- src/app/components/admin/roles/roles.component.html --> <div class="table-container"> <div class="table-card"> <h2>Role Management</h2> <table class="data-table"> <thead> <tr> <th *ngFor="let column of displayedColumns"> {{ column | titlecase }} </th> </tr> </thead> <tbody> <tr *ngFor="let role of roles"> <td> <a [routerLink]="['/admin/roles', role.roleId]" class="role-link"> {{ role.roleName }} </a> </td> <td>{{ role.roleDescription }}</td> <td>{{ role.createDate | date:'short' }}</td> <td>{{ role.updateDate | date:'short' }}</td> <td>{{ role.createdBy }}</td> <td>{{ role.updatedBy }}</td> </tr> </tbody> </table> </div> </div>
|   |   |   |   |   +-- roles.component.scss: // src/app/components/admin/roles/roles.component.scss .table-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .table-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1200px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .data-table { width: 100%; border-collapse: collapse; margin-top: 1rem; th, td { padding: 1rem; text-align: left; border-bottom: 1px solid #e0e0e0; } th { background-color: #f5f5f5; font-weight: 500; color: #333; } tr:hover { background-color: #f8f9fa; } } .role-link { color: #007bff; text-decoration: none; &:hover { text-decoration: underline; } }
|   |   |   |   |   \-- roles.component.ts: // src/app/components/admin/roles/roles.component.ts import { Component, OnInit } from '@angular/core'; interface Role { roleId: number; roleName: string; roleDescription: string; createDate: Date; updateDate: Date; createdBy: string; updatedBy: string; } @Component({ selector: 'app-roles', templateUrl: './roles.component.html', styleUrls: ['./roles.component.scss'] }) export class RolesComponent implements OnInit { roles: Role[] = [ { roleId: 1, roleName: 'Admin', roleDescription: 'Full system access and management capabilities', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-15'), createdBy: 'system', updatedBy: 'admin' }, { roleId: 2, roleName: 'User Manager', roleDescription: 'Can manage user accounts and permissions', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-20'), createdBy: 'system', updatedBy: 'admin' }, { roleId: 3, roleName: 'Report Viewer', roleDescription: 'Can view and download system reports', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-25'), createdBy: 'system', updatedBy: 'admin' } ]; displayedColumns: string[] = [ 'roleName', 'roleDescription', 'createDate', 'updateDate', 'createdBy', 'updatedBy' ]; constructor() {} ngOnInit(): void {} }
|   |   |   |   +-- user-detail
|   |   |   |   |   +-- user-detail.component.html: <!-- src/app/admin/users/user-detail/user-detail.component.html --> <div class="form-container"> <div class="form-card"> <h2>Edit User</h2> <form (ngSubmit)="onSubmit()" #userForm="ngForm"> <div class="form-group"> <label for="username">Username</label> <input type="text" id="username" name="username" [(ngModel)]="user.username" class="form-control" disabled > </div> <div class="form-group"> <label for="firstName">First Name</label> <input type="text" id="firstName" name="firstName" [(ngModel)]="user.firstName" class="form-control" required > </div> <div class="form-group"> <label for="middleInitial">Middle Initial</label> <input type="text" id="middleInitial" name="middleInitial" [(ngModel)]="user.middleInitial" class="form-control" maxlength="1" > </div> <div class="form-group"> <label for="lastName">Last Name</label> <input type="text" id="lastName" name="lastName" [(ngModel)]="user.lastName" class="form-control" required > </div> <div class="form-group"> <label for="status">Status</label> <select id="status" name="status" [(ngModel)]="user.status" class="form-control" required > <option *ngFor="let status of statuses" [value]="status"> {{ status | titlecase }} </option> </select> </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="!userForm.form.valid">Save Changes</button> </div> </form> </div> </div>
|   |   |   |   |   +-- user-detail.component.scss: // src/app/admin/users/user-detail/user-detail.component.scss .form-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .form-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &:disabled { background-color: #e9ecef; cursor: not-allowed; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } }
|   |   |   |   |   \-- user-detail.component.ts: // src/app/admin/users/user-detail/user-detail.component.ts import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, Router } from '@angular/router'; @Component({ selector: 'app-user-detail', templateUrl: './user-detail.component.html', styleUrls: ['./user-detail.component.scss'] }) export class UserDetailComponent implements OnInit { userId: number; user: any = { username: '', firstName: '', middleInitial: '', lastName: '', status: 'silver' }; statuses = ['gold', 'platinum', 'silver']; constructor( private route: ActivatedRoute, private router: Router ) { this.userId = Number(this.route.snapshot.paramMap.get('id')); } ngOnInit(): void { // In real app, fetch user data here // For now, simulate data this.user = { id: this.userId, username: 'jsmith', firstName: 'John', middleInitial: 'A', lastName: 'Smith', status: 'gold', createDate: new Date('2024-01-15'), updateDate: new Date('2024-02-20'), createdBy: 'admin', updatedBy: 'admin' }; } onSubmit(): void { // Save logic would go here console.log('Saving user:', this.user); this.router.navigate(['/admin/users']); } onCancel(): void { this.router.navigate(['/admin/users']); } }
|   |   |   |   \-- users
|   |   |   |       +-- users.component.html: <!-- src/app/admin/users/users.component.html --> <div class="table-container"> <div class="table-card"> <h2>User Management</h2> <table class="data-table"> <thead> <tr> <th *ngFor="let column of displayedColumns"> {{ column | titlecase }} </th> </tr> </thead> <tbody> <tr *ngFor="let user of users"> <td> <a [routerLink]="['/admin/users', user.id]" class="username-link"> {{ user.username }} </a> </td> <td>{{ user.firstName }}</td> <td>{{ user.middleInitial }}</td> <td>{{ user.lastName }}</td> <td> <span class="status-badge" [style.background-color]="getStatusColor(user.status)"> {{ user.status | titlecase }} </span> </td> <td>{{ user.createDate | date:'short' }}</td> <td>{{ user.updateDate | date:'short' }}</td> <td>{{ user.createdBy }}</td> <td>{{ user.updatedBy }}</td> </tr> </tbody> </table> </div> </div>
|   |   |   |       +-- users.component.scss: // src/app/admin/users/users.component.scss .table-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .table-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1200px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .data-table { width: 100%; border-collapse: collapse; margin-top: 1rem; th, td { padding: 1rem; text-align: left; border-bottom: 1px solid #e0e0e0; } th { background-color: #f5f5f5; font-weight: 500; color: #333; } tr:hover { background-color: #f8f9fa; } } .username-link { color: #007bff; text-decoration: none; &:hover { text-decoration: underline; } } .status-badge { padding: 0.25rem 0.75rem; border-radius: 1rem; font-size: 0.875rem; font-weight: 500; display: inline-block; color: #333; }
|   |   |   |       \-- users.component.ts: // src/app/admin/users/users.component.ts import { Component, OnInit } from '@angular/core'; interface User { id: number; username: string; firstName: string; middleInitial: string; lastName: string; status: 'gold' | 'platinum' | 'silver'; createDate: Date; updateDate: Date; createdBy: string; updatedBy: string; } @Component({ selector: 'app-users', templateUrl: './users.component.html', styleUrls: ['./users.component.scss'] }) export class UsersComponent implements OnInit { users: User[] = [ { id: 1, username: 'jsmith', firstName: 'John', middleInitial: 'A', lastName: 'Smith', status: 'gold', createDate: new Date('2024-01-15'), updateDate: new Date('2024-02-20'), createdBy: 'admin', updatedBy: 'admin' }, { id: 2, username: 'mjohnson', firstName: 'Mary', middleInitial: 'E', lastName: 'Johnson', status: 'platinum', createDate: new Date('2024-01-20'), updateDate: new Date('2024-02-25'), createdBy: 'admin', updatedBy: 'admin' }, { id: 3, username: 'rwilson', firstName: 'Robert', middleInitial: 'J', lastName: 'Wilson', status: 'silver', createDate: new Date('2024-02-01'), updateDate: new Date('2024-02-28'), createdBy: 'admin', updatedBy: 'admin' } ]; displayedColumns: string[] = [ 'username', 'firstName', 'middleInitial', 'lastName', 'status', 'createDate', 'updateDate', 'createdBy', 'updatedBy' ]; constructor() {} ngOnInit(): void {} getStatusColor(status: string): string { switch (status) { case 'gold': return '#FFD700'; case 'platinum': return '#E5E4E2'; case 'silver': return '#C0C0C0'; default: return '#FFFFFF'; } } }
|   |   |   +-- airport-table
|   |   |   |   +-- airport-table.component.html: <div> <!-- Add Row Button at the top of the table --> <button mat-icon-button (click)="toggleNewEntryRow()" aria-label="Add row" class="icon-blue"> <mat-icon>add</mat-icon> </button> </div> <div class="table-container"> <table mat-table [dataSource]="dataSource" class="mat-elevation-z8"> <!-- New entry row at the top --> <tr *ngIf="isAddingNewEntry"> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Code" [(ngModel)]="newEntry.code"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Region" [(ngModel)]="newEntry.region" type="number"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Name" [(ngModel)]="newEntry.name"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="City" [(ngModel)]="newEntry.city"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Country" [(ngModel)]="newEntry.country"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Latitude" [(ngModel)]="newEntry.lat" type="number"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Longitude" [(ngModel)]="newEntry.lon" type="number"> </td> <td> <!-- Icons for save and cancel actions --> <mat-icon (click)="addInlineEntry()" color="primary" class="icon-blue">save</mat-icon> <mat-icon (click)="clearNewEntry()" color="primary" class="icon-blue">cancel</mat-icon> </td> </tr> <!-- Column definitions --> <ng-container matColumnDef="code"> <th mat-header-cell *matHeaderCellDef> Code </th> <td mat-cell *matCellDef="let element"> {{ element?.code }} </td> </ng-container> <ng-container matColumnDef="region"> <th mat-header-cell *matHeaderCellDef> Region </th> <td mat-cell *matCellDef="let element"> {{ element?.region }} </td> </ng-container> <ng-container matColumnDef="name"> <th mat-header-cell *matHeaderCellDef> Name </th> <td mat-cell *matCellDef="let element"> {{ element?.name }} </td> </ng-container> <ng-container matColumnDef="city"> <th mat-header-cell *matHeaderCellDef> City </th> <td mat-cell *matCellDef="let element"> {{ element?.city }} </td> </ng-container> <ng-container matColumnDef="country"> <th mat-header-cell *matHeaderCellDef> Country </th> <td mat-cell *matCellDef="let element"> {{ element?.country }} </td> </ng-container> <ng-container matColumnDef="lat"> <th mat-header-cell *matHeaderCellDef> Latitude </th> <td mat-cell *matCellDef="let element"> {{ element?.lat }} </td> </ng-container> <ng-container matColumnDef="lon"> <th mat-header-cell *matHeaderCellDef> Longitude </th> <td mat-cell *matCellDef="let element"> {{ element?.lon }} </td> </ng-container> <ng-container matColumnDef="actions"> <th mat-header-cell *matHeaderCellDef> Actions </th> <td mat-cell *matCellDef="let element"> <mat-icon (click)="editEntry(element)" color="primary" class="icon-blue">edit</mat-icon> <mat-icon (click)="cancelEdit(element)" color="primary" class="icon-blue">cancel</mat-icon> <mat-icon (click)="saveEntry(element)" color="primary" class="icon-blue">save</mat-icon> </td> </ng-container> <!-- Header and data rows --> <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr> <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> </table> <mat-paginator #paginator [pageSize]="25" [pageSizeOptions]="[5, 10, 25, 100]" [length]="dataSource?.data.length || 0" showFirstLastButtons> </mat-paginator> </div>
|   |   |   |   +-- airport-table.component.scss: .table-container { padding: 1.25rem; background-color: #f9f9f9; border-radius: 0.5rem; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); table { width: 100%; border-collapse: collapse; table-layout: fixed; th, td { padding: 0.75rem 0.5rem; font-size: 0.875rem; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } th { font-weight: 600; background-color: #f0f0f0; } td { border-bottom: 1px solid #e0e0e0; } .code-column { width: 4rem; text-align: center; } .region-column { width: 6rem; text-align: center; } .name-column { width: 12rem; text-align: left; } .city-column { width: 8rem; text-align: left; } .country-column { width: 8rem; text-align: left; } .lat-column { width: 7rem; text-align: right; } .lon-column { width: 7rem; text-align: right; } } button { margin-top: 0.9375rem; } mat-paginator { margin-top: 1.25rem; } } .icon-blue { color: blue; } .new-entry-row { background-color: #f2f2f2; }
|   |   |   |   +-- airport-table.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing'; import { AirportTableComponent } from './airport-table.component'; describe('AirportTableComponent', () => { let component: AirportTableComponent; let fixture: ComponentFixture<AirportTableComponent>; beforeEach(() => { TestBed.configureTestingModule({ declarations: [AirportTableComponent] }); fixture = TestBed.createComponent(AirportTableComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
|   |   |   |   \-- airport-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, OnChanges, SimpleChanges, ViewChild } from '@angular/core'; import { MatTableDataSource } from '@angular/material/table'; import { MatPaginator } from '@angular/material/paginator'; import { AirportData } from '../../interfaces/airport-data.interface'; import { DataService } from '../../services/data.service'; @Component({ selector: 'app-airport-table', templateUrl: './airport-table.component.html', styleUrls: ['./airport-table.component.scss'] }) export class AirportTableComponent implements OnInit, OnChanges { @Input() airportData: AirportData[] = []; @ViewChild(MatPaginator, { static: true }) paginator: MatPaginator; dataSource: MatTableDataSource<AirportData> = new MatTableDataSource<AirportData>(); displayedColumns: string[] = ['code', 'region', 'name', 'city', 'country', 'lat', 'lon', 'actions']; // Control for displaying the new entry row isAddingNewEntry = false; newEntry: AirportData = { code: '', region: 0, name: '', city: '', country: '', lat: null, lon: null }; constructor( private dataService: DataService, private cdr: ChangeDetectorRef ) {} ngOnInit(): void { this.initializeDataSource(); } ngOnChanges(changes: SimpleChanges): void { if (changes['airportData'] && changes['airportData'].currentValue) { this.updateDataSource(); } } toggleNewEntryRow(): void { this.isAddingNewEntry = !this.isAddingNewEntry; this.cdr.markForCheck(); // Mark the component for change detection } addInlineEntry() { if (this.newEntry.code && this.newEntry.name && this.newEntry.city && this.newEntry.country && this.newEntry.lat !== null && this.newEntry.lon !== null) { const data = this.dataSource.data; data.unshift({ ...this.newEntry }); this.dataSource.data = data; this.dataService.setAirport(this.newEntry); this.clearNewEntry(); this.isAddingNewEntry = false; this.cdr.markForCheck(); // Mark the component for change detection } } clearNewEntry() { this.newEntry = { code: '', region: 0, name: '', city: '', country: '', lat: null, lon: null }; this.isAddingNewEntry = false; this.cdr.markForCheck(); // Mark the component for change detection } initializeDataSource(): void { this.dataSource.data = this.airportData; this.dataSource.paginator = this.paginator; } updateDataSource(): void { this.dataSource.data = this.airportData; } }
|   |   |   +-- identity
|   |   |   |   +-- password
|   |   |   |   |   +-- password.component.html: <!-- password.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Reset Password</h2> <!-- Error Messages --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <form (ngSubmit)="onSubmit()" #passwordForm="ngForm" *ngIf="!successMessage"> <div class="form-group"> <label for="email">Email Address</label> <input type="email" id="email" name="email" [(ngModel)]="email" maxlength="256" class="form-control" required placeholder="Enter your email address" email > </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="passwordForm.invalid">Reset Password</button> </div> </form> </div> </div>
|   |   |   |   |   +-- password.component.scss: // password.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &::placeholder { color: #999; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |   |   \-- password.component.ts: // password.component.ts import { Component, ViewChild } from '@angular/core'; import { NgForm } from '@angular/forms'; import { Router } from '@angular/router'; @Component({ selector: 'app-password', templateUrl: './password.component.html', styleUrls: ['./password.component.scss'] }) export class PasswordComponent { @ViewChild('passwordForm') passwordForm!: NgForm; email = ''; errorMessages: string[] = []; successMessage = ''; constructor(private router: Router) {} onSubmit() { this.errorMessages = []; this.successMessage = ''; if (!this.email) { this.errorMessages.push('Email address is required.'); return; } if (!this.isValidEmail(this.email)) { this.errorMessages.push('Please enter a valid email address.'); return; } // Intentionally vague success message for security this.successMessage = 'If an account exists for this email address, you will receive password reset instructions shortly.'; // Redirect to login after 3 seconds setTimeout(() => { this.router.navigate(['/login']); }, 3000); } onCancel() { this.router.navigate(['/login']); } private isValidEmail(email: string): boolean { const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/; return emailRegex.test(email); } }
|   |   |   |   +-- password-reset
|   |   |   |   |   +-- password-reset.component.html: <!-- src/app/components/identity/reset-password/reset-password.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Reset Your Password</h2> <!-- Token Error Message --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <!-- Password Reset Form --> <form [formGroup]="resetForm" (ngSubmit)="onSubmit()" *ngIf="!successMessage && !errorMessages.length"> <div class="password-requirements"> <h3>Password Requirements:</h3> <ul> <li>At least 8 characters long</li> <li>Must include an uppercase letter</li> <li>Must include a lowercase letter</li> <li>Must include a number</li> <li>Must include a special character (!@#$%^&*)</li> </ul> </div> <!-- New Password Field --> <div class="form-group"> <label for="password">New Password</label> <div class="password-input-container"> <input [type]="showPassword ? 'text' : 'password'" id="password" formControlName="password" class="form-control" [class.is-invalid]="resetForm.get('password')?.invalid && resetForm.get('password')?.touched" > <button type="button" class="password-toggle" (click)="togglePasswordVisibility('password')"> <i class="material-icons">{{ showPassword ? 'visibility_off' : 'visibility' }}</i> </button> </div> </div> <!-- Confirm Password Field --> <div class="form-group"> <label for="confirmPassword">Confirm New Password</label> <div class="password-input-container"> <input [type]="showConfirmPassword ? 'text' : 'password'" id="confirmPassword" formControlName="confirmPassword" class="form-control" [class.is-invalid]="resetForm.get('confirmPassword')?.touched && resetForm.hasError('passwordMismatch')" > <button type="button" class="password-toggle" (click)="togglePasswordVisibility('confirmPassword')"> <i class="material-icons">{{ showConfirmPassword ? 'visibility_off' : 'visibility' }}</i> </button> </div> </div> <!-- Validation Errors --> <div class="validation-errors" *ngIf="getPasswordErrors().length > 0"> <ul> <li *ngFor="let error of getPasswordErrors()" class="error-message"> {{ error }} </li> </ul> </div> <!-- Form Buttons --> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()"> Cancel </button> <button type="submit" class="btn btn-primary" [disabled]="resetForm.invalid || !token"> Reset Password </button> </div> </form> </div> </div>
|   |   |   |   |   +-- password-reset.component.scss: // src/app/components/identity/reset-password/reset-password.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .password-requirements { background-color: #f8f9fa; padding: 1rem; border-radius: 4px; margin-bottom: 1.5rem; h3 { font-size: 1rem; margin: 0 0 0.5rem; color: #495057; } ul { margin: 0; padding-left: 1.5rem; color: #6c757d; font-size: 0.9rem; li { margin-bottom: 0.25rem; } } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .password-input-container { position: relative; display: flex; align-items: center; .form-control { padding-right: 40px; } .password-toggle { position: absolute; right: 8px; background: none; border: none; color: #6c757d; cursor: pointer; padding: 4px; &:hover { color: #495057; } .material-icons { font-size: 20px; } } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &.is-invalid { border-color: #dc3545; &:focus { box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.1); } } } .validation-errors { margin-top: -0.5rem; margin-bottom: 1rem; ul { margin: 0; padding-left: 1.5rem; } .error-message { color: #dc3545; font-size: 0.875rem; margin-bottom: 0.25rem; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |   |   \-- password-reset.component.ts: // src/app/components/identity/reset-password/reset-password.component.ts import { Component, OnInit } from '@angular/core'; import { AbstractControl, FormBuilder, FormGroup, ValidationErrors, ValidatorFn, Validators } from '@angular/forms'; import { Router, ActivatedRoute } from '@angular/router'; @Component({ selector: 'app-reset-password', templateUrl: './password-reset.component.html', styleUrls: ['./password-reset.component.scss'] }) export class PasswordResetComponent implements OnInit { resetForm: FormGroup; token: string = ''; errorMessages: string[] = []; successMessage: string = ''; showPassword: boolean = false; showConfirmPassword: boolean = false; constructor( private fb: FormBuilder, private router: Router, private route: ActivatedRoute ) { this.resetForm = this.fb.group({ password: ['', [ Validators.required, Validators.minLength(8), this.createPasswordStrengthValidator() ]], confirmPassword: ['', Validators.required] }, { validators: this.passwordMatchValidator }); } ngOnInit(): void { this.token = this.route.snapshot.queryParams['token'] || ''; if (!this.token) { this.errorMessages = ['Invalid or expired password reset link']; } } createPasswordStrengthValidator(): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const password = control.value; if (!password) { return null; } const hasUpperCase = /[A-Z]/.test(password); const hasLowerCase = /[a-z]/.test(password); const hasNumber = /[0-9]/.test(password); const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password); const passwordValid = hasUpperCase && hasLowerCase && hasNumber && hasSpecialChar; return !passwordValid ? { passwordStrength: true } : null; }; } passwordMatchValidator(control: AbstractControl): ValidationErrors | null { const password = control.get('password'); const confirmPassword = control.get('confirmPassword'); if (!password || !confirmPassword) { return null; } return password.value === confirmPassword.value ? null : { passwordMismatch: true }; } getPasswordErrors(): string[] { const errors: string[] = []; const password = this.resetForm.get('password'); if (password?.errors && (password.dirty || password.touched)) { if (password.errors['required']) { errors.push('Password is required'); } if (password.errors['minlength']) { errors.push('Password must be at least 8 characters'); } if (password.errors['passwordStrength']) { errors.push('Password must include: uppercase letter, lowercase letter, number, and special character'); } } if (this.resetForm.errors?.['passwordMismatch'] && this.resetForm.get('confirmPassword')?.touched) { errors.push('Passwords must match'); } return errors; } onSubmit(): void { if (this.resetForm.valid) { // Here you would call your service to update the password console.log('Password reset submitted'); this.successMessage = 'Password successfully reset.'; // Redirect to login after success setTimeout(() => { this.router.navigate(['/login']); }, 3000); } else { this.resetForm.markAllAsTouched(); } } onCancel(): void { if (this.resetForm.dirty) { if (confirm('Are you sure you want to cancel? Any unsaved changes will be lost.')) { this.router.navigate(['/login']); } } else { this.router.navigate(['/login']); } } togglePasswordVisibility(field: 'password' | 'confirmPassword'): void { if (field === 'password') { this.showPassword = !this.showPassword; } else { this.showConfirmPassword = !this.showConfirmPassword; } } }
|   |   |   |   +-- profile
|   |   |   |   |   +-- profile.component.html: <!-- profile.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Create Account</h2> <!-- Error Messages --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <form (ngSubmit)="onSubmit()" #registrationForm="ngForm"> <div class="form-group"> <label for="username">Username</label> <input type="text" id="username" name="username" [(ngModel)]="username" maxlength="32" class="form-control" required placeholder="Choose a username" > </div> <div class="form-group"> <label for="email">Email</label> <input type="email" id="email" name="email" [(ngModel)]="email" maxlength="256" class="form-control" required placeholder="Enter your email address" > </div> <div class="form-group name-group"> <div class="name-field"> <label for="first-name">First Name</label> <input type="text" id="first-name" name="firstName" [(ngModel)]="firstName" maxlength="32" class="form-control" required placeholder="First name" > </div> <div class="name-field middle-initial"> <label for="middle-initial">M.I.</label> <input type="text" id="middle-initial" name="middleInitial" [(ngModel)]="middleInitial" maxlength="1" class="form-control" placeholder="M.I." > </div> <div class="name-field"> <label for="last-name">Last Name</label> <input type="text" id="last-name" name="lastName" [(ngModel)]="lastName" maxlength="32" class="form-control" required placeholder="Last name" > </div> </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="registrationForm.invalid">Create Account</button> </div> </form> </div> </div>
|   |   |   |   |   +-- profile.component.scss: // profile.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .name-group { display: flex; gap: 1rem; .name-field { flex: 1; &.middle-initial { flex: 0 0 80px; } } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &::placeholder { color: #999; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |   |   \-- profile.component.ts: // profile.component.ts import { Component, ViewChild } from '@angular/core'; import { NgForm } from '@angular/forms'; import { Router } from '@angular/router'; @Component({ selector: 'app-profile', templateUrl: './profile.component.html', styleUrls: ['./profile.component.scss'] }) export class ProfileComponent { @ViewChild('registrationForm') registrationForm!: NgForm; username = ''; email = ''; firstName = ''; middleInitial = ''; lastName = ''; errorMessages: string[] = []; successMessage = ''; constructor(private router: Router) {} onSubmit() { this.errorMessages = []; this.successMessage = ''; // Validate fields if (!this.username) { this.errorMessages.push('Username is required.'); } if (!this.email) { this.errorMessages.push('Email is required.'); } if (!this.firstName || !this.lastName) { this.errorMessages.push('First and last name are required.'); } // Simulate username availability check if (this.username.toLowerCase() === 'admin') { this.errorMessages.push('This username is not available. Please choose another.'); return; } // If no errors, proceed with registration if (this.errorMessages.length === 0) { // TODO: Implement actual registration logic here this.successMessage = 'Registration successful! Please check your email for confirmation.'; // Reset form after successful submission setTimeout(() => { this.router.navigate(['/login']); }, 2000); } } onCancel() { this.router.navigate(['/login']); } }
|   |   |   |   \-- username
|   |   |   |       +-- username.component.html: <!-- username.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Recover Username</h2> <!-- Error Messages --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <form (ngSubmit)="onSubmit()" #usernameForm="ngForm" *ngIf="!successMessage"> <div class="form-group"> <label for="email">Email Address</label> <input type="email" id="email" name="email" [(ngModel)]="email" maxlength="256" class="form-control" required placeholder="Enter your email address" email > </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="usernameForm.invalid">Recover Username</button> </div> </form> </div> </div>
|   |   |   |       +-- username.component.scss: // username.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &::placeholder { color: #999; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |       \-- username.component.ts: // username.component.ts import { Component, ViewChild } from '@angular/core'; import { NgForm } from '@angular/forms'; import { Router } from '@angular/router'; @Component({ selector: 'app-username', templateUrl: './username.component.html', styleUrls: ['./username.component.scss'] }) export class UsernameComponent { @ViewChild('usernameForm') usernameForm!: NgForm; email = ''; errorMessages: string[] = []; successMessage = ''; constructor(private router: Router) {} onSubmit() { this.errorMessages = []; this.successMessage = ''; if (!this.email) { this.errorMessages.push('Email address is required.'); return; } if (!this.isValidEmail(this.email)) { this.errorMessages.push('Please enter a valid email address.'); return; } // Success message intentionally vague for security this.successMessage = 'If an account exists for this email address, you will receive your username recovery instructions shortly.'; // Redirect to login after 3 seconds setTimeout(() => { this.router.navigate(['/login']); }, 3000); } onCancel() { this.router.navigate(['/login']); } private isValidEmail(email: string): boolean { const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/; return emailRegex.test(email); } }
|   |   |   +-- layout
|   |   |   |   +-- main-layout.component.html: <!-- main-layout.component.html --> <main [class.aside-hidden]="!(isVisible$ | async)"> <nav> <ul> <li><a routerLink="/map">Map</a></li> <li><a routerLink="/perspective">Perspective</a></li> <li><a routerLink="/orthographic">Orthographic</a></li> <li><a routerLink="/two-point">Two Point</a></li> <li><a routerLink="/gnomic">Gnomic</a></li> <li><a routerLink="/cylindrical">Cylindrical</a></li> <li><a routerLink="/solar">Solar</a></li> <li><a routerLink="/utm">UTM</a></li> <li><a routerLink="/albers">Albers</a></li> <li><a routerLink="/lambert">Lambert</a></li> <hr /> <li><a routerLink="/admin/users">Users</a></li> <li><a routerLink="/admin/roles">Roles</a></li> <li><a (click)="logout()">Logout</a></li> </ul> </nav> <header> <h1>GeoView Navigation</h1> </header> <section> <router-outlet></router-outlet> </section> <aside *ngIf="content$ | async as content"> <header> <h2>{{content.title}}</h2> <button (click)="toggleAside()">Ã—</button> </header> <ul> <li *ngFor="let command of content.commands"> <h3>{{command.action}}</h3> <div>{{command.keys}}</div> <p>{{command.description}}</p> </li> </ul> </aside> <footer></footer> </main>
|   |   |   |   +-- main-layout.component.scss: :host { display: block; height: 100vh; } main { display: grid; grid-template-areas: "nav header header" "nav section aside" "nav footer footer"; grid-template-columns: 300px 1fr 300px; grid-template-rows: 100px 1fr 80px; height: 100%; gap: 8px; padding: 8px; background: #f0f0f0; &.aside-hidden { grid-template-columns: 300px 1fr 0; aside { display: none; } section { grid-column: 2 / 4; } } } aside { header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; button { border: none; background: none; font-size: 1.5rem; cursor: pointer; padding: 0.25rem; } } ul { list-style: none; padding: 0; margin: 0; li { margin-bottom: 1rem; h3 { margin: 0 0 0.5rem; font-size: 1rem; } div { color: #666; font-family: monospace; margin-bottom: 0.25rem; } p { margin: 0; font-size: 0.9rem; } } } } nav { grid-area: nav; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); a { display: block; padding: 0.75rem 1rem; text-decoration: none; color: #333; border-radius: 4px; margin-bottom: 0.5rem; cursor: pointer; &:hover { background: #f5f5f5; } &.active { background: #007bff; color: white; } } } header { grid-area: header; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } section { grid-area: section; background: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); overflow: auto; } aside { grid-area: aside; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } footer { grid-area: footer; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
|   |   |   |   \-- main-layout.component.ts: // main-layout.component.ts import { Component } from '@angular/core'; import { AuthService } from '../../services/auth.service'; import { AsideService } from '../../services/aside.service'; @Component({ selector: 'app-main-layout', templateUrl: './main-layout.component.html', styleUrls: ['./main-layout.component.scss'] }) export class MainLayoutComponent { content$ = this.asideService.getContent(); isVisible$ = this.asideService.getVisibility(); constructor( private authService: AuthService, private asideService: AsideService ) {} logout() { this.authService.logout(); } toggleAside() { this.asideService.toggleVisibility(); } }
|   |   |   +-- login
|   |   |   |   +-- login.component.html: <div class="login-container"> <div class="login-card"> <h2>GeoView Login</h2> <div *ngIf="errorMessage" class="error-message"> <span class="material-icons error-icon">error_outline</span> {{ errorMessage }} </div> <form class="login-form" (ngSubmit)="onSubmit()"> <div class="form-field"> <label for="username">Username:</label> <input type="text" id="username" [(ngModel)]="username" name="username" placeholder="Enter username"> </div> <div class="form-field"> <label for="password">Password:</label> <input type="password" id="password" [(ngModel)]="password" name="password" placeholder="Enter password"> </div> <button type="submit" class="login-button">Login</button> </form> <div class="extra-links"> <a routerLink="/identity/username">Forgot Username?</a> <a routerLink="/identity/password">Forgot Password?</a> </div> </div> <!-- Registration Form --> <div class="login-card"> <h2>New Here?</h2> <p>Don't have an account? Register now to get started!</p> <button class="login-button" routerLink="/identity/profile">Register</button> </div> </div>
|   |   |   |   +-- login.component.scss: .login-container { display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f5f5f5; } .login-card { display: flex; /* Enable flex for the column layout */ flex-direction: column; /* Arrange children in a column */ align-items: stretch; /* Make children align to the container's width */ background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 400px; gap: 1rem; /* Add consistent spacing between elements */ } h2 { margin: 0; color: #333; text-align: center; } .error-message { display: flex; align-items: center; gap: 0.5rem; /* Space between icon and text */ background-color: #f8d7da; /* Light red for error messages */ color: #721c24; padding: 0.75rem; border-radius: 4px; } .error-icon { font-size: 24px; /* Icon size */ } .login-form { display: flex; flex-direction: column; /* Stack form fields */ gap: 1rem; /* Add spacing between fields */ } .form-field label { margin-bottom: 0.25rem; color: #555; font-weight: 500; } .form-field input { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; } input:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } .login-button { padding: 0.75rem; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; } .login-button:hover { background: #0056b3; } .extra-links { display: flex; justify-content: space-between; font-size: 0.9rem; a { color: #007bff; text-decoration: none; &:hover { text-decoration: underline; } } }
|   |   |   |   \-- login.component.ts: // src/app/components/login/login.component.ts import { Component } from '@angular/core'; import { AuthService } from '../../services/auth.service'; @Component({ selector: 'app-login', templateUrl: './login.component.html', styleUrls: ['./login.component.scss'] }) export class LoginComponent { username: string = 'admin'; password: string = 'admin'; errorMessage: string = ''; // To store the error message constructor(private authService: AuthService) {} onSubmit() { // Simulate login validation if (this.username !== 'admin' || this.password !== 'admin') { this.errorMessage = 'Username and/or password is not correct.'; // Set error message this.username = ''; // Clear username this.password = ''; // Clear password } else { this.errorMessage = ''; // Clear error message if login is successful this.authService.login(this.username, this.password); } } }
|   |   |   +-- map
|   |   |   |   +-- globe-drag-handler.ts: import { throttle, DebouncedFunc } from 'lodash'; import * as d3 from 'd3'; export class GlobeDragHandler { private v0: [number, number, number]; // Mouse position at drag start private r0: [number, number, number]; // Projection rotation at drag start private readonly throttledUpdate: DebouncedFunc<() => void>; constructor( private projection: d3.GeoProjection, private updateCallback: () => void, private throttleTime: number = 16 // ~60fps default ) { this.throttledUpdate = throttle(() => { this.updateCallback(); }, this.throttleTime); // Bind methods to ensure correct 'this' context this.dragStarted = this.dragStarted.bind(this); this.dragged = this.dragged.bind(this); this.dragEnded = this.dragEnded.bind(this); } public dragStarted(event: d3.D3DragEvent<any, any, any>): void { const point = d3.pointer(event, event.sourceEvent.currentTarget); this.v0 = [point[0], point[1], 0]; this.r0 = this.projection.rotate(); } public dragged(event: d3.D3DragEvent<any, any, any>): void { if (!this.v0 || !this.r0) return; const point = d3.pointer(event, event.sourceEvent.currentTarget); const sensitivity = 0.25; const xChange = (point[0] - this.v0[0]) * sensitivity; const yChange = (point[1] - this.v0[1]) * sensitivity; // Update projection rotation this.projection.rotate([ this.r0[0] + xChange, this.r0[1] - yChange, this.r0[2] ]); // Use throttled update this.throttledUpdate(); } public dragEnded(): void { this.v0 = undefined; this.r0 = undefined; // Force a final update to ensure we render the final position if (this.throttledUpdate.flush) { this.throttledUpdate.flush(); } } public destroy(): void { if (this.throttledUpdate.cancel) { this.throttledUpdate.cancel(); } } public attachDragBehavior(selection: d3.Selection<any, unknown, null, undefined>): void { const dragBehavior = d3.drag<any, unknown>() .on('start', this.dragStarted) .on('drag', this.dragged) .on('end', this.dragEnded); selection.call(dragBehavior); } }
|   |   |   |   +-- globe-keyboard-handler.ts: export class GlobeKeyboardHandler { constructor( private projection: d3.GeoProjection, private updateCallback: () => void, private zoomCallback: (zoomFactor: number) => void, // New callback for zoom private incrementStep: number = 5 // Degree increment for rotation adjustments ) { this.handleKeydown = this.handleKeydown.bind(this); window.addEventListener('keydown', this.handleKeydown, { passive: false }); } private handleKeydown(event: KeyboardEvent): void { event.preventDefault(); // Prevent default browser behavior for keys const currentRotation = this.projection.rotate(); let [yaw, pitch, roll] = currentRotation; switch (event.key.toUpperCase()) { // Ensure case-insensitivity case 'W': pitch = Math.min(pitch + this.incrementStep, 90); break; case 'S': pitch = Math.max(pitch - this.incrementStep, -90); break; case 'A': yaw = (yaw - this.incrementStep + 360) % 360; break; case 'D': yaw = (yaw + this.incrementStep) % 360; break; case 'Q': roll = (roll - this.incrementStep + 360) % 360; break; case 'E': roll = (roll + this.incrementStep) % 360; break; case 'R': // Reset rotation to default (0, 0, 0) yaw = 0; pitch = 0; roll = 0; break; case '+': // Zoom in this.zoomCallback(1.1); // Increase zoom factor return; case '-': // Zoom out this.zoomCallback(0.9); // Decrease zoom factor return; default: return; // Ignore other keys } this.projection.rotate([yaw, pitch, roll]); this.updateCallback(); } public removeEventListener(): void { window.removeEventListener('keydown', this.handleKeydown); } }
|   |   |   |   +-- map.component.html: <!-- map.component.html --> <div #mapContainer class="map-container"> <!-- The map will be appended here by D3 --> </div>
|   |   |   |   +-- map.component.scss: :host { display: block; width: 100%; height: 100%; } .map-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; } svg { width: 100%; height: 100%; display: block; }
|   |   |   |   +-- map.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild } from '@angular/core'; import * as d3 from 'd3'; import * as d3Geo from 'd3-geo'; import { Feature, FeatureCollection, Geometry, GeometryObject } from 'geojson'; import { Subscription } from 'rxjs'; import { ProjectionType } from '../../enums/projection-type.enum'; import { MatTableDataSource } from '@angular/material/table'; import { DataService } from '../../services/data.service'; import { throttle } from 'lodash'; import { GlobeDragHandler } from "./globe-drag-handler"; import { GlobeKeyboardHandler } from './globe-keyboard-handler'; @Component({ selector: 'app-map', templateUrl: './map.component.html', styleUrls: ['./map.component.scss'] }) export class MapComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('mapContainer', { static: true }) mapContainer: ElementRef; private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>; private gSphere: d3.Selection<SVGGElement, unknown, null, undefined>; private gGraticule: d3.Selection<SVGGElement, unknown, null, undefined>; private gCountries: d3.Selection<SVGGElement, unknown, null, undefined>; private gRoutes: d3.Selection<SVGGElement, unknown, null, undefined>; private gAirports: d3.Selection<SVGGElement, unknown, null, undefined>; private projection: d3.GeoProjection; private path: d3.GeoPath; private resizeObserver: ResizeObserver; private subscription: Subscription; private zoom: d3.ZoomBehavior<Element, unknown>; private projectionType: ProjectionType = ProjectionType.Orthographic; private dragHandler: GlobeDragHandler; private currentZoomScale: number = 1; private renderedAirports: Set<string> = new Set(); private keyboardHandler: GlobeKeyboardHandler; constructor(private dataService: DataService) { } ngOnInit(): void { //console.log('MapComponent ngOnInit called.'); this.initMap(); this.subscription = this.dataService.getSelectedFeatures().subscribe(features => { //console.log('MapComponent received updated features:', features); this.updateMapSelection(features); this.updateLayers(); }); } ngAfterViewInit(): void { //console.log('MapComponent ngAfterViewInit called. Ready for interaction.'); this.resizeObserver = new ResizeObserver(() => this.resizeMap()); this.resizeObserver.observe(this.mapContainer.nativeElement); } // Add a method to handle zoom changes private applyZoomChange(zoomFactor: number): void { this.zoom.scaleBy(this.svg, zoomFactor); } private updateMap(): void { //console.log('Updating the map based on new rotations or changes.'); // Re-render or refresh any D3 map layers as necessary this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } private setupSVG(): void { //console.log('Setting up SVG elements.'); const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; // Clear any existing SVG d3.select(this.mapContainer.nativeElement).selectAll('svg').remove(); this.svg = d3.select(this.mapContainer.nativeElement).append('svg') .attr('width', width) .attr('height', height) .attr('viewBox', `0 0 ${width} ${height}`) .attr('preserveAspectRatio', 'xMidYMid meet'); // Add external stylesheet reference this.svg.append('defs') .append('link') .attr('href', 'assets/styles/map.svg.css') .attr('type', 'text/css') .attr('rel', 'stylesheet'); // Create groups in correct order (bottom to top) this.gSphere = this.svg.append('g').attr('class', 'sphere-layer'); this.gGraticule = this.svg.append('g').attr('class', 'graticule-layer'); this.gCountries = this.svg.append('g').attr('class', 'countries-layer'); this.gRoutes = this.svg.append('g').attr('class', 'routes-layer'); this.gAirports = this.svg.append('g').attr('class', 'airports-layer'); } private initMap(): void { //console.log('Initializing map.'); this.setupSVG(); this.setProjection(this.projectionType); this.path = d3.geoPath().projection(this.projection); // Add the base sphere with subtle color this.gSphere.append('path') .datum({ type: 'Sphere' }) .attr('class', 'sphere') .attr('d', this.path); // Add graticule const graticule = d3.geoGraticule(); this.gGraticule.append('path') .datum(graticule) .attr('class', 'graticule') .attr('d', this.path) // Now add other layers this.updateLayers(); this.applyZoom(); this.resizeMap(); } private setProjection(type: ProjectionType): void { //console.log('Setting projection:', type); const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; this.projection = d3.geoOrthographic() .scale(Math.min(width, height) / 2.5) .translate([width / 2, height / 2]) .center([0, 0]) .rotate([74, -30, 0]) .clipAngle(90); this.path = d3.geoPath().projection(this.projection); } private updateLayers(): void { //console.log('Updating layers on the map.'); const layerNames = this.dataService.getLayerNames(); layerNames.forEach(layerName => { //console.log(`Processing layer: ${layerName}`); const layer = this.dataService.getLayer(layerName); if (layer && layer.getFeatures()) { if (layerName === 'countries') { this.updateCountriesLayer(layer.getFeatures()); } else if (layerName === 'routes' || layerName.toUpperCase() === 'PA') { this.updateRoutesLayer(layerName, layer.getFeatures()); this.updateAirportsForRoutes(layer.getFeatures()); } } }); } private updateCountriesLayer(features: Feature[]): void { this.gCountries.selectAll('path') .data(features) .join( enter => enter.append('path') .attr('class', (d: Feature) => `${d.geometry.type.toLowerCase()} country`) .attr('d', this.path) .style('fill', '#cccccc') .style('stroke', '#666666') .style('stroke-width', '0.5px'), update => update.attr('d', this.path), exit => exit.remove() ); } private updateRoutesLayer(layerName: string, features: Feature[]): void { this.gRoutes.selectAll(`path.${layerName}`) .data(features, (d: Feature) => d.id) .join( enter => enter.append('path') .attr('class', (d: Feature) => `${d.geometry.type.toLowerCase()} ${layerName}`) .attr('d', this.path) .on('click', (event: MouseEvent, feature: Feature<Geometry, { [name: string]: any }>) => this.selectFeature(event, feature) ) .style('cursor', 'pointer'), update => update.attr('d', this.path), exit => exit.remove() ); } private updateAirportsForRoutes(features: Feature[]): void { const airportsToAdd = new Set<string>(); // Collect all unique airports from the features features.forEach((feature: any) => { if (feature.properties && feature.properties.base && feature.properties.ref) { airportsToAdd.add(feature.properties.base); airportsToAdd.add(feature.properties.ref); } }); // Only add airports that haven't been rendered yet airportsToAdd.forEach(airportCode => { if (!this.renderedAirports.has(airportCode)) { this.addAirport(airportCode); this.renderedAirports.add(airportCode); } }); } private addAirport(airportCode: string): void { const airport = this.dataService.getAirport(airportCode); if (!airport) return; const lon = Number(airport.lon); const lat = Number(airport.lat); if (isNaN(lon) || isNaN(lat)) return; const coords: [number, number] = [lon, lat]; const projectedCoords = this.projection(coords as [number, number]); if (!projectedCoords || isNaN(projectedCoords[0]) || isNaN(projectedCoords[1])) return; // Add airport circle this.gAirports.append('circle') .attr('class', 'airport-circle') .attr('cx', projectedCoords[0]) .attr('cy', projectedCoords[1]) .attr('r', 1) .style('fill', '#add8e6') .style('stroke', 'blue') .style('stroke-width', '2px') .attr('data-airport', airportCode) .attr('vector-effect', 'non-scaling-stroke'); // Add single text label with consistent styling this.gAirports.append('text') .attr('class', 'airport-label') .attr('x', projectedCoords[0] + 7) .attr('y', projectedCoords[1] + 3) .text(airportCode) .style('font-size', '12px') .style('fill', 'blue') .style('stroke', 'none') .attr('data-airport', airportCode) .attr('vector-effect', 'non-scaling-stroke'); } private updateAirportPositions(): void { const zoomScale = this.currentZoomScale ? 1 / this.currentZoomScale : 1; this.gAirports.selectAll('.airport-circle, .airport-label').each((d: any, i, nodes) => { const element = d3.select(nodes[i]); const airportCode = element.attr('data-airport'); const airport = this.dataService.getAirport(airportCode); if (airport) { const coords: [number, number] = [Number(airport.lon), Number(airport.lat)]; const visible = d3.geoDistance(coords, [-this.projection.rotate()[0], -this.projection.rotate()[1]] as [number, number]) < Math.PI / 2; if (visible) { const projectedCoords = this.projection(coords as [number, number]); if (projectedCoords && !isNaN(projectedCoords[0]) && !isNaN(projectedCoords[1])) { if (element.classed('airport-circle')) { element .attr('cx', projectedCoords[0]) .attr('cy', projectedCoords[1]) .attr('r', 5 * zoomScale) .style('display', 'block'); } else { element .attr('x', projectedCoords[0] + 7 * zoomScale) .attr('y', projectedCoords[1] + 3 * zoomScale) .style('font-size', `${12 * zoomScale}px`) .style('display', 'block'); } } } else { element.style('display', 'none'); } } }); this.svg.selectAll('.airport-geometry').attr('vector-effect', 'non-scaling-stroke'); } public resizeMap(): void { //console.log('Resizing map.'); if (this.mapContainer && this.svg) { const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; this.svg .attr('width', width) .attr('height', height) .attr('viewBox', `0 0 ${width} ${height}`); this.projection .scale(Math.min(width, height) / 2.5) .translate([width / 2, height / 2]); // Update all paths and positions this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } } private selectFeature(event: MouseEvent, feature: Feature): void { console.log('Selecting feature:', feature); if (feature.id) { this.dataService.setSelectedFeatures([feature]); console.log('Selected feature set in DataModel:', feature.id); } else { console.error('Feature ID is undefined, cannot select'); } } private updateMapSelection(features: Feature[] | null): void { this.gRoutes.selectAll('.selected').classed('selected', false); if (features && features.length) { features.forEach(feature => { if (feature.id) { this.gRoutes.selectAll('path') .filter((d: any) => d.id === feature.id) .classed('selected', true) .raise(); } }); } } private applyZoom(): void { //console.log('Applying zoom behavior to the map.'); this.dragHandler = new GlobeDragHandler( this.projection, () => { this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } ); this.dragHandler.attachDragBehavior(this.gSphere.select('.sphere')); //this.dragHandler.attachDragBehavior(this.gSphere.select('*')); this.zoom = d3.zoom() .scaleExtent([1, 32]) .on('zoom', (event) => { const { transform } = event; const scaleTransformString = `translate(${transform.x}, ${transform.y}) scale(${transform.k})`; this.gSphere.attr('transform', scaleTransformString); this.gGraticule.attr('transform', scaleTransformString); this.gCountries.attr('transform', scaleTransformString); this.gRoutes.attr('transform', scaleTransformString); this.gAirports.attr('transform', scaleTransformString); this.svg.selectAll('path').attr('vector-effect', 'non-scaling-stroke'); this.currentZoomScale = event.transform.k; this.updateAirportPositions(); }); this.svg.call(this.zoom); } ngOnDestroy(): void { if (this.resizeObserver) this.resizeObserver.disconnect(); if (this.subscription) this.subscription.unsubscribe(); if (this.dragHandler) this.dragHandler.destroy(); if (this.keyboardHandler) this.keyboardHandler.removeEventListener(); // Access property here } }
|   |   |   |   \-- versor.ts: /** * versor.ts * A comprehensive utility class for handling 3D rotations using quaternions and versors. * Implements smooth interpolation and transformation between different rotation representations. */ export class Versor { /** * Converts degrees to radians */ static toRadians(degrees: number): number { return degrees * Math.PI / 180; } /** * Converts radians to degrees */ static toDegrees(radians: number): number { return radians * 180 / Math.PI; } /** * Converts latitude and longitude to 3D Cartesian coordinates on a unit sphere */ static cartesian(lambda: number, phi: number): [number, number, number] { lambda = this.toRadians(lambda); phi = this.toRadians(phi); const cosPhi = Math.cos(phi); return [ cosPhi * Math.cos(lambda), cosPhi * Math.sin(lambda), Math.sin(phi) ]; } /** * Converts 3D Cartesian coordinates to [longitude, latitude] in degrees */ static spherical(cartesian: [number, number, number]): [number, number] { const [x, y, z] = cartesian; return [ this.toDegrees(Math.atan2(y, x)), this.toDegrees(Math.asin(Math.max(-1, Math.min(1, z)))) ]; } /** * Calculates the dot product of two vectors */ static dot(a: number[], b: number[]): number { if (a.length !== b.length) { throw new Error('Vectors must have the same length'); } return Math.max(-1, Math.min(1, a.reduce((sum, _, i) => sum + a[i] * b[i], 0))); } /** * Calculates the cross product of two 3D vectors */ static cross(a: [number, number, number], b: [number, number, number]): [number, number, number] { return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; } /** * Normalizes a vector to unit length */ static normalize(v: number[]): number[] { const length = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0)); if (length === 0) { throw new Error('Cannot normalize zero-length vector'); } return v.map(x => x / length); } /** * Creates a quaternion that rotates vector v0 to align with vector v1 */ static quaternion(v0: [number, number, number], v1: [number, number, number]): [number, number, number, number] { if (!v0 || !v1) { throw new Error('Both vectors are required'); } // Normalize input vectors const normalized0 = this.normalize(v0) as [number, number, number]; const normalized1 = this.normalize(v1) as [number, number, number]; const dot = this.dot(normalized0, normalized1); // If vectors are parallel, return identity quaternion if (dot >= 0.999999) { return [1, 0, 0, 0]; } // If vectors are anti-parallel, rotate 180Â° around any perpendicular axis if (dot <= -0.999999) { const axis = Math.abs(normalized0[0]) < 0.1 ? this.cross(normalized0, [1, 0, 0]) : this.cross(normalized0, [0, 1, 0]); const normalizedAxis = this.normalize(axis); return [0, ...normalizedAxis] as [number, number, number, number]; } const w = this.cross(normalized0, normalized1); const theta = Math.acos(dot); const wlen = Math.sqrt(w.reduce((sum, x) => sum + x * x, 0)); if (wlen < 1e-10) { return [1, 0, 0, 0]; } const sinHalfTheta = Math.sin(theta / 2); return [ Math.cos(theta / 2), (w[0] / wlen) * sinHalfTheta, (w[1] / wlen) * sinHalfTheta, (w[2] / wlen) * sinHalfTheta ]; } /** * Multiplies two quaternions */ static multiply(a: [number, number, number, number], b: [number, number, number, number]): [number, number, number, number] { return [ a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3], a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2], a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1], a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0] ]; } /** * Converts a quaternion to a rotation matrix */ static quaternionToMatrix(q: [number, number, number, number]): number[] { const [w, x, y, z] = this.normalize(q) as [number, number, number, number]; const xx = x * x, yy = y * y, zz = z * z; const xy = x * y, xz = x * z, yz = y * z; const wx = w * x, wy = w * y, wz = w * z; return [ 1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy), 2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx), 2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy) ]; } /** * Converts a rotation matrix to Euler angles [phi, theta, psi] in degrees */ static matrixToEuler(matrix: number[]): [number, number, number] { const [m11, m12, m13, m21, m22, m23, m31, m32, m33] = matrix; let phi: number, theta: number, psi: number; if (Math.abs(m31) !== 1) { theta = -Math.asin(Math.max(-1, Math.min(1, m31))); const cosTheta = Math.cos(theta); phi = Math.atan2(m32 / cosTheta, m33 / cosTheta); psi = Math.atan2(m21 / cosTheta, m11 / cosTheta); } else { // Gimbal lock case phi = 0; if (m31 === -1) { theta = Math.PI / 2; psi = phi + Math.atan2(m12, m13); } else { theta = -Math.PI / 2; psi = -phi + Math.atan2(-m12, -m13); } } return [ this.toDegrees(phi), this.toDegrees(theta), this.toDegrees(psi) ]; } /** * Creates a quaternion from Euler angles [phi, theta, psi] in degrees */ static eulerToQuaternion(euler: [number, number, number]): [number, number, number, number] { const [phi, theta, psi] = euler.map(this.toRadians); const c1 = Math.cos(phi / 2); const c2 = Math.cos(theta / 2); const c3 = Math.cos(psi / 2); const s1 = Math.sin(phi / 2); const s2 = Math.sin(theta / 2); const s3 = Math.sin(psi / 2); return [ c1 * c2 * c3 + s1 * s2 * s3, s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3 ]; } /** * Interpolates between two quaternions using spherical linear interpolation (slerp) */ static slerp(q1: [number, number, number, number], q2: [number, number, number, number], t: number): [number, number, number, number] { // Normalize quaternions const n1 = this.normalize(q1) as [number, number, number, number]; const n2 = this.normalize(q2) as [number, number, number, number]; // Calculate cosine of angle between quaternions let dot = this.dot(n1, n2); // If quaternions are very close, use linear interpolation if (Math.abs(dot) > 0.9995) { const result = n1.map((x, i) => x + t * (n2[i] - x)); return this.normalize(result) as [number, number, number, number]; } // Ensure shortest path if (dot < 0) { n2.forEach((_, i) => n2[i] = -n2[i]); dot = -dot; } // Clamp dot product to valid range dot = Math.max(-1, Math.min(1, dot)); const theta0 = Math.acos(dot); const theta = theta0 * t; const sinTheta = Math.sin(theta); const sinTheta0 = Math.sin(theta0); const s1 = Math.cos(theta) - dot * sinTheta / sinTheta0; const s2 = sinTheta / sinTheta0; return [ s1 * n1[0] + s2 * n2[0], s1 * n1[1] + s2 * n2[1], s1 * n1[2] + s2 * n2[2], s1 * n1[3] + s2 * n2[3] ]; } /** * Converts a rotation in [longitude, latitude, rotation] format to a quaternion */ static rotationToQuaternion(rotation: [number, number, number]): [number, number, number, number] { const [lambda, phi, gamma] = rotation.map(this.toRadians); const cLambda = Math.cos(lambda / 2); const sLambda = Math.sin(lambda / 2); const cPhi = Math.cos(phi / 2); const sPhi = Math.sin(phi / 2); const cGamma = Math.cos(gamma / 2); const sGamma = Math.sin(gamma / 2); return [ cLambda * cPhi * cGamma - sLambda * sPhi * sGamma, sLambda * cPhi * cGamma + cLambda * sPhi * sGamma, cLambda * sPhi * cGamma - sLambda * cPhi * sGamma, cLambda * cPhi * sGamma + sLambda * sPhi * cGamma ]; } /** * Converts a quaternion to [longitude, latitude, rotation] in degrees */ static quaternionToRotation(q: [number, number, number, number]): [number, number, number] { const normalized = this.normalize(q) as [number, number, number, number]; const [w, x, y, z] = normalized; const sinPhi = 2 * (w * y - z * x); let phi = Math.asin(Math.max(-1, Math.min(1, sinPhi))); const lambda = Math.atan2( 2 * (w * x + y * z), 1 - 2 * (x * x + y * y) ); const gamma = Math.atan2( 2 * (w * z + x * y), 1 - 2 * (y * y + z * z) ); return [ this.toDegrees(lambda), this.toDegrees(phi), this.toDegrees(gamma) ]; } }
|   |   |   +-- map-view
|   |   |   |   +-- data.provider.ts: // src/app/matrix/ixt-matrix.provider.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { AirportCodeEditorComponent, ColumnConfigs, CoordinateEditorComponent, IxtDialogService } from '@dvanauken/ixtlan/dist/ixtlan'; @Injectable({ providedIn: 'root' }) export class DataProvider { constructor( private http: HttpClient, private dialogService: IxtDialogService ) {} getColumnConfigs(): ColumnConfigs { return { code: { type: AirportCodeEditorComponent as any, field: 'code', editable: true, label: 'IATA Code' }, region: { type: 'text', field: 'region', label: 'Region', editable: true }, name: { type: 'text', field: 'name', label: 'Name', editable: true }, city: { type: 'text', field: 'city', label: 'City', editable: true }, country: { type: 'text', field: 'country', label: 'Country', editable: true }, lat: { type: CoordinateEditorComponent, field: 'lat', label: 'LAT', editable: true }, lon: { type: CoordinateEditorComponent, field: 'lon', label: 'LON', editable: true } }; } getAirportData(): Observable<any[]> { return this.http.get<any[]>('assets/Airport.json'); } getAirportColumnConfigs(): ColumnConfigs { return this.getColumnConfigs(); } }
|   |   |   |   +-- map-view.component.html: <div *ngIf="isLoading" class="loading-container"> <img src="assets/spinner.gif" alt="Loading..." /> </div> <div *ngIf="!isLoading" class="map-view-container"> <app-double-pane> <app-pane class="left-panel"> <app-map #map></app-map> </app-pane> <app-pane class="right-panel"> <ixt-tabset title="Employee Form"> <ixt-tab title="City Pairs"> <app-table></app-table> </ixt-tab> <ixt-tab title="City Editor"> <ixt-matrix [data]="airportData" [columnConfigs]="matrixColumnConfigs" *ngIf="airportData.length"> </ixt-matrix> <ixt-matrix> </ixt-matrix> <ixt-table [data]="airportData" [config]="tableConfig"> </ixt-table> </ixt-tab> <ixt-tab title="Style Editor"> <h1></h1> <style-editor></style-editor> </ixt-tab> </ixt-tabset> </app-pane> </app-double-pane> </div>
|   |   |   |   +-- map-view.component.scss: :host { display: block; height: 100%; width: 100%; } .map-view-container { height: 100%; width: 100%; display: flex; flex-direction: column; } app-double-pane { flex: 1; min-height: 0; // Important for flex child scrolling } .left-panel, .right-panel { height: 100%; overflow: hidden; } .left-panel { app-map { height: 100%; width: 100%; display: block; } }
|   |   |   |   \-- map-view.component.ts: import { AfterViewInit, ChangeDetectorRef, Component, OnInit, ViewChild } from '@angular/core'; import { MatPaginator } from '@angular/material/paginator'; import { MatTableDataSource } from "@angular/material/table"; import { MatIconModule } from '@angular/material/icon'; import { MatTooltipModule } from '@angular/material/tooltip'; import { Feature, LineString, FeatureCollection } from 'geojson'; import { Observable } from 'rxjs'; import * as Papa from 'papaparse'; //import { TableConfig } from '@dvanauken/ixtlan'; import { TableConfig } from '@dvanauken/ixtlan/dist/ixtlan'; import { ITabContent, ITabsetConfig } from '@dvanauken/ixtlan/dist/ixtlan'; import { AirportData } from 'src/app/interfaces/airport-data.interface'; import { DataService } from 'src/app/services/data.service'; import { Resources } from 'src/app/services/resources'; import { Layer } from 'src/app/models/layer'; import { DataProvider } from './data.provider'; @Component({ selector: 'map-view', templateUrl: './map-view.component.html', styleUrls: ['./map-view.component.scss'] }) export class MapViewComponent implements OnInit, AfterViewInit { @ViewChild(MatPaginator, { static: false }) paginator: MatPaginator; title = 'Airport and Route Manager'; isLoading = true; displayedColumns: string[] = ['code', 'region', 'name', 'city', 'country', 'lat', 'lon']; //airportData = new MatTableDataSource<AirportData>([]); airportData: AirportData[] = []; countries: Layer | null = null; routes: Layer | null = null; airports: Layer | null = null; selectedFeatures$: Observable<Feature[]>; layers: Layer[] = []; formatCoord = (coord: number) => coord.toFixed(1); matrixColumnConfigs = this.dataProvider.getAirportColumnConfigs(); tableConfig: TableConfig<AirportData> = { columns: [ { key: 'code', header: 'Code' }, { key: 'name', header: 'Name' }, { key: 'city', header: 'City' }, { key: 'country', header: 'Country' }, { key: 'lat', header: 'Latitude' }, { key: 'lon', header: 'Longitude' } ], selectionMode: 'multiple', allowAdd: false, allowEdit: false, allowDelete: false }; tabConfig: ITabsetConfig = { showNotificationBand: true, notificationText: 'ðŸ—ºï¸ GeoView Navigation', animationDuration: 300 }; tabs: ITabContent[] = [ { id: 'map', title: 'Map', content: '', active: true }, { id: 'airports', title: 'Airports', content: '', active: false }, { id: 'style', title: 'Style Editor', content: '', active: false } ]; constructor( private cdr: ChangeDetectorRef, private dataService: DataService, public dataProvider: DataProvider, ) { this.selectedFeatures$ = this.dataService.getSelectedFeatures(); } ngOnInit(): void { (async () => { try { const loadedData = await Resources.load(["assets/Airport.json"]); if (loadedData.length === 0 || !loadedData[0].data) { throw new Error('Invalid airport data structure'); } this.dataService.setAirports(loadedData[0].data); console.log('Airports loaded and set in DataService.'); this.airportData = this.dataService.getAirports(); //this.airportData = new MatTableDataSource<AirportData>(this.dataService.getAirports()); //console.log('Loaded airport data for display:', this.airportData.data); const files = await Resources.load(['assets/110m/countries.geojson', 'assets/routes.json', 'assets/pa.csv']); files.forEach(({ data, path }) => { if (path.endsWith('countries.geojson')) { this.dataService.addLayer('countries', new Layer('FeatureCollection', data.features || data)); console.log("countries.geojson:path=" + path + ", data=" + data.features.length); } else if (path.endsWith('routes.json')) { // Ensure `airports[0].data` contains airport data for lookups //const airportData = airports[0].data; const hubs = ['ATL', 'SLC', 'MSP', 'DTW', 'JFK', 'AUS', 'CVG', 'LAX', 'SEA', 'BOS', 'LGA', 'DCA', 'RDU', 'DFW']; // List of DL hubs // Create GeoJSON features for routes based on base and ref lookups using map and filter const features = data .filter((route: { al: string }) => route.al === 'DL') // Filter for routes with `al: DL` .filter((route: { base: string; ref: string }) => !hubs.includes(route.base) && !hubs.includes(route.ref)) // Exclude routes with hubs as base or ref .map((route: { base: string; ref: string; al: string }) => { // Find the base and ref coordinates from airportData const baseAirport = this.dataService.getAirports().find((airport: any) => airport.code === route.base); const refAirport = this.dataService.getAirports().find((airport: any) => airport.code === route.ref); // Return a feature if both airports are found; otherwise, return null return (baseAirport && refAirport) ? { type: 'Feature', id: `${route.base}-${route.ref}-${route.al}`, // Ensure each feature has a unique ID geometry: { type: 'LineString', coordinates: [ [baseAirport.lon, baseAirport.lat], [refAirport.lon, refAirport.lat] ] }, properties: { id: `${route.base}-${route.ref}-${route.al}`, // Ensure each feature has a unique ID Airline: route.al, base: route.base, ref: route.ref, 'City 1': `${baseAirport.city}`, 'City 2': `${refAirport.city}`, 'Coords 1': [this.formatCoord(baseAirport.lon), this.formatCoord(baseAirport.lat)], 'Coords 2': [this.formatCoord(refAirport.lon), this.formatCoord(refAirport.lat)] }, } : null; }) .filter(feature => feature !== null) as GeoJSON.Feature[]; // Filter out null values this.dataService.addLayer('routes', new Layer("routes", features)); } else if (path.endsWith('pa.csv')) { console.log("pa.csv:path=" + path + ", data=" + data.length); // Print sample data for verification console.log('Filtered data sample:', data.filter(row => row['origin'] && row['destination']).slice(0, 3)); const cityPairSet = new Set(); const features = data .filter(row => row['origin'] && row['destination']) .map(row => { const base = (row['origin'] < row['destination']) ? row['origin'] : row['destination']; const ref = (row['origin'] < row['destination']) ? row['destination'] : row['origin']; // Ensure base and ref are not the same if (base === ref) { return null; } // Create a unique key for the city pair const pairKey = `${base}-${ref}-PA`; // Include airline in uppercase in the key if (cityPairSet.has(pairKey)) { return null; // Skip if the pair already exists } cityPairSet.add(pairKey); // Get the airport data directly from DataService const baseAirport = this.dataService.getAirport(base); const refAirport = this.dataService.getAirport(ref); // Ensure both coordinates are valid if (!baseAirport || !refAirport) { return null; } // const originCoords = ; // const destinationCoords = ; return { type: 'Feature', id: pairKey, // Assign the unique pair key with the airline as the id geometry: { type: 'LineString', coordinates: [[baseAirport.lon, baseAirport.lat], [refAirport.lon, refAirport.lat]] }, properties: { id: pairKey, Airline: 'PA', base: base, ref: ref, 'City 1': baseAirport.city, 'City 2': refAirport.city, 'Coords 1': [this.formatCoord(baseAirport.lon), this.formatCoord(baseAirport.lat)], 'Coords 2': [this.formatCoord(refAirport.lon), this.formatCoord(refAirport.lat)] } }; }) .filter(feature => feature !== null) .sort((a, b) => a.id.localeCompare(b.id)); // Sort features by id in alphabetical order // Print the sorted features for verification console.log('Sorted Features:', features.length); // Optional: Add the features to DataService as a new layer this.dataService.addLayer('PA', new Layer("PA", features)); } }); //console.log('All resource loading completed.'); this.dataService.setSelectedLayer("routes"); this.isLoading = false; } catch (err) { //console.error('An error occurred during loading:', err); this.isLoading = false; } })(); } ngAfterViewInit(): void { // setTimeout(() => { // if (this.paginator) { // //this.airportData.paginator = this.paginator; // this.cdr.detectChanges(); // console.log("Paginator linked successfully"); // } else { // console.warn("Paginator not found"); // } // }); } // onTabChange(event: any): void { // if (event.index === 1) { // Airport tab index // setTimeout(() => { // if (this.paginator) { // //this.airportData.paginator = this.paginator; // this.cdr.detectChanges(); // } // }); // } // } onLayerSelect(layerName: string): void { this.dataService.setSelectedLayer(layerName); } onTabChange(tab: ITabContent): void { if (tab.id === 'airports') { setTimeout(() => { if (this.paginator) { this.cdr.detectChanges(); } }); } } }
|   |   |   +-- pane
|   |   |   |   +-- double-pane
|   |   |   |   |   +-- double-pane.component.html: <div #container class="double-pane-container"> <ng-content select="app-pane.left-panel"></ng-content> <div #divider class="divider" (mousedown)="onMouseDown($event)" [style.left]="dividerPosition"></div> <ng-content select="app-pane.right-panel"></ng-content> </div>
|   |   |   |   |   +-- double-pane.component.scss: :host { display: block; width: 100%; height: 100%; } .double-pane-container { display: flex; /* Flex layout for left and right panels */ width: 100%; /* Full width of the container */ height: 100%; /* Full height of the container */ position: relative; /* For positioning the divider */ } .left-panel { flex: 0 0 50%; /* Start with 50% width, allow resizing */ max-width: 50%; /* Prevent overflow */ display: flex; /* Use flex for centering */ justify-content: center; /* Horizontally center the content */ align-items: center; /* Vertically center the content */ overflow: hidden; /* Prevent overflow scrollbars */ } .right-panel { flex: 1; /* Take up remaining space */ height: 100%; /* Full height for the right pane */ overflow: auto; /* Allow scrolling if necessary */ } .divider { position: absolute; top: 0; bottom: 0; width: 5px; background-color: #ccc; cursor: col-resize; z-index: 10; /* Ensure the divider stays on top */ }
|   |   |   |   |   \-- double-pane.component.ts: import { Component, ElementRef, ViewChild, AfterViewInit, AfterContentInit, ContentChildren, QueryList, OnDestroy, ChangeDetectorRef } from '@angular/core'; import { fromEvent, Subscription } from 'rxjs'; import { throttleTime, takeUntil } from 'rxjs/operators'; import { PaneComponent } from '../pane/pane.component'; import { MapComponent } from '../../map/map.component'; // Correct import @Component({ selector: 'app-double-pane', templateUrl: './double-pane.component.html', styleUrls: ['./double-pane.component.scss'] }) export class DoublePaneComponent implements AfterViewInit, AfterContentInit, OnDestroy { @ViewChild('map', { static: false }) mapComponent!: MapComponent; // Use template reference @ViewChild('divider', { static: true }) divider!: ElementRef; @ViewChild('container', { static: true }) container!: ElementRef; @ContentChildren(PaneComponent) panes!: QueryList<PaneComponent>; isDragging = false; leftPaneWidth = 50; dividerPosition = '50%'; private subscriptions: Subscription = new Subscription(); constructor(private cdr: ChangeDetectorRef) {} ngAfterViewInit(): void { //console.log('ngAfterViewInit: Checking if MapComponent is detected.'); //console.log('MapComponent:', this.mapComponent); this.updatePaneWidths(); } ngAfterContentInit() { //console.log('DoublePaneComponent - ngAfterContentInit'); //console.log('Number of panes:', this.panes.length); } ngOnDestroy(): void { this.subscriptions.unsubscribe(); } onMouseDown(event: MouseEvent): void { event.preventDefault(); this.isDragging = true; const moveSubscription = fromEvent<MouseEvent>(document, 'mousemove').pipe( takeUntil(fromEvent(document, 'mouseup')), throttleTime(16) // Approx. 60fps ).subscribe(e => this.resize(e.clientX)); const upSubscription = fromEvent(document, 'mouseup').subscribe(() => { this.isDragging = false; moveSubscription.unsubscribe(); upSubscription.unsubscribe(); }); this.subscriptions.add(moveSubscription); this.subscriptions.add(upSubscription); } resize(x: number): void { const containerRect = this.container.nativeElement.getBoundingClientRect(); const containerWidth = containerRect.width; const newLeftWidth = ((x - containerRect.left) / containerWidth) * 100; this.leftPaneWidth = Math.max(10, Math.min(90, newLeftWidth)); this.dividerPosition = `${this.leftPaneWidth}%`; this.updatePaneWidths(); } private updatePaneWidths(): void { //console.log('Updating pane widths...'); const paneArray = this.panes.toArray(); //console.log('Pane array:', paneArray); if (paneArray.length === 2) { //console.log(`Setting left pane width to ${this.leftPaneWidth}%`); paneArray[0].setWidth(`${this.leftPaneWidth}%`); //console.log(`Setting right pane width to ${100 - this.leftPaneWidth}%`); paneArray[1].setWidth(`${100 - this.leftPaneWidth}%`); this.cdr.detectChanges(); //console.log('Change detection triggered.'); //// Ensure the map component exists and trigger its resize logic //if (this.mapComponent) { // console.log('Calling resizeMap on the MapComponent instance.'); // this.mapComponent.resizeMap(); //} else { // console.warn('MapComponent instance not found.'); //} } else { console.warn('Expected 2 panes, but found:', paneArray.length); } } }
|   |   |   |   +-- pane
|   |   |   |   |   +-- pane.component.html: <ng-content></ng-content>
|   |   |   |   |   +-- pane.component.scss: :host { display: block; height: 100%; overflow: auto; }
|   |   |   |   |   \-- pane.component.ts: import { Component, ElementRef, Renderer2, ChangeDetectorRef, AfterContentInit } from '@angular/core'; @Component({ selector: 'app-pane', templateUrl: './pane.component.html', styleUrls: ['./pane.component.scss'] }) export class PaneComponent implements AfterContentInit { constructor( public elementRef: ElementRef, private renderer: Renderer2, private cdr: ChangeDetectorRef ) {} ngAfterContentInit() { //console.log('PaneComponent - ngAfterContentInit'); //console.log('Pane content:', this.el.nativeElement.innerHTML); } setWidth(width: string) { //console.log('Setting pane width:', width); this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); this.cdr.detectChanges(); // Force change detection } }
|   |   |   |   \-- pane.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { PaneComponent } from './pane/pane.component'; import { DoublePaneComponent } from './double-pane/double-pane.component'; @NgModule({ declarations: [PaneComponent, DoublePaneComponent], imports: [CommonModule], exports: [PaneComponent, DoublePaneComponent] }) export class PaneModule { }
|   |   |   +-- perspective
|   |   |   |   +-- Perspective.ts: import * as d3 from 'd3'; import * as topojson from 'topojson-client'; import { geoSatellite } from 'd3-geo-projection'; interface PerspectiveParams { longitude: number; latitude: number; altitude: number; rotation: number; tilt: number; fieldOfView: number; } class Perspective { private params: PerspectiveParams; private earthRadius: number; private degrees: number; private snyderP: number | null; private dY: number | null; private dZ: number | null; private visibleYextent: number | null; private scale: number | null; private yShift: number | null; private numPixelsY: number | null; private width: number | null; private projection: any | null; private preclip: any | null; private grid: any | null; private land: any | null; private land50: any | null; private land110: any | null; private geoClipCircle: any; constructor() { this.params = { longitude: -85, latitude: 18, altitude: 1024, rotation: 15, tilt: 45, fieldOfView: 25 }; this.earthRadius = 6371; this.degrees = 180 / Math.PI; this.snyderP = null; this.dY = null; this.dZ = null; this.visibleYextent = null; this.scale = null; this.yShift = null; this.numPixelsY = null; this.width = null; this.projection = null; this.preclip = null; this.grid = null; this.land = null; this.land50 = null; this.land110 = null; // Bind methods that are used as callbacks this.geoPipeline = this.geoPipeline.bind(this); this.geoRotatePhi = this.geoRotatePhi.bind(this); this.geoClipCircle = d3.geoClipCircle; } public init(width: number): Promise<Perspective> { this.width = width; this.numPixelsY = width * 0.6; this.setupGrid(); this.calculateAll(); return this.loadMapData(); } public updateParams(newParams: Partial<PerspectiveParams>): void { Object.assign(this.params, newParams); this.calculateAll(); } public async loadMapData(): Promise<Perspective> { try { const [land50Response, land110Response] = await Promise.all([ fetch('https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json'), fetch('https://cdn.jsdelivr.net/npm/world-atlas@1/world/110m.json') ]); const world50 = await land50Response.json(); const world110 = await land110Response.json(); this.land50 = topojson.feature(world50, world50.objects.land); this.land110 = topojson.feature(world110, world110.objects.land); this.land = this.land50; return this; } catch (error) { console.error('Failed to load map data:', error); throw error; } } private setupGrid(): void { this.grid = { major: d3.geoGraticule().step([15, 15])(), minor: d3.geoGraticule().step([5, 5])(), horizon: { type: "Sphere" } }; } private calculateAll(): void { this.snyderP = this.calculateSnyderP(); [this.dY, this.dZ] = this.calculateOffsets(); this.visibleYextent = this.calculateVisibleExtent(); this.scale = this.calculateScale(); this.yShift = this.calculateYShift(); this.updateProjection(); } private calculateSnyderP(): number { return 1.0 + this.params.altitude / this.earthRadius; } private calculateOffsets(): [number, number] { const tiltRad = this.params.tilt / this.degrees; const dY = this.params.altitude * Math.sin(tiltRad); const dZ = this.params.altitude * Math.cos(tiltRad); return [dY, dZ]; } private calculateVisibleExtent(): number { const fovRad = 0.5 * this.params.fieldOfView / this.degrees; return 2 * this.dZ! * Math.tan(fovRad); } private calculateScale(): number { return this.earthRadius * this.numPixelsY! / this.visibleYextent!; } private calculateYShift(): number { return this.dY! * this.numPixelsY! / this.visibleYextent!; } private updateProjection(): void { this.preclip = this.createPreclip(); this.projection = geoSatellite() .scale(this.scale) .translate([this.width! / 2, this.yShift! + this.numPixelsY! / 2]) .rotate([-this.params.longitude, -this.params.latitude, this.params.rotation]) .tilt(this.params.tilt) .distance(this.snyderP) .preclip(this.preclip) .precision(0.1); } private createPreclip(): any { const tilt = this.params.tilt / this.degrees; const alpha = Math.acos(this.snyderP! * Math.cos(tilt) * 0.999); const clipDistance = this.geoClipCircle(Math.acos(1 / this.snyderP!) - 1e-6); if (!alpha) return clipDistance; return this.geoPipeline( clipDistance, this.geoRotatePhi(Math.PI + tilt), this.geoClipCircle(Math.PI - alpha - 1e-4), this.geoRotatePhi(-Math.PI - tilt) ); } private geoPipeline(...transforms: any[]): any { return (sink: any) => { for (let i = transforms.length - 1; i >= 0; --i) { sink = transforms[i](sink); } return sink; }; } private geoRotatePhi(deltaPhi: number): any { const cosDeltaPhi = Math.cos(deltaPhi); const sinDeltaPhi = Math.sin(deltaPhi); return (sink: any) => ({ point(lambda: number, phi: number) { const cosPhi = Math.cos(phi); const x = Math.cos(lambda) * cosPhi; const y = Math.sin(lambda) * cosPhi; const z = Math.sin(phi); const k = z * cosDeltaPhi + x * sinDeltaPhi; sink.point(Math.atan2(y, x * cosDeltaPhi - z * sinDeltaPhi), Math.asin(k)); }, lineStart() { sink.lineStart(); }, lineEnd() { sink.lineEnd(); }, polygonStart() { sink.polygonStart(); }, polygonEnd() { sink.polygonEnd(); }, sphere() { sink.sphere(); } }); } public draw(context: CanvasRenderingContext2D): void { if (!this.projection || !this.land) return; const path = d3.geoPath(this.projection, context); context.clearRect(0, 0, this.width!, this.numPixelsY!); context.fillStyle = "#88d"; context.beginPath(); path(this.land); context.fill(); context.beginPath(); path(this.grid.major); context.strokeStyle = "#ddf"; context.globalAlpha = 0.8; context.stroke(); context.beginPath(); path(this.grid.horizon); context.strokeStyle = "#000"; context.globalAlpha = 1; context.stroke(); const el = document.querySelector('input[name="altitude"]'); const kmValue = this.params.altitude; const milesValue = kmValue * 0.621371; if (el?.nextElementSibling) { el.nextElementSibling.textContent = `${milesValue.toLocaleString()} miles`; } } public setResolution(useHighRes: boolean): void { this.land = useHighRes ? this.land50 : this.land110; } } export default Perspective;
|   |   |   |   +-- perspective.component.html: <div class="controls"> <h3>Satellite Position</h3> <label> <input name="longitude" type="range" min="-180" max="180" value="-85" step="any"> Longitude = <output>-85Â°</output> </label> <label> <input name="latitude" type="range" min="-90" max="90" value="18" step="any"> Latitude = <output>18Â°</output> </label> <label> <input name="altitude" type="range" min="3" max="15" value="10" step="0.1"> Altitude = <output>1024 km</output> </label> </div> <div class="controls"> <h3>Camera Properties</h3> <label> <input name="rotation" type="range" min="-180" max="180" value="15" step="2"> Rotation = <output>15Â°</output> </label> <label> <input name="tilt" type="range" min="0" max="89" value="45" step="1"> Tilt = <output>45Â°</output> </label> <label> <input name="fieldOfView" type="range" min="1" max="175" value="30" step="1"> Field of View = <output>30Â°</output> </label> </div> <canvas #mapCanvas></canvas>
|   |   |   |   +-- perspective.component.scss: .controls { display: inline-block; border: 1px solid red; padding: 8px; margin: 5px 5px 0 5px; width: 345px; label { display: block; } input[type="range"] { width: 180px; } }
|   |   |   |   \-- perspective.component.ts: import { Component, OnInit, ViewChild, ElementRef, AfterViewInit } from '@angular/core'; import Perspective from './Perspective'; import * as d3 from 'd3'; import * as topojson from 'topojson-client'; import { geoSatellite } from 'd3-geo-projection'; @Component({ selector: 'app-perspective', templateUrl: './perspective.component.html', styleUrls: ['./perspective.component.scss'] }) export class PerspectiveComponent implements OnInit, AfterViewInit { @ViewChild('mapCanvas') canvas!: ElementRef<HTMLCanvasElement>; private context!: CanvasRenderingContext2D; private width!: number; private perspective!: Perspective; ngOnInit() { // this.width = window.innerWidth * 0.8; // Add this // this.initializePerspective(); } // ngAfterViewInit() { // // Move canvas setup here // this.setupCanvas(); // this.setupControls(); // } ngAfterViewInit() { this.setupCanvas(); // First set up canvas and get width this.setupControls(); // Set up controls this.initializePerspective(); // Then initialize perspective which needs canvas width } private setupCanvas(): void { const canvas = this.canvas.nativeElement; this.width = window.innerWidth * 0.8; canvas.width = this.width; canvas.height = this.width * 0.6; this.context = canvas.getContext('2d')!; } private async initializePerspective(): Promise<void> { this.perspective = new Perspective(); await this.perspective.init(this.width); this.updateView(); } private setupControls(): void { document.querySelectorAll('input[type="range"]').forEach(input => { input.addEventListener('input', this.handleInput.bind(this)); }); this.canvas.nativeElement.addEventListener('mousedown', () => { this.perspective?.setResolution(false); this.updateView(); }); this.canvas.nativeElement.addEventListener('mouseup', () => { this.perspective?.setResolution(true); this.updateView(); }); } handleInput(event: Event): void { const input = event.target as HTMLInputElement; const value = input.valueAsNumber; const name = input.name; let displayValue = value; if (name === 'altitude') { displayValue = Math.pow(2, value); input.nextElementSibling!.textContent = `${displayValue.toFixed(0)} km`; } else { input.nextElementSibling!.textContent = `${value.toFixed(name === 'longitude' || name === 'latitude' ? 2 : 0)}Â°`; } if (this.perspective) { const params: {[key: string]: number} = {}; params[name] = name === 'altitude' ? Math.pow(2, value) : value; this.perspective.updateParams(params); this.updateView(); } } private updateView(): void { if (this.perspective) { this.perspective.draw(this.context); } } }
|   |   |   +-- projections
|   |   |   |   +-- albers
|   |   |   |   |   +-- albers.component.html: <div id="map-container"></div>
|   |   |   |   |   +-- albers.component.scss: :host { display: block; width: 100%; height: 100%; } #map-container { width: 100%; height: 100%; background: #eee; } path.district-boundaries { fill: lightgrey; stroke: grey; stroke-width: 0.5; }
|   |   |   |   |   \-- albers.component.ts: import { Component, OnInit, ElementRef, ViewEncapsulation } from '@angular/core'; import * as d3 from 'd3'; import * as topojson from 'topojson-client'; import { Topology, Objects, GeometryCollection } from 'topojson-specification'; interface StateConfig { code: string; } @Component({ selector: 'app-albers', templateUrl: './albers.component.html', styleUrls: ['./albers.component.scss'], encapsulation: ViewEncapsulation.None }) export class AlbersComponent implements OnInit { private readonly states: StateConfig[] = [ { code: 'al' }, { code: 'ak' }, { code: 'az' }, { code: 'ar' }, { code: 'ca' }, { code: 'co' }, { code: 'ct' }, { code: 'de' }, { code: 'fl' }, { code: 'ga' }, { code: 'hi' }, { code: 'id' }, { code: 'il' }, { code: 'in' }, { code: 'ia' }, { code: 'ks' }, { code: 'ky' }, { code: 'la' }, { code: 'me' }, { code: 'md' }, { code: 'ma' }, { code: 'mi' }, { code: 'mn' }, { code: 'ms' }, { code: 'mo' }, { code: 'mt' }, { code: 'ne' }, { code: 'nv' }, { code: 'nh' }, { code: 'nj' }, { code: 'nm' }, { code: 'ny' }, { code: 'nc' }, { code: 'nd' }, { code: 'oh' }, { code: 'ok' }, { code: 'or' }, { code: 'pa' }, { code: 'ri' }, { code: 'sc' }, { code: 'sd' }, { code: 'tn' }, { code: 'tx' }, { code: 'ut' }, { code: 'vt' }, { code: 'va' }, { code: 'wa' }, { code: 'wv' }, { code: 'wi' }, { code: 'wy' } ]; constructor(private elementRef: ElementRef) { } ngOnInit(): void { const host = this.elementRef.nativeElement; const svg = d3.select(host.querySelector('#map-container')) .append('svg') .attr('xmlns', 'http://www.w3.org/2000/svg') .attr('viewBox', '0 0 975 610') .attr('width', '100%') .attr('height', '100%'); const zoom = d3.zoom() .scaleExtent([1, 8]) .on('zoom', (event) => { g.attr('transform', event.transform); }); svg.call(zoom); const projection = d3.geoAlbersUsa() .scale(1300) .translate([487.5, 305]); const path = d3.geoPath(projection); const g = svg.append('g'); Promise.all( this.states.map(state => fetch(`/assets/congress-3/us-districts-${state.code}-119.topojson`) .then(response => response.json()) ) ).then(districts => { const features = districts.flatMap(district => topojson.feature(district, district.objects.data as GeometryCollection).features ); g.selectAll('path') .data(features) .enter() .append('path') .attr('class', 'district-boundaries') .attr('d', path) .style('vector-effect', 'non-scaling-stroke') // This prevents stroke width scaling .on('click', (event, d) => { console.log('District Properties:'); Object.entries(d.properties).forEach(([key, value]) => { console.log(`${key}: ${value}`); }); }); }).catch(error => { console.error('Error loading the map data:', error); }); } }
|   |   |   |   +-- azimuthal
|   |   |   |   |   +-- gnomic
|   |   |   |   |   |   +-- gnomic.component.html
|   |   |   |   |   |   +-- gnomic.component.scss
|   |   |   |   |   |   \-- gnomic.component.ts
|   |   |   |   |   +-- orthographic
|   |   |   |   |   |   +-- orthographic.component.html: <div class="orthographic-container"> <canvas #canvas class="main-canvas"></canvas> <canvas #bufferCanvas class="buffer-canvas"></canvas> <canvas #mercatorCanvas class="reference-canvas"></canvas> </div>
|   |   |   |   |   |   +-- orthographic.component.scss: .orthographic-container { position: relative; width: 800px; height: 600px; border: 1px solid #ccc; background: #f0f0f0; .main-canvas { position: absolute; top: 0; left: 0; } .buffer-canvas { position: absolute; top: 0; left: 0; } .reference-canvas { position: absolute; top: 20px; right: 20px; background: white; border: 1px solid rgba(0,0,0,0.2); box-shadow: 0 2px 4px rgba(0,0,0,0.1); } }
|   |   |   |   |   |   \-- orthographic.component.ts: import { Component, OnInit, ElementRef, ViewChild, AfterViewInit, OnDestroy, NgZone } from '@angular/core'; import * as d3 from 'd3'; import * as topojson from 'topojson-client'; import versor from 'versor'; @Component({ selector: 'app-orthographic', templateUrl: './orthographic.component.html', styleUrls: ['./orthographic.component.scss'] }) export class OrthographicComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('canvas') canvasRef!: ElementRef<HTMLCanvasElement>; @ViewChild('bufferCanvas') bufferCanvasRef!: ElementRef<HTMLCanvasElement>; @ViewChild('mercatorCanvas') mercatorCanvasRef!: ElementRef<HTMLCanvasElement>; // Main view properties private readonly width = 800; private readonly height = 600; private readonly aspect = this.width / this.height; private readonly MINIMUM_SIZE = 20; private readonly MAX_SCALE = 2000; private readonly INITIAL_SCALE = 300; // Reference map properties private readonly REFERENCE_WIDTH = 300; private readonly REFERENCE_HEIGHT = 200; // Canvas contexts private context!: CanvasRenderingContext2D; private bufferContext!: CanvasRenderingContext2D; private mercatorContext!: CanvasRenderingContext2D; // Projections private projection!: d3.GeoProjection; private mercatorProjection!: d3.GeoProjection; private path!: d3.GeoPath; private mercatorPath!: d3.GeoPath; // Shared data private sphere: d3.GeoSphere = { type: "Sphere" }; private land50: any; private land110: any; private destroyed = false; // Rubber band state private isRubberBanding = false; private startX = 0; private startY = 0; private currentX = 0; private currentY = 0; private readonly keydownListener: (event: KeyboardEvent) => void; private readonly keyupListener: (event: KeyboardEvent) => void; constructor(private ngZone: NgZone) { this.keydownListener = this.handleKeyDown.bind(this); this.keyupListener = this.handleKeyUp.bind(this); } ngOnInit(): void { console.log('ngOnInit'); this.initializeProjections(); this.loadLandData(); } ngAfterViewInit(): void { console.log('ngAfterViewInit'); this.initializeCanvases(); console.log('Canvases initialized'); this.setupEventListeners(); console.log('Event listeners set up'); } ngOnDestroy(): void { this.destroyed = true; window.removeEventListener('keydown', this.keydownListener); window.removeEventListener('keyup', this.keyupListener); } private initializeCanvases(): void { console.log('Initializing canvases...'); const canvas = this.canvasRef.nativeElement; console.log('Main canvas:', canvas); canvas.width = this.width; canvas.height = this.height; this.context = canvas.getContext('2d')!; // Buffer canvas & context const bufferCanvas = this.bufferCanvasRef.nativeElement; bufferCanvas.style.pointerEvents = 'none'; // Ensure buffer isn't blocking console.log('Buffer canvas style:', bufferCanvas.style.pointerEvents); bufferCanvas.width = this.width; bufferCanvas.height = this.height; this.bufferContext = bufferCanvas.getContext('2d')!; // Reference map & context const mercatorCanvas = this.mercatorCanvasRef.nativeElement; mercatorCanvas.width = this.REFERENCE_WIDTH; mercatorCanvas.height = this.REFERENCE_HEIGHT; this.mercatorContext = mercatorCanvas.getContext('2d')!; // Create paths after contexts are initialized this.path = d3.geoPath(this.projection, this.context); this.mercatorPath = d3.geoPath(this.mercatorProjection, this.mercatorContext); } private initializeProjections(): void { this.projection = d3.geoOrthographic() .precision(0.1) .scale(this.INITIAL_SCALE) .translate([this.width / 2, this.height / 2]); this.mercatorProjection = d3.geoMercator() .scale(this.REFERENCE_WIDTH / 6) .center([0, 0]) .translate([this.REFERENCE_WIDTH / 2, this.REFERENCE_HEIGHT / 2]); } private async loadLandData(): Promise<void> { console.log('Loading land data...'); try { console.log('Fetching land data...'); const [response50, response110] = await Promise.all([ fetch('../../assets/land-50m.json'), fetch('../../assets/land-110m.json') ]); console.log('Response status:', response50.status, response110.status); if (!this.destroyed) { const world50 = await response50.json(); const world110 = await response110.json(); console.log('Loaded data:', world50, world110); this.land50 = topojson.feature(world50, world50.objects.land); this.land110 = topojson.feature(world110, world110.objects.land); console.log('Processed features:', this.land50, this.land110); this.render(this.land50); //this.renderReferenceMap(); } } catch (error) { console.error('Error loading land data:', error); } } private calculateViewportExtent(): GeoJSON.Feature<GeoJSON.Polygon> { const numPoints = 60; // Increased from 20 const points: [number, number][] = []; for (let i = 0; i <= numPoints; i++) { const t = i / numPoints; ['top', 'right', 'bottom', 'left'].forEach(edge => { const [x, y] = edge === 'top' ? [t * this.width, 0] : edge === 'right' ? [this.width, t * this.height] : edge === 'bottom' ? [(1 - t) * this.width, this.height] : [0, (1 - t) * this.height]; const point = this.projection.invert!([x, y]); if (point) points.push(point); }); } // Ensure the polygon is closed if (points.length > 0) points.push(points[0]); return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [points] } }; } private renderReferenceMap(): void { console.log('Rendering reference map...'); // Clear the reference map this.mercatorContext.clearRect(0, 0, this.REFERENCE_WIDTH, this.REFERENCE_HEIGHT); // Draw world outline this.mercatorContext.beginPath(); this.mercatorPath(this.sphere); this.mercatorContext.fillStyle = "#fff"; this.mercatorContext.fill(); // Draw land this.mercatorContext.beginPath(); this.mercatorPath(this.land110); this.mercatorContext.fillStyle = "#ddd"; this.mercatorContext.fill(); // Draw viewport extent const viewportExtent = this.calculateViewportExtent(); this.mercatorContext.beginPath(); this.mercatorPath(viewportExtent); this.mercatorContext.strokeStyle = "rgba(255, 0, 0, 0.8)"; this.mercatorContext.stroke(); } private setupEventListeners(): void { console.log('Setting up event listeners...'); this.setupDragHandlers(); this.setupRubberBandHandlers(); // Global key listeners window.addEventListener('keydown', this.keydownListener); window.addEventListener('keyup', this.keyupListener); } private handleKeyDown(event: KeyboardEvent): void { if (event.altKey) { this.bufferCanvasRef.nativeElement.style.pointerEvents = 'auto'; this.bufferCanvasRef.nativeElement.style.cursor = 'crosshair'; } if (event.key === 'Escape' && this.isRubberBanding) { this.isRubberBanding = false; this.bufferContext.clearRect(0, 0, this.width, this.height); } } private handleKeyUp(event: KeyboardEvent): void { if (!event.altKey) { this.bufferCanvasRef.nativeElement.style.pointerEvents = 'none'; this.bufferCanvasRef.nativeElement.style.cursor = 'default'; } } private setupRubberBandHandlers(): void { const bufferCanvas = this.bufferCanvasRef.nativeElement; bufferCanvas.addEventListener('mousedown', (event: MouseEvent) => { if (event.altKey) { this.isRubberBanding = true; this.startX = event.offsetX; this.startY = event.offsetY; const mousemove = (moveEvent: MouseEvent) => { this.currentX = moveEvent.offsetX; this.currentY = moveEvent.offsetY; this.drawRubberBand(); }; const mouseup = (upEvent: MouseEvent) => { this.isRubberBanding = false; bufferCanvas.removeEventListener('mousemove', mousemove); bufferCanvas.removeEventListener('mouseup', mouseup); this.bufferContext.clearRect(0, 0, this.width, this.height); // Apply zoom if selection is large enough if (Math.abs(this.currentX - this.startX) >= this.MINIMUM_SIZE && Math.abs(this.currentY - this.startY) >= this.MINIMUM_SIZE) { this.applyZoom(); } }; bufferCanvas.addEventListener('mousemove', mousemove); bufferCanvas.addEventListener('mouseup', mouseup); } }); } private setupDragHandlers(): void { let v0: [number, number, number]; let q0: number[]; let r0: [number, number, number]; const canvas = this.canvasRef.nativeElement; console.log('Setting up drag handlers, canvas:', canvas); canvas.addEventListener('click', () => { console.log('Canvas clicked'); }); canvas.style.pointerEvents = 'auto'; console.log('Current canvas style:', { position: canvas.style.position, pointerEvents: canvas.style.pointerEvents, zIndex: canvas.style.zIndex }); canvas.addEventListener('mousedown', (event: MouseEvent) => { console.log('Mouse down event triggered', event); if (!event.altKey) { const [x, y] = [event.offsetX, event.offsetY]; console.log('Mouse position:', x, y); const inverted = this.projection.invert!([x, y]); console.log('Inverted coordinates:', inverted); v0 = this.cartesian(inverted!); console.log('v0:', v0); r0 = this.projection.rotate(); console.log('r0:', r0); q0 = versor(r0); console.log('q0:', q0); const pointermove = (event: MouseEvent) => { console.log('Pointer move event'); const [x, y] = [event.offsetX, event.offsetY]; const v1 = this.cartesian(this.projection.rotate(r0).invert!([x, y])!); const deltaQ = versor.delta(v0, v1); const q1 = this.multiply(q0, deltaQ); this.projection.rotate(versor.rotation(q1)); this.render(this.land110 || this.land50); }; const pointerup = () => { console.log('Pointer up event'); canvas.removeEventListener('mousemove', pointermove); canvas.removeEventListener('mouseup', pointerup); this.render(this.land50); }; canvas.addEventListener('mousemove', pointermove); canvas.addEventListener('mouseup', pointerup); } }); } private drawRubberBand(): void { this.bufferContext.clearRect(0, 0, this.width, this.height); const redWidth = Math.abs(this.currentX - this.startX); const redHeight = Math.abs(this.currentY - this.startY); const redLeft = Math.min(this.startX, this.currentX); const redTop = Math.min(this.startY, this.currentY); // Draw red rectangle this.bufferContext.strokeStyle = 'rgba(255, 0, 0, 1)'; this.bufferContext.strokeRect(redLeft, redTop, redWidth, redHeight); // Show minimum size indicator if (redWidth < this.MINIMUM_SIZE || redHeight < this.MINIMUM_SIZE) { this.bufferContext.fillStyle = 'rgba(255, 0, 0, 0.3)'; this.bufferContext.fillRect(redLeft, redTop, redWidth, redHeight); return; } // Calculate gray rectangle dimensions let grayWidth: number; let grayHeight: number; const redAspect = redWidth / redHeight; if (redAspect > this.aspect) { grayWidth = redWidth; grayHeight = redWidth / this.aspect; } else { grayHeight = redHeight; grayWidth = redHeight * this.aspect; } // Center gray rectangle within red rectangle const grayLeft = redLeft + (redWidth - grayWidth) / 2; const grayTop = redTop + (redHeight - grayHeight) / 2; // Draw gray rectangle this.bufferContext.fillStyle = 'rgba(128, 128, 128, 0.3)'; this.bufferContext.fillRect(grayLeft, grayTop, grayWidth, grayHeight); } private applyZoom(): void { const redWidth = Math.abs(this.currentX - this.startX); const redHeight = Math.abs(this.currentY - this.startY); const redLeft = Math.min(this.startX, this.currentX); const redTop = Math.min(this.startY, this.currentY); let grayWidth: number; let grayHeight: number; const redAspect = redWidth / redHeight; if (redAspect > this.aspect) { grayWidth = redWidth; grayHeight = redWidth / this.aspect; } else { grayHeight = redHeight; grayWidth = redHeight * this.aspect; } // Calculate gray rectangle position const grayLeft = redLeft + (redWidth - grayWidth) / 2; const grayTop = redTop + (redHeight - grayHeight) / 2; // Calculate new scale based on gray rectangle const scale = this.projection.scale(); const newScale = Math.min(scale * (this.width / grayWidth), this.MAX_SCALE); // Calculate the center point of the gray rectangle const centerX = grayLeft + grayWidth / 2; const centerY = grayTop + grayHeight / 2; // Get the geographical coordinates of the center point const centerGeo = this.projection.invert!([centerX, centerY]); if (centerGeo) { // Update projection this.projection .scale(newScale) .center(centerGeo); // Render with new projection this.render(this.land110 || this.land50); } } private resetView(): void { this.projection .scale(this.INITIAL_SCALE) .rotate([0, 0, 0]) .translate([this.width / 2, this.height / 2]); this.render(this.land110 || this.land50); } private cartesian(coords: [number, number]): [number, number, number] { const [Î», Ï†] = coords.map(d => d * Math.PI / 180); return [ Math.cos(Ï†) * Math.cos(Î»), Math.cos(Ï†) * Math.sin(Î»), Math.sin(Ï†) ]; } private multiply(a: number[], b: number[]): [number, number, number, number] { return [ a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3], a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2], a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1], a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0] ]; } private render(land: any): void { console.log('Rendering main view...'); this.context.clearRect(0, 0, this.width, this.height); this.context.beginPath(); this.path(this.sphere); this.context.fillStyle = "#fff"; this.context.fill(); this.context.beginPath(); this.path(land); this.context.fillStyle = "#000"; this.context.fill(); this.context.beginPath(); this.path(this.sphere); this.context.stroke(); this.renderReferenceMap(); } }
|   |   |   |   |   \-- two-point
|   |   |   |   |       +-- two-point.compoment.html
|   |   |   |   |       +-- two-point.component.scss
|   |   |   |   |       \-- two-point.compoonent.ts
|   |   |   |   +-- conical
|   |   |   |   |   \-- lambert
|   |   |   |   |       +-- lambert.component.html: 
|   |   |   |   |       +-- lambert.component.scss: 
|   |   |   |   |       \-- lambert.component.ts: // lambert-map.model.ts export interface ParallelState { active: boolean; value: number; } export interface LambertMapState { parallel1: ParallelState; parallel2: ParallelState; centralParallel: number; } // lambert-map.component.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; import { geoPath, geoLambertConformal, geoGraticule30 } from 'd3-geo-projection'; import { feature } from 'topojson-client'; @Component({ selector: 'app-lambert-map', template: ` <section class="map-container"> <canvas #mapCanvas></canvas> <div class="controls"> <fieldset> <legend>Standard Parallels</legend> <div class="parallel-control"> <input type="checkbox" id="parallel1Toggle" [checked]="mapState.parallel1.active" (change)="toggleParallel(1)"> <input type="number" id="parallel1Value" [value]="mapState.parallel1.value" (input)="updateParallelValue(1, $event)"> </div> <div class="parallel-control"> <input type="checkbox" id="parallel2Toggle" [checked]="mapState.parallel2.active" (change)="toggleParallel(2)"> <input type="number" id="parallel2Value" [value]="mapState.parallel2.value" (input)="updateParallelValue(2, $event)"> </div> </fieldset> <div class="central-parallel"> <label for="centralValue">Central Parallel</label> <input type="number" id="centralValue" [value]="mapState.centralParallel" (input)="updateCentralParallel($event)"> </div> </div> </section> `, styles: [` :host { display: block; position: relative; } .map-container { position: relative; width: 100%; height: 100%; } canvas { width: 100%; height: 100%; } .controls { position: absolute; top: 1rem; right: 1rem; background: white; padding: 1rem; border-radius: 4px; } .parallel-control { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; } input[type="number"] { width: 5rem; } `] }) export class LambertMapComponent implements OnInit { @ViewChild('mapCanvas', { static: true }) canvas!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private width = 800; private height = 600; private land: any; // TopoJSON data private isDragging = false; private dragTarget: 'parallel1' | 'parallel2' | 'central' | null = null; mapState: LambertMapState = { parallel1: { active: true, value: 30 }, parallel2: { active: true, value: 60 }, centralParallel: 0 }; constructor() {} async ngOnInit() { this.ctx = this.canvas.nativeElement.getContext('2d')!; this.setupCanvas(); await this.loadData(); this.setupEventListeners(); this.draw(); } private async loadData() { const response = await fetch('/assets/land-110m.json'); const topology = await response.json(); this.land = feature(topology, topology.objects.land); } private setupCanvas() { const dpr = window.devicePixelRatio || 1; this.canvas.nativeElement.width = this.width * dpr; this.canvas.nativeElement.height = this.height * dpr; this.ctx.scale(dpr, dpr); } private setupEventListeners() { const canvas = this.canvas.nativeElement; canvas.addEventListener('mousedown', (e) => { const rect = canvas.getBoundingClientRect(); const y = e.clientY - rect.top; // Determine what's being dragged based on proximity to lines this.dragTarget = this.getDragTarget(y); if (this.dragTarget) { this.isDragging = true; } }); canvas.addEventListener('mousemove', (e) => { if (this.isDragging && this.dragTarget) { const rect = canvas.getBoundingClientRect(); const y = e.clientY - rect.top; this.updateFromDrag(y); } }); canvas.addEventListener('mouseup', () => { this.isDragging = false; this.dragTarget = null; }); } private getDragTarget(y: number): 'parallel1' | 'parallel2' | 'central' | null { // Convert y coordinate to latitude and check proximity to lines // This is a simplified version - you'll need to add proper conversion return null; // TODO: Implement proper hit detection } private updateFromDrag(y: number) { if (!this.dragTarget) return; // Convert y coordinate to latitude const latitude = this.yToLatitude(y); switch (this.dragTarget) { case 'parallel1': if (this.mapState.parallel1.active) { this.mapState.parallel1.value = latitude; } break; case 'parallel2': if (this.mapState.parallel2.active) { this.mapState.parallel2.value = latitude; } break; case 'central': this.mapState.centralParallel = latitude; break; } this.draw(); } private yToLatitude(y: number): number { // Convert y coordinate to latitude // This is a simplified version - you'll need to add proper conversion return (this.height - y) / this.height * 180 - 90; } private draw() { this.ctx.clearRect(0, 0, this.width, this.height); const projection = geoLambertConformal() .center([0, this.mapState.centralParallel]) .parallels(this.getActiveParallels()) .fitSize([this.width, this.height], this.land); const path = geoPath(projection, this.ctx); // Draw graticule const graticule = geoGraticule30(); this.ctx.beginPath(); this.ctx.strokeStyle = '#ccc'; path(graticule); this.ctx.stroke(); // Draw land this.ctx.beginPath(); this.ctx.fillStyle = '#d4d4d4'; path(this.land); this.ctx.fill(); // Draw parallels this.drawParallels(path); } private drawParallels(path: any) { // Draw central parallel this.ctx.beginPath(); this.ctx.strokeStyle = 'purple'; path({ type: 'LineString', coordinates: [[-180, this.mapState.centralParallel], [180, this.mapState.centralParallel]] }); this.ctx.stroke(); // Draw standard parallels if active if (this.mapState.parallel1.active) { this.ctx.beginPath(); this.ctx.strokeStyle = 'green'; path({ type: 'LineString', coordinates: [[-180, this.mapState.parallel1.value], [180, this.mapState.parallel1.value]] }); this.ctx.stroke(); } if (this.mapState.parallel2.active) { this.ctx.beginPath(); this.ctx.strokeStyle = 'blue'; path({ type: 'LineString', coordinates: [[-180, this.mapState.parallel2.value], [180, this.mapState.parallel2.value]] }); this.ctx.stroke(); } } private getActiveParallels(): number[] { const parallels: number[] = []; if (this.mapState.parallel1.active) parallels.push(this.mapState.parallel1.value); if (this.mapState.parallel2.active) parallels.push(this.mapState.parallel2.value); return parallels; } toggleParallel(num: 1 | 2) { const parallel = num === 1 ? 'parallel1' : 'parallel2'; this.mapState[parallel].active = !this.mapState[parallel].active; this.draw(); } updateParallelValue(num: 1 | 2, event: Event) { const value = +(event.target as HTMLInputElement).value; const parallel = num === 1 ? 'parallel1' : 'parallel2'; this.mapState[parallel].value = value; this.draw(); } updateCentralParallel(event: Event) { const value = +(event.target as HTMLInputElement).value; this.mapState.centralParallel = value; this.draw(); } }
|   |   |   |   +-- cylindrical
|   |   |   |   |   +-- models
|   |   |   |   |   |   \-- abstract-projection.ts
|   |   |   |   |   \-- utm
|   |   |   |   |       +-- utm.component.html: <div class="container"> <canvas class="horizontal-ruler" #horizontalRulerCanvas></canvas> <canvas class="vertical-ruler" #verticalRulerCanvas></canvas> <canvas class="map-canvas" #mapCanvas></canvas> </div>
|   |   |   |   |       +-- utm.component.scss: :host { display: grid; place-content: center; height: calc(100vh - 200px); // Accounting for header and margins } .container { display: grid; grid-template: 50px 1fr / 50px 1fr; width: 960px; height: 500px; } canvas { width: 100%; height: 100%; } .horizontal-ruler { grid-area: 1 / 2; background-color: gray; } .vertical-ruler { grid-area: 2 / 1; background-color: gray; } .map-canvas { grid-area: 2 / 2; }
|   |   |   |   |       \-- utm.component.ts: import { Component, ElementRef, EventEmitter, HostListener, OnInit, Output, ViewChild } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { geoMercator, geoPath } from 'd3-geo'; import { feature } from 'topojson-client'; import { zoom, ZoomBehavior } from 'd3-zoom'; import { select } from 'd3-selection'; import * as d3 from 'd3'; @Component({ selector: 'app-utm', templateUrl: './utm.component.html', styleUrls: ['./utm.component.scss'], }) export class UtmComponent implements OnInit { @ViewChild('mapCanvas', { static: true }) mapCanvas!: ElementRef<HTMLCanvasElement>; @ViewChild('horizontalRulerCanvas', { static: true }) horizontalRulerCanvas!: ElementRef<HTMLCanvasElement>; @ViewChild('verticalRulerCanvas', { static: true }) verticalRulerCanvas!: ElementRef<HTMLCanvasElement>; @Output() zoneSelected = new EventEmitter<string>(); private context!: CanvasRenderingContext2D; private horizontalRulerContext!: CanvasRenderingContext2D; private verticalRulerContext!: CanvasRenderingContext2D; private projection = geoMercator(); private path = geoPath(this.projection); private canvasWidth = 960; private canvasHeight = 500; private hoveredZone: string | null = null; private landData: any = null; private zoom!: ZoomBehavior<Element, unknown>; private transform = { k: 1, x: 0, y: 0 }; constructor(private http: HttpClient) { } ngOnInit(): void { this.setupZoom(); this.setupCanvases(); this.loadMapData(); } private setupZoom(): void { this.zoom = zoom() .scaleExtent([0.5, 5]) .on('zoom', (event) => { this.transform = event.transform; this.redraw(); }); select(this.mapCanvas.nativeElement).call(this.zoom); } private setupCanvases(): void { const mapCanvas = this.mapCanvas.nativeElement; const hRuler = this.horizontalRulerCanvas.nativeElement; const vRuler = this.verticalRulerCanvas.nativeElement; mapCanvas.width = this.canvasWidth; mapCanvas.height = this.canvasHeight; hRuler.width = this.canvasWidth; hRuler.height = 50; vRuler.width = 50; vRuler.height = this.canvasHeight; this.context = mapCanvas.getContext('2d')!; this.horizontalRulerContext = hRuler.getContext('2d')!; this.verticalRulerContext = vRuler.getContext('2d')!; this.projection.scale(this.canvasWidth / 8).translate([this.canvasWidth / 2, this.canvasHeight / 2]); this.drawRulers(); } private loadMapData(): void { this.http.get('assets/land-110m.json').subscribe(data => { this.landData = data; this.redraw(); }); } // private redraw(): void { // this.context.save(); // this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight); // this.context.translate(this.transform.x, this.transform.y); // this.context.scale(this.transform.k, this.transform.k); // this.drawMap(); // this.drawUTMZones(); // this.context.restore(); // } private drawMap(): void { if (!this.landData) return; const landGeoJson = feature(this.landData, this.landData.objects.land); this.context.beginPath(); this.path.context(this.context)(landGeoJson as any); this.context.fillStyle = '#d4e157'; this.context.fill(); this.context.stroke(); } private drawUTMZones(): void { const zoneWidth = this.canvasWidth / 60; const zoneHeight = this.canvasHeight / 20; for (let i = 0; i < 60; i++) { for (let j = 0; j < 20; j++) { const x = i * zoneWidth; const y = j * zoneHeight; const zoneName = `${i + 1}${String.fromCharCode(67 + j)}`; this.context.beginPath(); this.context.rect(x, y, zoneWidth, zoneHeight); this.context.strokeStyle = 'gray'; this.context.stroke(); this.context.font = '10px Arial'; this.context.fillStyle = 'black'; this.context.fillText(zoneName, x + 5, y + 15); } } } // private drawRulers(): void { // const zoneWidth = this.canvasWidth / 60; // const zoneHeight = this.canvasHeight / 20; // // Horizontal ruler // this.horizontalRulerContext.clearRect(0, 0, this.canvasWidth, 50); // for (let i = 0; i < 60; i++) { // const x = i * zoneWidth; // this.horizontalRulerContext.beginPath(); // this.horizontalRulerContext.moveTo(x, 0); // this.horizontalRulerContext.lineTo(x, 10); // this.horizontalRulerContext.stroke(); // this.horizontalRulerContext.fillText(`${i + 1}`, x + zoneWidth / 2, 30); // } // // Vertical ruler // this.verticalRulerContext.clearRect(0, 0, 50, this.canvasHeight); // for (let j = 0; j < 20; j++) { // const y = j * zoneHeight; // this.verticalRulerContext.beginPath(); // this.verticalRulerContext.moveTo(40, y); // this.verticalRulerContext.lineTo(50, y); // this.verticalRulerContext.stroke(); // this.verticalRulerContext.fillText(String.fromCharCode(67 + j), 35, y + zoneHeight / 2); // } // } @HostListener('mousemove', ['$event']) handleMouseMove(event: MouseEvent): void { const rect = this.mapCanvas.nativeElement.getBoundingClientRect(); const scaleX = this.canvasWidth / rect.width; const scaleY = this.canvasHeight / rect.height; const x = ((event.clientX - rect.left) * scaleX - this.transform.x) / this.transform.k; const y = ((event.clientY - rect.top) * scaleY - this.transform.y) / this.transform.k; const zoneWidth = this.canvasWidth / 60; const zoneHeight = this.canvasHeight / 20; const zoneX = Math.floor(x / zoneWidth); const zoneY = Math.floor(y / zoneHeight); if (zoneX >= 0 && zoneX < 60 && zoneY >= 0 && zoneY < 20) { const hoveredZone = `${zoneX + 1}${String.fromCharCode(67 + zoneY)}`; if (this.hoveredZone !== hoveredZone) { this.hoveredZone = hoveredZone; this.highlightZone(zoneX, zoneY); } } } private highlightZone(zoneX: number, zoneY: number): void { this.redraw(); const zoneWidth = this.canvasWidth / 60; const zoneHeight = this.canvasHeight / 20; const x = zoneX * zoneWidth; const y = zoneY * zoneHeight; this.context.save(); this.context.translate(this.transform.x, this.transform.y); this.context.scale(this.transform.k, this.transform.k); this.context.fillStyle = 'rgba(255, 255, 0, 0.2)'; this.context.fillRect(x, y, zoneWidth, zoneHeight); this.context.restore(); } @HostListener('click', ['$event']) handleClick(event: MouseEvent): void { const rect = this.mapCanvas.nativeElement.getBoundingClientRect(); const scaleX = this.canvasWidth / rect.width; const scaleY = this.canvasHeight / rect.height; const x = ((event.clientX - rect.left) * scaleX - this.transform.x) / this.transform.k; const y = ((event.clientY - rect.top) * scaleY - this.transform.y) / this.transform.k; const zoneWidth = this.canvasWidth / 60; const zoneHeight = this.canvasHeight / 20; const zoneX = Math.floor(x / zoneWidth); const zoneY = Math.floor(y / zoneHeight); if (zoneX >= 0 && zoneX < 60 && zoneY >= 0 && zoneY < 20) { const selectedZone = `${zoneX + 1}${String.fromCharCode(67 + zoneY)}`; console.log(`Selected UTM Zone: ${selectedZone}`); this.zoneSelected.emit(selectedZone); } } @HostListener('window:resize') onResize(): void { this.setupCanvases(); if (this.landData) { this.redraw(); } } private redraw(): void { // Clear and redraw main canvas this.context.save(); this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight); this.context.translate(this.transform.x, this.transform.y); this.context.scale(this.transform.k, this.transform.k); this.drawMap(); this.drawUTMZones(); this.context.restore(); // Redraw rulers with current transform this.drawRulers(); } private drawRulers(): void { const zoneWidth = (this.canvasWidth / 60) * this.transform.k; const zoneHeight = (this.canvasHeight / 20) * this.transform.k; const offsetX = this.transform.x; const offsetY = this.transform.y; // Horizontal ruler this.horizontalRulerContext.clearRect(0, 0, this.canvasWidth, 50); for (let i = 0; i < 60; i++) { const x = (i * zoneWidth) + offsetX; if (x >= 0 && x <= this.canvasWidth) { // Only draw visible ticks this.horizontalRulerContext.beginPath(); this.horizontalRulerContext.moveTo(x, 0); this.horizontalRulerContext.lineTo(x, 10); this.horizontalRulerContext.stroke(); this.horizontalRulerContext.fillText(`${i + 1}`, x + zoneWidth / 2, 30); } } // Vertical ruler this.verticalRulerContext.clearRect(0, 0, 50, this.canvasHeight); for (let j = 0; j < 20; j++) { const y = (j * zoneHeight) + offsetY; if (y >= 0 && y <= this.canvasHeight) { // Only draw visible ticks this.verticalRulerContext.beginPath(); this.verticalRulerContext.moveTo(40, y); this.verticalRulerContext.lineTo(50, y); this.verticalRulerContext.stroke(); this.verticalRulerContext.fillText(String.fromCharCode(67 + j), 35, y + zoneHeight / 2); } } } }
|   |   |   |   +-- solar
|   |   |   |   |   +-- solar.component.html: <div class="solar-container"> <div *ngIf="loading" class="loading-indicator">Loading map data...</div> <canvas #mapCanvas></canvas> </div>
|   |   |   |   |   +-- solar.component.scss: 
|   |   |   |   |   \-- solar.component.ts: import { Component, OnInit, ElementRef, ViewChild, AfterViewInit } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import * as d3 from 'd3'; import * as topojson from 'topojson-client'; import { Topology, GeometryCollection } from 'topojson-specification'; import { GeoPermissibleObjects } from 'd3-geo'; // not from 'd3' import solar from 'solar-calculator'; import { century, equationOfTime, declination } from 'solar-calculator'; @Component({ selector: 'app-solar', templateUrl: './solar.component.html', styleUrls: ['./solar.component.scss'] }) export class SolarComponent implements OnInit, AfterViewInit { @ViewChild('mapCanvas') mapCanvas!: ElementRef<HTMLCanvasElement>; private context!: CanvasRenderingContext2D; private width = 960; private height = 480; private projection!: d3.GeoProjection; private path!: d3.GeoPath; //private sphere = { type: "Sphere" }; private sphere: GeoPermissibleObjects = { type: "Sphere", geometries: [] }; private world: Topology | null = null; public loading = true; private zoom = d3.zoom<HTMLCanvasElement, unknown>(); private transform = d3.zoomIdentity; constructor(private http: HttpClient) { } ngOnInit(): void { this.loadWorldData(); } ngAfterViewInit(): void { this.setupCanvas(); this.setupZoom(); } private setupCanvas(): void { const canvas = this.mapCanvas.nativeElement; this.context = canvas.getContext('2d')!; // Handle high DPI displays const resolutionScale = window.devicePixelRatio || 1; canvas.width = this.width * resolutionScale; canvas.height = this.height * resolutionScale; canvas.style.width = `${this.width}px`; canvas.style.height = `${this.height}px`; this.context.scale(resolutionScale, resolutionScale); // Setup projection and path this.projection = d3.geoNaturalEarth1() .fitExtent( [[0, 0], [this.width, this.height]], this.sphere as GeoPermissibleObjects ); this.path = d3.geoPath(this.projection, this.context); } private setupZoom(): void { d3.select(this.mapCanvas.nativeElement) .call(this.zoom .scaleExtent([1, 8]) .on('zoom', (event) => { this.transform = event.transform; this.render(); })); } private loadWorldData(): void { this.http.get<Topology>('assets/land-50m.json') .subscribe({ next: (world) => { this.world = world; this.loading = false; // Hide loading indicator this.render(); }, error: (error) => { console.error('Error loading world map data:', error); this.loading = false; // Hide loading indicator even on error } }); } private renderGraticule(): void { this.context.beginPath(); this.path(d3.geoGraticule()()); this.context.strokeStyle = "#ccc"; this.context.lineWidth = 0.5; this.context.stroke(); } private renderLand(): void { if (this.world?.objects?.land) { const land = topojson.feature( this.world, this.world.objects.land as GeometryCollection ); this.context.beginPath(); this.path(land); this.context.fillStyle = "#555"; this.context.fill(); } } private renderNightRegion(): void { const now = new Date(); const day = new Date(+now).setUTCHours(0, 0, 0, 0); const t = century(now); const longitude = (day - +now) / 864e5 * 360 - 180; const sun = [ longitude - equationOfTime(t) / 4, declination(t) ] as [number, number]; const antipode = ([lon, lat]: [number, number]): [number, number] => [lon + 180, -lat]; const night = d3.geoCircle() .radius(90) .center(antipode(sun))(); this.context.beginPath(); this.path(night); this.context.fillStyle = "rgba(0, 0, 128, 0.5)"; this.context.fill(); } private renderSphere(): void { this.context.beginPath(); this.path(this.sphere); this.context.strokeStyle = "#000"; this.context.lineWidth = 1; this.context.stroke(); } // private render(): void { // // Use requestAnimationFrame for smoother rendering // requestAnimationFrame(() => { // this.renderGraticule(); // requestAnimationFrame(() => { // this.renderLand(); // requestAnimationFrame(() => { // this.renderNightRegion(); // requestAnimationFrame(() => { // this.renderSphere(); // }); // }); // }); // }); //} // // Update render() to use transform: // private render(): void { // this.context.save(); // this.context.clearRect(0, 0, this.width, this.height); // this.context.translate(this.transform.x, this.transform.y); // this.context.scale(this.transform.k, this.transform.k); // requestAnimationFrame(() => { // this.renderGraticule(); // requestAnimationFrame(() => { // this.renderLand(); // requestAnimationFrame(() => { // this.renderNightRegion(); // requestAnimationFrame(() => { // this.renderSphere(); // this.context.restore(); // }); // }); // }); // }); // } private render(): void { this.context.save(); this.context.clearRect(0, 0, this.width, this.height); // Center the zoom const tx = (this.width * (1 - this.transform.k)) / 2; const ty = (this.height * (1 - this.transform.k)) / 2; this.context.translate(tx + this.transform.x, ty + this.transform.y); this.context.scale(this.transform.k, this.transform.k); requestAnimationFrame(() => { this.renderGraticule(); requestAnimationFrame(() => { this.renderLand(); requestAnimationFrame(() => { this.renderNightRegion(); requestAnimationFrame(() => { this.renderSphere(); this.context.restore(); }); }); }); }); } }
|   |   |   |   +-- two-point
|   |   |   |   |   +-- models
|   |   |   |   |   |   +-- abstract-two-point-projection.ts: import { Point } from "./point.interface"; import { Coordinate, Distance, GreatCircle, Bearing } from '@dvanauken/sphere'; // models/abstract-two-point-projection.ts export abstract class AbstractTwoPointProjection { protected point1: Point; protected point2: Point; constructor(initialPoint1: Point, initialPoint2: Point) { this.point1 = this.validatePoint(initialPoint1); this.point2 = this.validatePoint(initialPoint2); } // protected validatePoint(point: Point): Point { // if (point.latitude < -90 || point.latitude > 90) { // throw new Error('Latitude must be between -90 and 90 degrees'); // } // if (point.longitude < -180 || point.longitude > 180) { // throw new Error('Longitude must be between -180 and 180 degrees'); // } // return { // latitude: Number(point.latitude.toFixed(3)), // longitude: Number(point.longitude.toFixed(3)) // }; // } protected validatePoint(point: Point): Point { // Sphere's Coordinate constructor already handles validation const coord = new Coordinate(point.latitude, point.longitude); return { latitude: Number(coord.latitude.toFixed(3)), longitude: Number(coord.longitude.toFixed(3)) }; } getPoint1(): Point { return { ...this.point1 }; } getPoint2(): Point { return { ...this.point2 }; } setPoint1(point: Point): void { this.point1 = this.validatePoint(point); } setPoint2(point: Point): void { this.point2 = this.validatePoint(point); } // Abstract methods that must be implemented by concrete classes abstract project(coordinates: Point): [number, number]; abstract unproject(point: [number, number]): Point; abstract getProjection(): any; // // Common geometric calculations // protected calculateDistance(p1: Point, p2: Point): number { // const R = 6371; // Earth's radius in kilometers // const lat1 = this.toRadians(p1.latitude); // const lat2 = this.toRadians(p2.latitude); // const dLat = this.toRadians(p2.latitude - p1.latitude); // const dLon = this.toRadians(p2.longitude - p1.longitude); // const a = Math.sin(dLat/2) * Math.sin(dLat/2) + // Math.cos(lat1) * Math.cos(lat2) * // Math.sin(dLon/2) * Math.sin(dLon/2); // const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); // return R * c; // } // protected calculateBearing(p1: Point, p2: Point): number { // const lat1 = this.toRadians(p1.latitude); // const lat2 = this.toRadians(p2.latitude); // const dLon = this.toRadians(p2.longitude - p1.longitude); // const y = Math.sin(dLon) * Math.cos(lat2); // const x = Math.cos(lat1) * Math.sin(lat2) - // Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon); // return (this.toDegrees(Math.atan2(y, x)) + 360) % 360; // } protected calculateDistance(p1: Point, p2: Point): number { const coord1 = new Coordinate(p1.latitude, p1.longitude); const coord2 = new Coordinate(p2.latitude, p2.longitude); const distance = GreatCircle.from(coord1).to(coord2).distance(); return distance.inKilometers(); // Since your original used km } // Replace calculateBearing with Sphere's Bearing protected calculateBearing(p1: Point, p2: Point): number { const coord1 = new Coordinate(p1.latitude, p1.longitude); const coord2 = new Coordinate(p2.latitude, p2.longitude); return Bearing.from(coord1).to(coord2).initial().degrees; } private toRadians(degrees: number): number { return degrees * Math.PI / 180; } private toDegrees(radians: number): number { return radians * 180 / Math.PI; } }
|   |   |   |   |   |   +-- azimuthal-projection.ts: // models/azimuthal-projection.ts import * as d3 from 'd3'; import { geoTwoPointAzimuthal } from 'd3-geo-projection'; import { AbstractTwoPointProjection } from './abstract-two-point-projection'; import { Point } from './point.interface'; export class AzimuthalProjection extends AbstractTwoPointProjection { private projection: any; // d3 projection type constructor(initialPoint1: Point, initialPoint2: Point) { super(initialPoint1, initialPoint2); this.initializeProjection(); } private initializeProjection(): void { this.projection = geoTwoPointAzimuthal() .points([ [this.point1.longitude, this.point1.latitude], [this.point2.longitude, this.point2.latitude] ]) .scale(150) .translate([480, 300]); // These will be overridden by UI layer } override setPoint1(point: Point): void { super.setPoint1(point); this.initializeProjection(); } override setPoint2(point: Point): void { super.setPoint2(point); this.initializeProjection(); } project(coordinates: Point): [number, number] { return this.projection([coordinates.longitude, coordinates.latitude]) as [number, number]; } unproject(point: [number, number]): Point { const [longitude, latitude] = this.projection.invert(point); return { latitude, longitude }; } getProjection(): any { return this.projection; } }
|   |   |   |   |   |   +-- equidistant-projection.ts: // models/equidistant-projection.ts import * as d3 from 'd3'; import { AbstractTwoPointProjection } from './abstract-two-point-projection'; import { Point } from './point.interface'; import { geoTwoPointEquidistant } from 'd3-geo-projection'; export class EquidistantProjection extends AbstractTwoPointProjection { private projection: any; // d3 projection type constructor(initialPoint1: Point, initialPoint2: Point) { super(initialPoint1, initialPoint2); this.initializeProjection(); } private initializeProjection(): void { this.projection = geoTwoPointEquidistant() .points([ [this.point1.longitude, this.point1.latitude], [this.point2.longitude, this.point2.latitude] ]) .scale(150) .translate([480, 300]); // These will be overridden by UI layer } override setPoint1(point: Point): void { super.setPoint1(point); this.initializeProjection(); } override setPoint2(point: Point): void { super.setPoint2(point); this.initializeProjection(); } project(coordinates: Point): [number, number] { return this.projection([coordinates.longitude, coordinates.latitude]) as [number, number]; } unproject(point: [number, number]): Point { const [longitude, latitude] = this.projection.invert(point); return { latitude, longitude }; } getProjection(): any { return this.projection; } }
|   |   |   |   |   |   +-- point.interface.ts: // models/point.interface.ts export interface Point { latitude: number; longitude: number; }
|   |   |   |   |   |   +-- projection-factory.ts: // models/projection-factory.ts import { ProjectionType } from './projection-type.enum'; import { Point } from './point.interface'; import { AbstractTwoPointProjection } from './abstract-two-point-projection'; import { EquidistantProjection } from './equidistant-projection'; import { AzimuthalProjection } from './azimuthal-projection'; export class ProjectionFactory { static createProjection( type: ProjectionType, point1: Point, point2: Point ): AbstractTwoPointProjection { switch (type) { case ProjectionType.EQUIDISTANT: return new EquidistantProjection(point1, point2); case ProjectionType.AZIMUTHAL: return new AzimuthalProjection(point1, point2); default: throw new Error(`Unknown projection type: ${type}`); } } }
|   |   |   |   |   |   +-- projection-state.interface.ts: import { Point } from "geojson"; import { ProjectionType } from "./projection-type.enum"; // models/projection-state.interface.ts export interface ProjectionState { point1: Point; point2: Point; type: ProjectionType; }
|   |   |   |   |   |   \-- projection-type.enum.ts: // models/projection-type.enum.ts export enum ProjectionType { EQUIDISTANT = 'equidistant', AZIMUTHAL = 'azimuthal' }
|   |   |   |   |   +-- two-point-equidistant.component
|   |   |   |   |   +-- abstract-two-point-map.component.ts: // components/abstract-two-point-map.component.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import * as d3 from 'd3'; import { AbstractTwoPointProjection } from './models/abstract-two-point-projection'; import { Point } from './models/point.interface'; @Component({ template: '' }) export abstract class AbstractTwoPointMapComponent implements OnInit { @ViewChild('mapCanvas', { static: true }) protected canvas!: ElementRef<HTMLCanvasElement>; protected width = 960; protected height = 600; protected context!: CanvasRenderingContext2D; protected landFeatures: any; protected projection!: AbstractTwoPointProjection; protected state$ = new BehaviorSubject<{ point1: Point; point2: Point; }>({ point1: { latitude: 40.7128, longitude: -74.0060 }, // New York point2: { latitude: 48.8566, longitude: 2.3522 } // Paris }); async ngOnInit() { await this.setupCanvas(); await this.loadMapData(); this.initializeProjection(); this.setupSubscriptions(); this.setupDragBehavior(); this.draw(); } protected async setupCanvas(): Promise<void> { const context = this.canvas.nativeElement.getContext('2d'); if (!context) throw new Error('Could not get canvas context'); this.context = context; // Handle high DPI displays const scale = window.devicePixelRatio; this.canvas.nativeElement.width = this.width * scale; this.canvas.nativeElement.height = this.height * scale; this.canvas.nativeElement.style.width = this.width + 'px'; this.canvas.nativeElement.style.height = this.height + 'px'; this.context.scale(scale, scale); } protected async loadMapData(): Promise<void> { this.landFeatures = await d3.json('/assets/land-110m.json'); } protected abstract initializeProjection(): void; protected setupSubscriptions(): void { this.state$.subscribe(() => { this.updateProjectionPoints(); this.draw(); }); } protected setupDragBehavior(): void { const canvas = d3.select(this.canvas.nativeElement); const dragBehavior = d3.drag() .on('drag', (event) => { const pos: [number, number] = [event.x, event.y]; this.handleDrag(pos); }); canvas.call(dragBehavior); } protected handleDrag(pos: [number, number]): void { const coords = this.projection.unproject(pos); const currentState = this.state$.value; // Determine which point is closer to the drag position const point1Pos = this.projection.project(currentState.point1); const point2Pos = this.projection.project(currentState.point2); const dist1 = Math.hypot(pos[0] - point1Pos[0], pos[1] - point1Pos[1]); const dist2 = Math.hypot(pos[0] - point2Pos[0], pos[1] - point2Pos[1]); if (dist1 < dist2) { this.updatePoint1(coords); } else { this.updatePoint2(coords); } } protected draw(): void { this.context.clearRect(0, 0, this.width, this.height); this.drawLand(); this.drawPoints(); this.drawGeodesicLine(); } protected drawLand(): void { const path = d3.geoPath(this.projection.getProjection(), this.context); this.context.beginPath(); path(this.landFeatures); this.context.fillStyle = '#d4d4d4'; this.context.fill(); } protected drawPoints(): void { const state = this.state$.value; const point1Pos = this.projection.project(state.point1); const point2Pos = this.projection.project(state.point2); // Draw drag targets this.context.beginPath(); this.context.arc(point1Pos[0], point1Pos[1], 15, 0, 2 * Math.PI); this.context.fillStyle = 'rgba(128, 0, 128, 0.2)'; this.context.fill(); this.context.beginPath(); this.context.arc(point2Pos[0], point2Pos[1], 15, 0, 2 * Math.PI); this.context.fillStyle = 'rgba(0, 128, 0, 0.2)'; this.context.fill(); // Draw actual points this.context.beginPath(); this.context.arc(point1Pos[0], point1Pos[1], 4, 0, 2 * Math.PI); this.context.fillStyle = 'purple'; this.context.fill(); this.context.beginPath(); this.context.arc(point2Pos[0], point2Pos[1], 4, 0, 2 * Math.PI); this.context.fillStyle = 'green'; this.context.fill(); } protected drawGeodesicLine(): void { const state = this.state$.value; const path = d3.geoPath(this.projection.getProjection(), this.context); this.context.beginPath(); path({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: [ [state.point1.longitude, state.point1.latitude], [state.point2.longitude, state.point2.latitude] ] } }); this.context.strokeStyle = '#666'; this.context.stroke(); } protected updateProjectionPoints(): void { const state = this.state$.value; this.projection.setPoint1(state.point1); this.projection.setPoint2(state.point2); } // Public methods for coordinate updates updatePoint1(point: Point): void { this.state$.next({ ...this.state$.value, point1: point }); } updatePoint2(point: Point): void { this.state$.next({ ...this.state$.value, point2: point }); } }
|   |   |   |   |   +-- two-point-azimuthal.component.ts: // components/two-point-azimuthal-map.component.ts import { Component } from '@angular/core'; import { AbstractTwoPointMapComponent } from './abstract-two-point-map.component'; import { AzimuthalProjection } from './models/azimuthal-projection'; @Component({ selector: 'app-two-point-azimuthal-map', template: ` <div class="map-container"> <canvas #mapCanvas></canvas> <div class="coordinates-panel"> <div class="point-inputs"> <h4>Point 1 (Purple)</h4> <div> <label>Latitude:</label> <input type="number" [value]="(state$ | async)?.point1.latitude" (change)="updatePoint1Lat($event)" step="0.001" min="-90" max="90"> </div> <div> <label>Longitude:</label> <input type="number" [value]="(state$ | async)?.point1.longitude" (change)="updatePoint1Lng($event)" step="0.001" min="-180" max="180"> </div> </div> <div class="point-inputs"> <h4>Point 2 (Green)</h4> <div> <label>Latitude:</label> <input type="number" [value]="(state$ | async)?.point2.latitude" (change)="updatePoint2Lat($event)" step="0.001" min="-90" max="90"> </div> <div> <label>Longitude:</label> <input type="number" [value]="(state$ | async)?.point2.longitude" (change)="updatePoint2Lng($event)" step="0.001" min="-180" max="180"> </div> </div> <!-- Additional azimuthal-specific info --> <div class="bearing-info"> <h4>Bearings</h4> <div>Initial: {{calculateInitialBearing()}}Â°</div> <div>Final: {{calculateFinalBearing()}}Â°</div> </div> </div> </div> `, styles: [` .map-container { position: relative; width: 100%; height: 100%; } canvas { width: 100%; height: 100%; } .coordinates-panel { position: absolute; top: 20px; right: 20px; background: rgba(255, 255, 255, 0.9); padding: 15px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .point-inputs { margin-bottom: 15px; } .point-inputs div { margin: 5px 0; } input { width: 100px; margin-left: 10px; } .bearing-info { border-top: 1px solid #ddd; padding-top: 10px; margin-top: 10px; } `] }) export class TwoPointAzimuthalMapComponent extends AbstractTwoPointMapComponent { protected override initializeProjection(): void { const state = this.state$.value; this.projection = new AzimuthalProjection(state.point1, state.point2); } protected override drawPoints(): void { super.drawPoints(); this.drawBearingIndicators(); } private drawBearingIndicators(): void { const state = this.state$.value; const point1Pos = this.projection.project(state.point1); const point2Pos = this.projection.project(state.point2); // Draw bearing lines const initialBearing = this.calculateInitialBearing(); const finalBearing = this.calculateFinalBearing(); this.drawBearingLine(point1Pos, initialBearing, 'purple'); this.drawBearingLine(point2Pos, finalBearing, 'green'); } private drawBearingLine(point: [number, number], bearing: number, color: string): void { const length = 30; const radians = (bearing - 90) * Math.PI / 180; // -90 to align with geographic bearing const endX = point[0] + length * Math.cos(radians); const endY = point[1] + length * Math.sin(radians); this.context.beginPath(); this.context.moveTo(point[0], point[1]); this.context.lineTo(endX, endY); this.context.strokeStyle = color; this.context.lineWidth = 2; this.context.stroke(); // Draw arrowhead const arrowSize = 8; const arrowAngle = Math.PI / 6; this.context.beginPath(); this.context.moveTo(endX, endY); this.context.lineTo( endX - arrowSize * Math.cos(radians - arrowAngle), endY - arrowSize * Math.sin(radians - arrowAngle) ); this.context.lineTo( endX - arrowSize * Math.cos(radians + arrowAngle), endY - arrowSize * Math.sin(radians + arrowAngle) ); this.context.closePath(); this.context.fillStyle = color; this.context.fill(); } calculateInitialBearing(): number { const state = this.state$.value; return Number(this.projection['calculateBearing'](state.point1, state.point2).toFixed(1)); } calculateFinalBearing(): number { const state = this.state$.value; // Final bearing is initial bearing from point 2 to point 1, plus 180 degrees return Number(((this.projection['calculateBearing'](state.point2, state.point1) + 180) % 360).toFixed(1)); } // Input handlers (same as equidistant component) updatePoint1Lat(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint1({ ...currentState.point1, latitude: value }); } updatePoint1Lng(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint1({ ...currentState.point1, longitude: value }); } updatePoint2Lat(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint2({ ...currentState.point2, latitude: value }); } updatePoint2Lng(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint2({ ...currentState.point2, longitude: value }); } }
|   |   |   |   |   \-- two-point-equidistant.component.ts: // components/two-point-equidistant-map.component.ts import { Component } from '@angular/core'; import { EquidistantProjection } from './models/equidistant-projection'; import { Point } from './models/point.interface'; import { AbstractTwoPointMapComponent } from './abstract-two-point-map.component'; @Component({ selector: 'app-two-point-equidistant-map', template: ` <div class="map-container"> <canvas #mapCanvas></canvas> <div class="coordinates-panel"> <div class="point-inputs"> <h4>Point 1 (Purple)</h4> <div> <label>Latitude:</label> <input type="number" [value]="(state$ | async)?.point1.latitude" (change)="updatePoint1Lat($event)" step="0.001" min="-90" max="90"> </div> <div> <label>Longitude:</label> <input type="number" [value]="(state$ | async)?.point1.longitude" (change)="updatePoint1Lng($event)" step="0.001" min="-180" max="180"> </div> </div> <div class="point-inputs"> <h4>Point 2 (Green)</h4> <div> <label>Latitude:</label> <input type="number" [value]="(state$ | async)?.point2.latitude" (change)="updatePoint2Lat($event)" step="0.001" min="-90" max="90"> </div> <div> <label>Longitude:</label> <input type="number" [value]="(state$ | async)?.point2.longitude" (change)="updatePoint2Lng($event)" step="0.001" min="-180" max="180"> </div> </div> </div> </div> `, styles: [` .map-container { position: relative; width: 100%; height: 100%; } canvas { width: 100%; height: 100%; } .coordinates-panel { position: absolute; top: 20px; right: 20px; background: rgba(255, 255, 255, 0.9); padding: 15px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .point-inputs { margin-bottom: 15px; } .point-inputs div { margin: 5px 0; } input { width: 100px; margin-left: 10px; } `] }) export class TwoPointEquidistantMapComponent extends AbstractTwoPointMapComponent { protected override initializeProjection(): void { const state = this.state$.value; this.projection = new EquidistantProjection(state.point1, state.point2); } updatePoint1Lat(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint1({ ...currentState.point1, latitude: value }); } updatePoint1Lng(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint1({ ...currentState.point1, longitude: value }); } updatePoint2Lat(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint2({ ...currentState.point2, latitude: value }); } updatePoint2Lng(event: Event): void { const value = +(event.target as HTMLInputElement).value; const currentState = this.state$.value; this.updatePoint2({ ...currentState.point2, longitude: value }); } }
|   |   |   |   +-- cylindrical.component.html: 
|   |   |   |   +-- cylindrical.component.scss: 
|   |   |   |   \-- cylindrical.component.ts: 
|   |   |   +-- style-editor
|   |   |   |   +-- style-editor.component.html: <div> <button mat-icon-button (click)="addRow()" aria-label="Add row"> <mat-icon>add</mat-icon> </button> </div> <table mat-table [dataSource]="dataSource" class="mat-elevation-z8"> <ng-container matColumnDef="al"> <th mat-header-cell *matHeaderCellDef> AL </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readAl"> <input matInput [(ngModel)]="row.al" /> </ng-container> <ng-template #readAl>{{ row.al }}</ng-template> </td> </ng-container> <ng-container matColumnDef="base"> <th mat-header-cell *matHeaderCellDef> Base </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readBase"> <input matInput [(ngModel)]="row.base" /> </ng-container> <ng-template #readBase>{{ row.base }}</ng-template> </td> </ng-container> <ng-container matColumnDef="ref"> <th mat-header-cell *matHeaderCellDef> Ref </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readRef"> <input matInput [(ngModel)]="row.ref" /> </ng-container> <ng-template #readRef>{{ row.ref }}</ng-template> </td> </ng-container> <ng-container matColumnDef="strokeColor"> <th mat-header-cell *matHeaderCellDef> Stroke Color </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readStrokeColor"> <input matInput type="color" [(ngModel)]="row.strokeColor" /> </ng-container> <ng-template #readStrokeColor> <div [style.background]="row.strokeColor" class="color-preview"></div> </ng-template> </td> </ng-container> <ng-container matColumnDef="fillColor"> <th mat-header-cell *matHeaderCellDef> Fill Color </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readFillColor"> <input matInput type="color" [(ngModel)]="row.fillColor" /> </ng-container> <ng-template #readFillColor> <div [style.background]="row.fillColor" class="color-preview"></div> </ng-template> </td> </ng-container> <ng-container matColumnDef="style"> <th mat-header-cell *matHeaderCellDef> Style </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readStyle"> <mat-select [(value)]="row.style"> <mat-option *ngFor="let s of styles" [value]="s">{{ s }}</mat-option> </mat-select> </ng-container> <ng-template #readStyle>{{ row.style }}</ng-template> </td> </ng-container> <ng-container matColumnDef="actions"> <th mat-header-cell *matHeaderCellDef> Actions </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing"> <!-- Save Icon --> <button mat-icon-button (click)="saveRow(row)" aria-label="Save row"> <mat-icon>check</mat-icon> </button> <!-- Cancel Icon --> <button mat-icon-button (click)="cancelEdit(row)" aria-label="Cancel edit"> <mat-icon>close</mat-icon> </button> </ng-container> <ng-container *ngIf="!row.isEditing"> <!-- Edit Icon --> <button mat-icon-button (click)="editRow(row)" aria-label="Edit row"> <mat-icon>edit</mat-icon> </button> </ng-container> </td> </ng-container> <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr> <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> </table>
|   |   |   |   +-- style-editor.component.scss: .color-preview { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #ddd; } /* Make icons flat and apply royal blue color */ .mat-icon-button.flat { background: none; color: royalblue; border: none; box-shadow: none; } .mat-icon-button.flat:hover { background: rgba(65, 105, 225, 0.1); /* Adds a subtle hover effect */ } .mat-icon-button.flat:active { background: rgba(65, 105, 225, 0.2); /* Slightly darker hover on click */ } .icon-blue { color: blue; } .new-entry-row { background-color: #f2f2f2; }
|   |   |   |   +-- style-editor.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing'; import { StyleEditorComponent } from './style-editor.component'; describe('StyleEditorComponent', () => { let component: StyleEditorComponent; let fixture: ComponentFixture<StyleEditorComponent>; beforeEach(() => { TestBed.configureTestingModule({ declarations: [StyleEditorComponent] }); fixture = TestBed.createComponent(StyleEditorComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
|   |   |   |   \-- style-editor.component.ts: import { Component } from '@angular/core'; interface StyleRow { al: string; base: string; ref: string; strokeColor: string; fillColor: string; style: string; isEditing?: boolean; } @Component({ selector: 'style-editor', templateUrl: './style-editor.component.html', styleUrls: ['./style-editor.component.scss'] }) export class StyleEditorComponent { displayedColumns: string[] = ['al', 'base', 'ref', 'strokeColor', 'fillColor', 'style', 'actions']; styles: string[] = ['solid', 'dashed', 'dotted']; // D3 line styles dataSource: StyleRow[] = [ { al: 'SampleAl', base: 'SampleBase', ref: 'SampleRef', strokeColor: '#000000', fillColor: '#FFFFFF', style: 'solid', isEditing: false } ]; addRow() { // Add a new row at the top, in editing mode const newRow: StyleRow = { al: '', base: '', ref: '', strokeColor: '#000000', fillColor: '#FFFFFF', style: 'solid', isEditing: true // Set to true to start editing mode immediately }; this.dataSource = [newRow, ...this.dataSource]; // Assign a new array to trigger change detection } editRow(row: StyleRow) { row.isEditing = true; } saveRow(row: StyleRow) { row.isEditing = false; } cancelEdit(row: StyleRow) { if (!row.al && !row.base && !row.ref) { // Remove row if it's empty and a new entry const index = this.dataSource.indexOf(row); if (index > -1) { this.dataSource.splice(index, 1); } } else { row.isEditing = false; } } }
|   |   |   \-- table
|   |   |       +-- table.component.html: <div class="table-container" #tableContainer> <div class="table-content"> <table> <caption> <div class="table-controls"> <button (click)="onAddNewRow()"> <mat-icon>add_circle</mat-icon> </button> <button (click)="onSaveAll()"> <mat-icon>save</mat-icon> </button> </div> </caption> <thead> <!-- Column Headers with Sort/Filter Icons --> <tr class="header-row"> <th *ngFor="let column of displayedColumns" class="column-header"> <div class="header-content"> <div class="header-title"> {{column}} </div> <div class="header-actions"> <button class="icon-button sort-button" matTooltip="Sort"> <mat-icon class="small-icon">unfold_more</mat-icon> </button> <button class="icon-button filter-button" matTooltip="Toggle Filters" (click)="toggleFilters()" [class.active]="showFilters"> <mat-icon class="small-icon" [class.active]="showFilters">filter_list</mat-icon> </button> </div> </div> </th> <th class="actions-cell column-header"> <div class="header-content"> <div class="header-title">Actions</div> <div class="header-actions"> <button class="icon-button filter-toggle" matTooltip="Toggle All Filters" (click)="toggleFilters()" [class.active]="showFilters"> <mat-icon class="small-icon" [class.active]="showFilters">filter_list</mat-icon> </button> </div> </div> </th> </tr> <!-- Filter Inputs Row - Now with animation classes --> <tr class="filter-row" [@filterAnimation]="showFilters ? 'visible' : 'hidden'"> <th *ngFor="let column of displayedColumns"> <input type="text" class="filter-input" [placeholder]="'Filter ' + column" matTooltip="Enter filter criteria"> </th> <th class="actions-cell"> <button class="clear-filters" matTooltip="Clear all filters"> <mat-icon class="small-icon">clear</mat-icon> </button> </th> </tr> </thead> <tbody> <tr *ngFor="let row of paginatedData; let i = index" [class.selected]="row.selected" (click)="onRowClick(row, i, $event)"> <td *ngFor="let column of displayedColumns"> <ng-container *ngIf="!row.isEditing"> {{row[column]}} </ng-container> <ng-container *ngIf="row.isEditing"> <input *ngIf="column === 'base' || column === 'ref'" [value]="row[column]" (input)="onFieldChange($event.target.value, column, row, i)" (click)="$event.stopPropagation()"> <span *ngIf="column !== 'base' && column !== 'ref'">{{row[column]}}</span> </ng-container> </td> <td class="actions-cell"> <ng-container *ngIf="!row.isEditing"> <button (click)="onEdit(row, i, $event)"> <mat-icon>edit</mat-icon> </button> <button class="delete-button" (click)="onDelete(row, i, $event)"> <mat-icon>delete</mat-icon> </button> </ng-container> <ng-container *ngIf="row.isEditing"> <button (click)="onSave(row, i)"> <mat-icon>save</mat-icon> </button> <button (click)="onCancel(row, i)"> <mat-icon>close</mat-icon> </button> </ng-container> </td> </tr> </tbody> <tfoot> <tr> <td [attr.colspan]="displayedColumns.length + 1"> <div class="pagination-container"> <div class="pagination-controls"> <button class="pagination-button" (click)="goToFirstPage()" [disabled]="pagination.currentPage === 1"> <mat-icon>first_page</mat-icon> </button> <button class="pagination-button" (click)="goToPreviousPage()" [disabled]="pagination.currentPage === 1"> <mat-icon>chevron_left</mat-icon> </button> <div class="pagination-pages"> <button *ngFor="let page of visiblePages" class="pagination-button" [class.active]="page === pagination.currentPage" [class.ellipsis]="page === -1" [disabled]="page === -1" (click)="onPageChange(page)"> {{page === -1 ? '...' : page}} </button> </div> <button class="pagination-button" (click)="goToNextPage()" [disabled]="pagination.currentPage === totalPages"> <mat-icon>chevron_right</mat-icon> </button> <button class="pagination-button" (click)="goToLastPage()" [disabled]="pagination.currentPage === totalPages"> <mat-icon>last_page</mat-icon> </button> </div> <div class="page-size-selector"> <select (change)="onPageSizeChange($event.target.value)"> <option *ngFor="let size of pagination.pageSizeOptions" [value]="size" [selected]="size === pagination.pageSize"> {{size === -1 ? 'All' : size}} </option> </select> <span class="page-size-label">items per page</span> </div> </div> </td> </tr> </tfoot> </table> </div> </div>
|   |   |       +-- table.component.scss: // table.component.scss .table-controls { padding: 10px; display: flex; gap: 10px; align-items: center; button { background: none; border: none; padding: 0; cursor: pointer; color: #1976d2; &:hover { color: #1565c0; } } } .table-container { width: 100%; height: 100%; display: flex; flex-direction: column; font-family: 'Helvetica Neue', Arial, sans-serif; } .table-content { overflow: auto; position: relative; table { width: 95%; margin: 10px auto; border-collapse: collapse; table-layout: fixed; caption { caption-side: top; padding: 10px; .table-controls { display: flex; gap: 10px; align-items: center; justify-content: flex-start; button { background: none; border: none; padding: 4px; cursor: pointer; color: #1976d2; display: flex; align-items: center; justify-content: center; border-radius: 4px; &:hover { background-color: rgba(25, 118, 210, 0.04); color: #1565c0; } mat-icon { font-size: 20px; width: 20px; height: 20px; line-height: 20px; } } } } thead { th { position: sticky; top: 0; z-index: 10; background-color: #f5f5f5; padding: 8px; font-weight: 500; color: #333; border-bottom: 1px solid #e0e0e0; white-space: nowrap; transition: background-color 0.2s; box-shadow: 0 2px 2px -1px rgba(0,0,0,0.4); &:hover { background-color: #eeeeee; } } .header-row { th { padding: 0; } } .column-header { .header-content { display: flex; align-items: center; justify-content: space-between; padding: 8px; min-height: 48px; } .header-title { font-weight: 500; margin-right: 8px; } .header-actions { display: flex; gap: 4px; align-items: center; } .icon-button { background: none; border: none; padding: 4px; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666; transition: all 0.2s; &:hover { background-color: rgba(0, 0, 0, 0.04); color: #333; } .small-icon { font-size: 18px; width: 18px; height: 18px; line-height: 18px; &.active { color: #1976d2; } } } } .filter-row { background-color: #fafafa; transition: all 0.3s ease; &.hidden { display: none; } th { padding: 8px; background-color: #fafafa; border-top: 1px solid #e0e0e0; } .filter-input { width: 100%; padding: 6px 8px; border: 1px solid #e0e0e0; border-radius: 4px; font-size: 12px; background-color: white; transition: border-color 0.2s; &:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 0 1px rgba(25, 118, 210, 0.2); } &::placeholder { color: #999; } } .clear-filters { background: none; border: none; padding: 4px; cursor: pointer; color: #666; display: flex; align-items: center; justify-content: center; width: 100%; &:hover { color: #d32f2f; } } } } tbody { td { padding: 2px; text-align: left; border-bottom: 1px solid #e0e0e0; font-size: 12px; color: #333; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 150px; } tr { &:nth-child(even) { background-color: #ffffff; } &:nth-child(odd) { background-color: #f7f7f7; } &:hover { background-color: #f0f0f0; } &.selected { background-color: #add8e6; font-weight: bold; } } } .actions-cell { min-width: 100px; text-align: right; } tfoot { tr td { padding: 0; } } } // Pagination styles .pagination-container { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background-color: #fff; border-top: 1px solid #e0e0e0; } .pagination-controls { display: flex; align-items: center; gap: 4px; } .pagination-pages { display: flex; gap: 4px; } .pagination-button { min-width: 32px; height: 32px; padding: 0 4px; margin: 0 2px; border: none; background: none; border-radius: 4px; cursor: pointer; color: #1976d2; font-size: 13px; mat-icon { font-size: 18px; width: 18px; height: 18px; line-height: 18px; } &:hover:not(:disabled) { background-color: rgba(0, 0, 0, 0.04); } &:disabled { color: rgba(0, 0, 0, 0.26); cursor: default; } &.active { background-color: #1976d2; color: white; } &.ellipsis { cursor: default; &:hover { background: none; } } } .page-size-selector { display: flex; align-items: center; gap: 8px; select { padding: 4px 8px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: white; cursor: pointer; font-size: 13px; &:focus { outline: none; border-color: #1976d2; } } .page-size-label { color: rgba(0, 0, 0, 0.54); font-size: 13px; } } } .text-center { text-align: center; } .text-right { text-align: right; } .flex-grow { flex-grow: 1; } .ellipsis { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .column-header { .icon-button { &.active { color: #1976d2; background-color: rgba(25, 118, 210, 0.12); } } } .filter-row { background-color: #fafafa; th { border-top: 1px solid #e0e0e0; transition: padding 200ms cubic-bezier(0.4, 0.0, 0.2, 1); .filter-input { opacity: 1; transition: opacity 200ms cubic-bezier(0.4, 0.0, 0.2, 1); } } &.ng-animating { th { overflow: hidden; } } }
|   |   |       \-- table.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild } from '@angular/core'; import { ChangeDetectorRef } from '@angular/core'; import { FeatureCollection, Feature } from 'geojson'; import { DataService } from '../../services/data.service'; import { Subscription } from 'rxjs'; import { trigger, state, style, transition, animate } from '@angular/animations'; interface PaginationConfig { pageSize: number; currentPage: number; totalItems: number; pageSizeOptions: number[]; } @Component({ selector: 'app-table', templateUrl: './table.component.html', styleUrls: ['./table.component.scss'], animations: [ trigger('filterAnimation', [ state('hidden', style({ opacity: 0, height: '0px', minHeight: '0', padding: '0', overflow: 'hidden' })), state('visible', style({ opacity: 1, height: '*', minHeight: '48px' })), transition('hidden <=> visible', [ animate('200ms cubic-bezier(0.4, 0.0, 0.2, 1)') ]) ]) ] }) export class TableComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('tableContainer', { static: true }) tableContainer: ElementRef; displayedColumns: string[] = []; dataSource: any[] = []; private resizeObserver!: ResizeObserver; private subscription: Subscription; selectedRows = new Set(); lastClickedRowIndex: number | null = null; editingRows = new Set<number>(); formatCoord = (coord: number) => coord.toFixed(3); showFilters = false; paginatedData: any[] = []; // Add this line pagination: PaginationConfig = { pageSize: 10, currentPage: 1, totalItems: 0, pageSizeOptions: [10, 25, 50, 100, -1] // -1 represents 'All' }; constructor(private dataService: DataService, private cdr: ChangeDetectorRef) {} ngOnInit(): void { this.dataService.setSelectedFeatures([]); this.initTable(); this.subscription = this.dataService.getSelectedFeatures().subscribe(features => { this.updateTableSelection(features); }); } ngAfterViewInit(): void { this.resizeObserver = new ResizeObserver(() => { this.resizeTable(); }); this.resizeObserver.observe(this.tableContainer.nativeElement); } ngOnDestroy(): void { if (this.resizeObserver) { this.resizeObserver.disconnect(); } this.subscription.unsubscribe(); } private initTable(): void { const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer?.getFeatures()?.length > 0) { const features = selectedLayer.getFeatures(); if (features[0].properties) { this.displayedColumns = Object.keys(features[0].properties); this.dataSource = features.map(feature => ({ ...feature.properties, id: feature.id, selected: false, isEditing: false })); this.pagination.totalItems = this.dataSource.length; this.updatePaginatedData(); } } } initializeNewEntry(): any { return { id: 'NEW', Airline: 'DL', base: '', ref: '', 'City 1': '', 'City 2': '', 'Coords 1': '(0.000, 0.000)', 'Coords 2': '(0.000, 0.000)', isEditing: true, isNew: true }; } onAddNewRow(): void { const newEntry = this.initializeNewEntry(); this.dataSource.unshift(newEntry); } onFieldChange(value: string, field: string, row: any, index: number): void { // Sanitize the input const sanitizedValue = value.toUpperCase().replace(/[^A-Z0-9]/g, ''); // Update the specific row's field row[field] = sanitizedValue; // Only trigger the airport lookup if we have a complete code if (sanitizedValue.length === 3) { if (field === 'base') { const baseAirport = this.dataService.getAirport(sanitizedValue); if (baseAirport) { row['City 1'] = baseAirport.city; row['Coords 1'] = `(${this.formatCoord(baseAirport.lon)}, ${this.formatCoord(baseAirport.lat)})`; this.updateId(row); } else { alert('Base airport not found'); row.base = ''; } } else if (field === 'ref') { const refAirport = this.dataService.getAirport(sanitizedValue); if (refAirport) { row['City 2'] = refAirport.city; row['Coords 2'] = `(${this.formatCoord(refAirport.lon)}, ${this.formatCoord(refAirport.lat)})`; this.updateId(row); } else { alert('Ref airport not found'); row.ref = ''; } } } } updateId(row: any): void { if (row.base && row.ref) { const newId = `${row.base}-${row.ref}-DL`; const idExists = this.dataSource.some(r => r.id === newId && r !== row); if (idExists) { alert('Route with this ID already exists'); row.id = row.isNew ? 'NEW' : row.originalData.id; } else { row.id = newId; } } } resizeTable(): void { if (this.tableContainer) { const width = this.tableContainer.nativeElement.offsetWidth; const height = this.tableContainer.nativeElement.offsetHeight; console.log(`Resizing table to ${width}x${height}`); } } onRowClick(row: any, index: number, event: MouseEvent): void { if (this.editingRows.size > 0) { return; // Prevent selection while editing } this.lastClickedRowIndex = index; let newSelection; if (event.shiftKey && this.lastClickedRowIndex !== null) { const start = Math.min(index, this.lastClickedRowIndex); const end = Math.max(index, this.lastClickedRowIndex); newSelection = this.dataSource.slice(start, end + 1); } else if (event.ctrlKey || event.metaKey) { newSelection = [...this.dataService.getSelectedFeatures().value || []]; const idx = newSelection.findIndex(item => item.id === row.id); if (idx > -1) { newSelection.splice(idx, 1); } else { newSelection.push(row); } } else { newSelection = [row]; } this.dataService.setSelectedFeatures(newSelection); } updateTableSelection(features: Feature[] | null): void { if (!features) { console.log('No features to update in table.'); return; } this.dataSource.forEach(row => { const isSelected = features.some(feature => feature && feature.id === row.id); if (isSelected !== row.selected) { row.selected = isSelected; } }); } onEdit(row: any, index: number, event: Event): void { event.stopPropagation(); row.originalData = { ...row }; row.isEditing = true; this.editingRows.add(index); } onSave(row: any, index: number): void { if (row.id === 'NEW' || !row.base || !row.ref) { alert('Please complete all required fields before saving'); return; } const feature = this.createFeatureFromEntry(row); const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer) { if (row.isNew) { this.dataService.addFeature(feature); } else { this.dataService.updateFeature(feature); } this.dataService.addLayer('routes', selectedLayer); row.isEditing = false; row.isNew = false; delete row.originalData; this.editingRows.delete(index); const currentlySelectedFeatures = this.dataService.getSelectedFeatures().value || []; this.dataService.setSelectedFeatures([...currentlySelectedFeatures]); } } onCancel(row: any, index: number): void { if (row.isNew) { this.dataSource = this.dataSource.filter((_, i) => i !== index); } else { Object.assign(row, row.originalData); row.isEditing = false; delete row.originalData; } this.editingRows.delete(index); } onDelete(row: any, index: number, event: Event): void { event.stopPropagation(); if (confirm('Are you sure you want to delete this row?')) { const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer && !row.isNew) { this.dataService.removeFeature(row.id); this.dataService.addLayer('routes', selectedLayer); } this.dataSource = this.dataSource.filter((_, i) => i !== index); } } onSaveAll(): void { const selectedLayer = this.dataService.getSelectedLayer(); if (!selectedLayer) { alert('No layer selected'); return; } for (const row of this.dataSource) { if (row.isNew || row.isEditing) { if (row.id === 'NEW' || !row.base || !row.ref) { alert('Please complete all required fields before saving'); return; } const feature = this.createFeatureFromEntry(row); if (row.isNew) { this.dataService.addFeature(feature); } else { this.dataService.updateFeature(feature); } row.isEditing = false; row.isNew = false; delete row.originalData; } } this.editingRows.clear(); this.dataService.addLayer('routes', selectedLayer); const currentlySelectedFeatures = this.dataService.getSelectedFeatures().value || []; this.dataService.setSelectedFeatures([...currentlySelectedFeatures]); } private createFeatureFromEntry(entry: any): Feature { const city1 = this.dataService.getAirport(entry.base); const city2 = this.dataService.getAirport(entry.ref); const coords1 = [city1.lon, city1.lat]; const coords2 = [city2.lon, city2.lat]; return { type: 'Feature', id: entry.id, geometry: { type: 'LineString', coordinates: [ coords1, coords2 ] }, properties: { Airline: entry.Airline, base: entry.base, ref: entry.ref, 'City 1': entry['City 1'], 'City 2': entry['City 2'], 'Coords 1': entry['Coords 1'], 'Coords 2': entry['Coords 2'] }, }; } // Pagination Methods updatePaginatedData(): void { if (this.pagination.pageSize === -1) { // Show all data this.paginatedData = [...this.dataSource]; return; } const startIndex = (this.pagination.currentPage - 1) * this.pagination.pageSize; const endIndex = startIndex + this.pagination.pageSize; this.paginatedData = this.dataSource.slice(startIndex, endIndex); } get totalPages(): number { if (this.pagination.pageSize === -1) return 1; return Math.ceil(this.pagination.totalItems / this.pagination.pageSize); } get visiblePages(): number[] { const totalPages = this.totalPages; const current = this.pagination.currentPage; const pages: number[] = []; if (totalPages <= 7) { // Show all pages if total is 7 or less for (let i = 1; i <= totalPages; i++) pages.push(i); } else { // Always show first page pages.push(1); if (current > 3) pages.push(-1); // Add ellipsis // Show pages around current page for (let i = Math.max(2, current - 1); i <= Math.min(totalPages - 1, current + 1); i++) { pages.push(i); } if (current < totalPages - 2) pages.push(-1); // Add ellipsis // Always show last page pages.push(totalPages); } return pages; } onPageSizeChange(newSize: number): void { this.pagination.pageSize = newSize; this.pagination.currentPage = 1; // Reset to first page this.updatePaginatedData(); } onPageChange(page: number): void { if (page < 1 || page > this.totalPages) return; this.pagination.currentPage = page; this.updatePaginatedData(); } // Navigation methods goToFirstPage(): void { this.onPageChange(1); } goToLastPage(): void { this.onPageChange(this.totalPages); } goToPreviousPage(): void { this.onPageChange(this.pagination.currentPage - 1); } goToNextPage(): void { this.onPageChange(this.pagination.currentPage + 1); } toggleFilters(event?: Event): void { if (event) { event.stopPropagation(); } this.showFilters = !this.showFilters; } }
|   |   +-- enums
|   |   |   \-- projection-type.enum.ts: // src/app/enums/projection-type.enum.ts export enum ProjectionType { Armadillo = 'armadillo', Gnomonic = 'gnomonic', LambertConicConformal = 'lambertConicConformal', Mercator = 'mercator', Orthographic = 'orthographic', TiltedPerspective = 'tiltedPerspective', TransverseMercator = 'transverseMercator', Equirectangular = 'equirectangular', NaturalEarth = 'naturalEarth', AzimuthalEqualArea = 'azimuthalEqualArea', Stereographic = 'stereographic', AlbersUSA = 'albersUSA', Sinusoidal = 'sinusoidal', Mollweide= 'mollweide' }
|   |   +-- guards
|   |   |   \-- auth.guard.ts: // src/app/guards/auth.guard.ts import { Injectable } from '@angular/core'; import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router'; import { AuthService } from '../services/auth.service'; @Injectable({ providedIn: 'root' }) export class AuthGuard implements CanActivate { constructor(private authService: AuthService, private router: Router) {} canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean { // Define public routes that don't require authentication const publicRoutes = ['/admin/users', '/login', '/identity/profile', '/identity/password', '/identity/username']; // Check if the current route is in public routes if (publicRoutes.some(route => state.url.startsWith(route))) { return true; } // Check if user is authenticated if (this.authService.isAuthenticated()) { return true; } // Not authenticated and not a public route, redirect to login this.router.navigate(['/login']); return false; } }
|   |   +-- interfaces
|   |   |   +-- airport-data.interface.ts: export interface AirportData { code: string; // Airport code (e.g., IATA code) region: number; // Region code or ID, if applicable name: string; // Name of the airport city: string; // City in which the airport is located country: string; // Country in which the airport is located lat: number; // Latitude of the airport lon: number; // Longitude of the airport }
|   |   |   +-- filter-listener.ts: export interface FilterCriteria { [key: string]: any; } export interface FilterListener { /** * Called when a filter is applied. * @param criteria The filter criteria */ onFilter(criteria: FilterCriteria): void; /** * Called when the filter is cleared. */ onClearFilter(): void; }
|   |   |   +-- flight-data.interface.ts: export interface FlightData { flight_number?: string; origin?: string; destination?: string; frequency?: string; days?: string; departure_time?: string; arrival_time?: string; effective_date?: string | null; discontinued_date?: string | null; suspension_start?: string | null; suspension_end?: string | null; notes?: string | null; }
|   |   |   +-- model-listener.ts: import { GeoModel } from '../models/geo-model'; export interface ModelListener { /** * Called when the model data is updated. * @param model The updated GeoJSONModel */ onModelChange(model: GeoModel): void; }
|   |   |   \-- selection-listener.ts: import { Feature } from 'geojson'; export interface SelectionListener { /** * Called when a feature is selected. * @param feature The selected feature */ onSelect(feature: Feature): void; /** * Called when a feature is deselected. * @param feature The deselected feature */ onDeselect(feature: Feature): void; /** * Called when the selection is cleared. */ onClearSelection(): void; }
|   |   +-- models
|   |   |   +-- criteria.model.ts: export interface CriteriaModel { filterString: string; // Add any additional filter criteria properties as needed }
|   |   |   \-- layer.ts: // Importing the GeoJSON Feature type import { Feature } from 'geojson'; export class Layer { public name: string; private features: Feature[]; // An array of GeoJSON Features constructor(name: string, features: Feature[] = []) { this.name = name; this.features = features; } // Method to get all features getFeatures(): Feature[] { return this.features; } // Method to add a feature addFeature(feature: Feature): void { this.features.push(feature); } // Method to find a feature by ID findFeatureById(id: string | number): Feature | undefined { return this.features.find(feature => feature.id === id); } // Method to remove a feature by ID removeFeatureById(id: string | number): void { this.features = this.features.filter(feature => feature.id !== id); } getProperty(index: number): { [key: string]: any } | undefined { const feature = this.features[index]; return feature ? feature.properties : undefined; } // Method to get properties of all features getProperties(): { [key: string]: any }[] { return this.features .map(feature => feature.properties) .filter(properties => properties !== undefined); } // Custom toString() method for the Layer class toString(): string { if (this.features.length === 0) { return `Layer Name: ${this.name}, Number of Features: 0 (No feature data available)`; } // Extract property names from the first feature const propertyNames = this.features[0].properties ? Object.keys(this.features[0].properties) : []; return `Layer Name: ${this.name}, Number of Features: ${this.features.length}, Property Names: ${propertyNames.join(', ')}`; } }
|   |   +-- projections
|   |   |   +-- components
|   |   |   |   +-- projection-controls
|   |   |   |   \-- projection-map
|   |   |   +-- models
|   |   |   |   +-- abstract
|   |   |   |   |   +-- abstract-projection.ts
|   |   |   |   |   +-- abstract-pseudocylindrical.ts
|   |   |   |   |   \-- index.ts
|   |   |   |   +-- eckert
|   |   |   |   |   +-- eckert-i.ts
|   |   |   |   |   +-- eckert-iv.ts
|   |   |   |   |   \-- index.ts
|   |   |   |   \-- index.ts
|   |   |   +-- pipes
|   |   |   +-- services
|   |   |   |   +-- coordinate.service.ts
|   |   |   |   \-- projection.service.ts
|   |   |   +-- types
|   |   |   |   +-- coordinate.types.ts
|   |   |   |   \-- projection.types.ts: // src/app/projections/types/projection.types.ts export interface GeoCoordinates { lat: number; // Latitude in radians lon: number; // Longitude in radians } export interface ProjectedCoordinates { x: number; y: number; } export enum ProjectionFlags { EqualArea = 'equalArea', Pseudocylindrical = 'pseudocylindrical', SinusoidalSpacing = 'sinusoidalSpacing', MeridiansCurved = 'meridiansCurved', Equidistant = 'equidistant', Compromise = 'compromise', ParallelLatitudes = 'parallelLatitudes', Symmetric = 'symmetric' } export interface ProjectionConfig { R?: number; // Sphere radius lat0?: number; // Central latitude lon0?: number; // Central longitude flags?: ProjectionFlags[]; }
|   |   |   +-- utils
|   |   |   |   \-- math.utils.ts
|   |   |   +-- index.ts
|   |   |   \-- projections.module.ts
|   |   +-- services
|   |   |   +-- airport.service.ts: import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { AirportData } from '../interfaces/airport-data.interface'; // Update the path as necessary @Injectable({ providedIn: 'root' }) export class AirportService { constructor(private http: HttpClient) {} loadAirportData(): Observable<AirportData[]> { return this.http.get<AirportData[]>('assets/Airport.json'); } }
|   |   |   +-- aside.service.ts: // services/aside.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { Router, NavigationEnd } from '@angular/router'; import { filter } from 'rxjs/operators'; interface AsideContent { title: string; commands?: { action: string; keys: string; description: string; }[]; } @Injectable({ providedIn: 'root' }) export class AsideService { private contentSubject = new BehaviorSubject<AsideContent | null>(null); private isVisibleSubject = new BehaviorSubject<boolean>(true); private routeMap = new Map<string, AsideContent>([ ['/orthographic', { title: 'Orthographic Controls', commands: [ { action: 'Rotate Globe', keys: 'Mouse Drag', description: 'Click and drag to rotate the view' }, { action: 'Zoom', keys: 'Alt + Mouse Drag', description: 'Hold Alt and drag to define zoom area' }, { action: 'Reset View', keys: 'Double Click', description: 'Reset to default view' } ] }] ]); constructor(router: Router) { router.events.pipe( filter(event => event instanceof NavigationEnd) ).subscribe((event: NavigationEnd) => { this.contentSubject.next(this.routeMap.get(event.url) || null); }); } getContent() { return this.contentSubject.asObservable(); } getVisibility() { return this.isVisibleSubject.asObservable(); } toggleVisibility() { this.isVisibleSubject.next(!this.isVisibleSubject.value); } }
|   |   |   +-- auth.service.ts: // src/app/services/auth.service.ts import { Injectable } from '@angular/core'; import { Router } from '@angular/router'; @Injectable({ providedIn: 'root' }) export class AuthService { constructor(private router: Router) {} login(username: string, password: string): boolean { if (username === 'admin' && password === 'admin') { localStorage.setItem('isLoggedIn', 'true'); this.router.navigate(['/map']); return true; } return false; } logout() { localStorage.removeItem('isLoggedIn'); this.router.navigate(['/login']); } isAuthenticated(): boolean { return localStorage.getItem('isLoggedIn') === 'true'; } }
|   |   |   +-- data.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { Layer } from '../models/layer'; import { AirportData } from '../interfaces/airport-data.interface'; import { Feature } from 'geojson'; @Injectable({ providedIn: 'root' }) export class DataService { private airports: Map<string, AirportData> = new Map(); // Stores airport data by code private layersMap: Map<string, Layer> = new Map(); private selectedLayerName: string | null = null; private selectedFeatures: BehaviorSubject<Feature[] | null> = new BehaviorSubject([]); // Layer Getters and Setters public addLayer(name: string, layer: Layer): void { this.layersMap.set(name, layer); } public getLayer(name: string): Layer | undefined { return this.layersMap.get(name); } public getLayerNames(): string[] { return Array.from(this.layersMap.keys()); } public getLayers(): Layer[] { return Array.from(this.layersMap.values()); } public getSelectedLayer(): Layer | undefined { if (this.selectedLayerName) { return this.layersMap.get(this.selectedLayerName); } return undefined; } public setSelectedLayer(layerName: string): void { this.selectedLayerName = layerName; const selectedLayer = this.layersMap.get(layerName); if (selectedLayer && selectedLayer.getFeatures()) { //console.log(`Setting selected layer: ${layerName} with ${selectedLayer.getFeatures().length} features`); this.setSelectedFeatures(selectedLayer.getFeatures()); } else { this.setSelectedFeatures([]); // Clear features if the layer is undefined or has no features } } public setSelectedFeatures(features: Feature[]): void { //console.log('DataService.setSelectedFeatures called with features:', features); this.selectedFeatures.next(features); } public getSelectedFeatures(): BehaviorSubject<Feature[]> { return this.selectedFeatures; } // Airport Getters and Setters public getAirports(): AirportData[] { return Array.from(this.airports.values()); } public setAirports(airports: AirportData[]): void { this.airports.clear(); airports.forEach(airport => { this.airports.set(airport.code, airport); }); //console.log('Airports data set in DataService'); } public getAirport(code: string): AirportData | undefined { return this.airports.get(code); } public setAirport(airport: AirportData): void { if (airport && airport.code) { this.airports.set(airport.code, airport); //console.log(`Airport data updated for ${airport.code} in DataService`); } else { //console.error('Invalid airport data provided'); } } // New methods for feature management updateFeature(feature: Feature) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); const index = features.findIndex((f: Feature) => f.id === feature.id); if (index !== -1) { features[index] = feature; //this.getSelectedLayer().setFeatures(features); } } } removeFeature(featureId: string) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); const filteredFeatures = features.filter((f: Feature) => f.id !== featureId); //this.getSelectedLayer().setFeatures(filteredFeatures); } } addFeature(feature: Feature) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); features.push(feature); //this.getSelectedLayer().setFeatures(features); } } }
|   |   |   +-- query-processor.spec.ts: // import { processAndSortData } from './queryProcessor'; // describe('Query Processor', () => { // const mockData = [ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]; // it('should filter data with a simple "eq" condition', () => { // const query = { // and: [{ field: 'al', operator: 'eq', value: 'DL' }] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' } // ]); // }); // it('should filter data with "not_in" condition', () => { // const query = { // and: [{ field: 'base', operator: 'not_in', value: ['ATL', 'MSP'] }] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]); // }); // it('should filter data with nested "or" and "and" conditions', () => { // const query = { // or: [ // { field: 'al', operator: 'eq', value: 'UA' }, // { // and: [ // { field: 'al', operator: 'eq', value: 'DL' }, // { field: 'ref', operator: 'in', value: ['SEA', 'ORD'] } // ] // } // ] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]); // }); // it('should sort data based on the "base" field in ascending order', () => { // const query = { // sort: { field: 'base', order: 'asc' } // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'UA', base: 'DEN', ref: 'IAH' }, // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'DL', base: 'SLC', ref: 'SEA' } // ]); // }); // });
|   |   |   +-- query-processor.ts: // export type QueryCondition = { // field: string; // operator: 'eq' | 'in' | 'not_in'; // value: any; // }; // export type Query = { // and?: QueryCondition[] | Query[]; // or?: QueryCondition[] | Query[]; // sort?: { field: string; order: 'asc' | 'desc' }; // }; // // Function to evaluate a single condition // function evaluateCondition(item: any, condition: QueryCondition): boolean { // switch (condition.operator) { // case 'eq': // return item[condition.field] === condition.value; // case 'in': // return Array.isArray(condition.value) && condition.value.includes(item[condition.field]); // case 'not_in': // return Array.isArray(condition.value) && !condition.value.includes(item[condition.field]); // default: // throw new Error(`Unsupported operator: ${condition.operator}`); // } // } // // Function to process a query with nested logic // export function processQuery(data: any[], query: Query): any[] { // if (query.and) { // return data.filter(item => query.and!.every(subQuery => Array.isArray(subQuery) ? processQuery([item], subQuery).length > 0 : evaluateCondition(item, subQuery))); // } // if (query.or) { // return data.filter(item => query.or!.some(subQuery => Array.isArray(subQuery) ? processQuery([item], subQuery).length > 0 : evaluateCondition(item, subQuery))); // } // return data; // } // // Function to apply sorting // export function sortData(data: any[], sort: { field: string; order: 'asc' | 'desc' }): any[] { // return data.sort((a, b) => { // if (sort.order === 'asc') return a[sort.field] > b[sort.field] ? 1 : -1; // return a[sort.field] < b[sort.field] ? 1 : -1; // }); // } // // Main function to process and sort data based on query // export function processAndSortData(data: any[], query: Query): any[] { // let filteredData = processQuery(data, query); // if (query.sort) { // filteredData = sortData(filteredData, query.sort); // } // return filteredData; // }
|   |   |   \-- resources.ts: import * as Papa from 'papaparse'; export class Resources { static async load(filePaths: string[]): Promise<any[]> { try { const results = []; for (const path of filePaths) { let data; if (path.endsWith('.json') || path.endsWith('.geojson')) { const response = await fetch(path); if (!response.ok) throw new Error(`Failed to load ${path}`); data = await response.json(); } else if (path.endsWith('.csv')) { const response = await fetch(path); if (!response.ok) throw new Error(`Failed to load ${path}`); const csvText = await response.text(); data = Papa.parse(csvText, { header: true, skipEmptyLines: true, }).data; } results.push({ data, path }); } return results; } catch (err) { console.error('Error during resource loading:', err); throw err; } } }
|   |   +-- sphere
|   |   +-- types
|   |   |   +-- solar-calculator.d.ts: // src/app/types/solar-calculator.d.ts declare module 'solar-calculator' { export function century(date: Date): number; export function declination(t: number): number; export function equationOfTime(t: number): number; export function apparentLongitude(t: number): number; export function meanAnomaly(t: number): number; export function meanLongitude(t: number): number; export function obliquityOfEcliptic(t: number): number; export function trueLongitude(t: number): number; const solar: { century(date: Date): number; declination(t: number): number; equationOfTime(t: number): number; hourAngle(t: number, latitude: number): number; radius(t: number): number; rightAscension(t: number): number; solarNoon(t: number, longitude: number): number; zenith(t: number, latitude: number): number; }; export default solar; }
|   |   |   \-- versor.d.ts: declare module 'versor' { interface VersorFunction { (rotate: [number, number, number]): number[]; delta(v0: [number, number, number], v1: [number, number, number]): number[]; rotation(q: number[]): [number, number, number]; } const versor: VersorFunction; export = versor; }
|   |   +-- utils
|   |   |   \-- geo-feature.util.ts: import { Feature, LineString } from 'geojson'; import * as d3 from 'd3-geo'; import { AirportService } from '../services/airport.service'; import { AirlineService } from '../services/airline.service'; export function createGreatCircleFeature( cityPair: any, airportService: AirportService, airlineService: AirlineService ): Feature<LineString> | null { //console.log('Looking up base airport:', cityPair.base); const baseAirport = airportService.getAirportByCode(cityPair.base); //console.log('Looking up ref airport:', cityPair.ref); const refAirport = airportService.getAirportByCode(cityPair.ref); if (!baseAirport || !refAirport) { //console.error('Airport not found for base or ref:', cityPair.base, cityPair.ref); return null; } const baseCoords: [number, number] = [baseAirport.lon, baseAirport.lat]; const refCoords: [number, number] = [refAirport.lon, refAirport.lat]; const greatCircle = d3.geoInterpolate(baseCoords, refCoords); const steps = 50; const pathCoords = Array.from({ length: steps + 1 }, (_, i) => greatCircle(i / steps)); const feature: Feature<LineString> = { type: 'Feature', geometry: { type: 'LineString', coordinates: pathCoords }, properties: { base: baseAirport.code, ref: refAirport.code, baseName: baseAirport.name, refName: refAirport.name, airline: airlineService.getAirlineByCode(cityPair.al)?.name || 'Unknown Airline', distance: d3.geoDistance(baseCoords, refCoords), layer: 'puck' } }; return feature; }
|   |   +-- app-routing.module.ts: // src/app/app-routing.module.ts import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { LoginComponent } from './components/login/login.component'; import { MainLayoutComponent } from './components/layout/main-layout.component'; import { MapViewComponent } from './components/map-view/map-view.component'; import { AuthGuard } from './guards/auth.guard'; import { PasswordComponent } from './components/identity/password/password.component'; import { ProfileComponent } from './components/identity/profile/profile.component'; import { UsernameComponent } from './components/identity/username/username.component'; import { UsersComponent } from './components/admin/users/users.component'; import { UserDetailComponent } from './components/admin/user-detail/user-detail.component'; import { RoleDetailComponent } from './components/admin/role-detail/role-detail.component'; import { RolesComponent } from './components/admin/roles/roles.component'; import { PerspectiveComponent } from './components/perspective/perspective.component'; import { PasswordResetComponent } from './components/identity/password-reset/password-reset.component'; import { OrthographicComponent } from './components/projections/azimuthal/orthographic/orthographic.component'; import { SolarComponent } from './components/projections/solar/solar.component'; import { UtmComponent } from './components/projections/cylindrical/utm/utm.component'; import { AlbersComponent } from './components/projections/albers/albers.component'; const routes: Routes = [ { path: '', redirectTo: '/login', pathMatch: 'full' }, { path: 'login', component: LoginComponent }, { path: '', component: MainLayoutComponent, canActivate: [AuthGuard], children: [ { path: 'map', component: MapViewComponent }, { path: 'admin/users', component: UsersComponent, canActivate: [AuthGuard] }, { path: 'admin/users/:id', component: UserDetailComponent, canActivate: [AuthGuard] }, { path: 'admin/roles', component: RolesComponent, canActivate: [AuthGuard] }, { path: 'admin/roles/:id', component: RoleDetailComponent, canActivate: [AuthGuard] }, { path: 'orthographic', component: OrthographicComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' { path: 'perspective', component: PerspectiveComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' { path: 'solar', component: SolarComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' { path: 'utm', component: UtmComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' //{ path: 'gnomic', component: UtmComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' //{ path: 'two-point', component: UtmComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' //{ path: 'lambert', component: UtmComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' { path: 'albers', component: AlbersComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' //{ path: 'cylindrical', component: CylinricalComponent, canActivate: [AuthGuard] }, // Fixed typo in 'perspective' { path: 'logout', redirectTo: '/login', pathMatch: 'full' } ] }, { path: 'identity/profile', component: ProfileComponent }, // Route for user registration { path: 'identity/password', component: PasswordComponent }, // Route for password reset { path: 'identity/username', component: UsernameComponent }, // Route for username assistance { path: 'identity/password-reset', component: PasswordResetComponent }, // New route { path: '**', redirectTo: '/login', pathMatch: 'full' } // Wildcard route for a 404 page ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }
|   |   +-- app.component.html
|   |   +-- app.component.scss
|   |   +-- app.component.ts: import { Component } from '@angular/core'; @Component({ selector: 'app-root', template: '<router-outlet></router-outlet>', styleUrls: ['./app.component.scss'] }) export class AppComponent {}
|   |   \-- app.module.ts: import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { HttpClientModule } from '@angular/common/http'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { RouterModule } from '@angular/router'; import { CommonModule } from '@angular/common'; import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component'; import { MatPaginatorModule } from '@angular/material/paginator'; import { MatSortModule } from '@angular/material/sort'; import { MatTooltipModule } from '@angular/material/tooltip'; import { MatTabsModule } from '@angular/material/tabs'; import { MatTableModule } from '@angular/material/table'; import { MatIconModule } from '@angular/material/icon'; import { MapComponent } from './components/map/map.component'; import { MapViewComponent } from './components/map-view/map-view.component'; import { TableComponent } from './components/table/table.component'; import { DataService } from './services/data.service'; import { PaneModule } from './components/pane/pane.module'; import { AirportTableComponent } from './components/airport-table/airport-table.component'; import { StyleEditorComponent } from './components/style-editor/style-editor.component'; import { LoginComponent } from './components/login/login.component'; import { AuthService } from './services/auth.service'; import { AuthGuard } from './guards/auth.guard'; import { PasswordComponent } from './components/identity/password/password.component'; import { UsernameComponent } from './components/identity/username/username.component'; import { ProfileComponent } from './components/identity/profile/profile.component'; import { MainLayoutComponent } from './components/layout/main-layout.component'; import { IxtTableModule, IxtTabsetModule } from '@dvanauken/ixtlan/dist/ixtlan'; import { UserDetailComponent } from './components/admin/user-detail/user-detail.component'; import { UsersComponent } from './components/admin/users/users.component'; import { RoleDetailComponent } from './components/admin/role-detail/role-detail.component'; import { RolesComponent } from './components/admin/roles/roles.component'; import { PerspectiveComponent } from './components/perspective/perspective.component'; import { PasswordResetComponent } from './components/identity/password-reset/password-reset.component'; import { SolarComponent } from './components/projections/solar/solar.component'; import { AlbersComponent } from './components/projections/albers/albers.component'; @NgModule({ declarations: [ AlbersComponent, SolarComponent, AppComponent, MapComponent, TableComponent, AirportTableComponent, StyleEditorComponent, LoginComponent, MapViewComponent, MainLayoutComponent, UsernameComponent, PasswordComponent, ProfileComponent, UsersComponent, UserDetailComponent, RolesComponent, RoleDetailComponent, PerspectiveComponent, PasswordResetComponent ], imports: [ CommonModule, BrowserModule, BrowserAnimationsModule, HttpClientModule, FormsModule, ReactiveFormsModule, RouterModule, AppRoutingModule, PaneModule, MatTabsModule, MatTableModule, MatPaginatorModule, MatSortModule, MatIconModule, MatTooltipModule, IxtTableModule, IxtTabsetModule ], providers: [ DataService, AuthService, AuthGuard ], bootstrap: [AppComponent] }) export class AppModule { }
|   +-- assets
|   |   +-- 10m
|   |   |   +-- ne_10m_admin_0_boundary_lines_land.geojson
|   |   |   +-- ne_10m_airports.geojson
|   |   |   +-- ne_10m_graticules_30.geojson
|   |   |   +-- ne_10m_populated_places_simple.geojson
|   |   |   +-- ne_10m_railroads_north_america.geojson
|   |   |   \-- ne_10m_time_zones.geojson
|   |   +-- 110m
|   |   |   +-- countries.geojson
|   |   |   +-- lakes.geojson
|   |   |   +-- ne_110m_admin_0_countries_lakes.geojson
|   |   |   +-- ne_110m_admin_1_states_provinces.geojson
|   |   |   +-- ne_110m_coastline.geojson
|   |   |   +-- ne_110m_lakes.geojson
|   |   |   +-- ne_110m_land.geojson
|   |   |   +-- ne_110m_ocean.geojson
|   |   |   +-- ne_110m_populated_places.geojson
|   |   |   +-- ne_110m_populated_places_simple.geojson
|   |   |   +-- ne_110m_rivers_lake_centerlines.geojson
|   |   |   +-- test.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Geographical Projection</title> <script src="https://d3js.org/d3.v6.min.js"></script> <style> svg { width: 100%; height: auto; } </style> </head> <body> <svg></svg> <script> // Constants const R = 6371; // Mean radius of the Earth in kilometers function perspectiveProjection(P, Ï†0, Î»0) { return function(Î», Ï†) { const Ï†Rad = Ï† * Math.PI / 180; const Î»Rad = Î» * Math.PI / 180; const Ï†0Rad = Ï†0 * Math.PI / 180; const Î»0Rad = Î»0 * Math.PI / 180; const cosC = Math.sin(Ï†0Rad) * Math.sin(Ï†Rad) + Math.cos(Ï†0Rad) * Math.cos(Ï†Rad) * Math.cos(Î»Rad - Î»0Rad); if (cosC < 1 / P) { return [NaN, NaN]; // Reject points outside the projection } const k = (P - 1) / (P * Math.cos(cosC) - 1); const x = R * k * Math.cos(Ï†Rad) * Math.sin(Î»Rad - Î»0Rad); const y = R * k * (Math.cos(Ï†0Rad) * Math.sin(Ï†Rad) - Math.sin(Ï†0Rad) * Math.cos(Ï†Rad) * Math.cos(Î»Rad - Î»0Rad)); return [x, y]; }; } const projection = perspectiveProjection(2, 0, 0); // P = 2, Ï†0 = 0, Î»0 = 0 console.log(typeof projection); // Check if it's a function const svg = d3.select("svg"); const path = d3.geoPath().projection(projection); d3.json("countries.geojson").then(data => { console.log(data); // Inspect the data structure svg.selectAll("path") .data(data.features) .enter().append("path") .attr("d", path) .attr("fill", "steelblue") .attr("stroke", "black"); }).catch(error => { console.error("Error loading the GeoJSON data:", error); }); </script> </body> </html>
|   |   |   \-- world-110m.v1.json
|   |   +-- 50m
|   |   |   +-- ne_50m_land.geojson
|   |   |   +-- ne_50m_ocean.geojson
|   |   |   +-- ne_50m_populated_places_simple.geojson
|   |   |   \-- ne_50m_urban_areas.geojson
|   |   +-- styles
|   |   |   \-- map.svg.css
|   |   +-- .gitkeep
|   |   +-- Airline.json
|   |   +-- Airport - Copy.json
|   |   +-- Airport.json
|   |   +-- counties-10m.json
|   |   +-- counties-albers-10m.json
|   |   +-- counties-albers-110m.json
|   |   +-- land-10m.json
|   |   +-- land-110m.json
|   |   +-- land-50m.json
|   |   +-- logo.png
|   |   +-- logo2.png
|   |   +-- moscow.geojson
|   |   +-- nation-10m - Copy.json
|   |   +-- nation-10m.json
|   |   +-- nation-albers-10m.json
|   |   +-- outlines-albers-10m.json
|   |   +-- pa.csv
|   |   +-- routes.json
|   |   +-- spinner.gif
|   |   +-- states-10m.json
|   |   +-- states-albers-10m.json
|   |   \-- us-10m.v2.json
|   +-- test
|   +-- create_projection_structure.bat
|   +-- favicon.ico
|   +-- index.html: <!doctype html> <html lang="en"> <head> <meta charset="utf-8" /> <title>GeoView</title> <base href="/" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <link rel="icon" type="image/x-icon" href="favicon.ico" /> <link rel="preconnect" href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> </head> <body class="mat-typography"> <app-root></app-root> </body> </html>
|   +-- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) => console.error(err));
|   \-- styles.scss: /* styles.scss */ html, body { height: 100vh; margin: 0; padding: 0; overflow: hidden; background-color: #f5f5f5; } // Login layout .login-container { height: 100vh; display: flex; justify-content: center; align-items: center; background: #f5f5f5; } // Main app layout main { display: grid; grid-template-areas: "nav header header" "nav section aside" "nav footer footer"; grid-template-columns: 300px 1fr 300px; grid-template-rows: 100px 1fr 80px; height: 100vh; gap: 8px; padding: 8px; background: #f0f0f0; } nav { grid-area: nav; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); a { display: block; padding: 0.75rem 1rem; text-decoration: none; color: #333; border-radius: 4px; margin-bottom: 0.5rem; &:hover { background: #f5f5f5; } &.active { background: #007bff; color: white; } } } header { grid-area: header; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } section { grid-area: section; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: auto; } aside { grid-area: aside; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } footer { grid-area: footer; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
+-- .editorconfig
+-- .gitignore
+-- .npmrc
+-- Figure37.png
+-- README.md
+-- Snyder 1994 Map_Projections_a_Working_Manual.pdf
+-- angular.json
+-- clean.ps1
+-- clean2.ps1
+-- create_projection_structure.bat
+-- error.txt
+-- package-lock.json
+-- package.json
+-- summary.bat
+-- tag.py
+-- tree-content.py
+-- tree.20241228065529.txt
+-- tsconfig.app.json
+-- tsconfig.json
\-- tsconfig.spec.json
