+-- .vscode
|   +-- extensions.json
|   +-- launch.json
|   \-- tasks.json
+-- src
|   +-- app
|   |   +-- components
|   |   |   +-- admin
|   |   |   |   +-- permissions
|   |   |   |   +-- role-detail
|   |   |   |   |   +-- role-detail.component.html: <!-- src/app/components/admin/role-detail/role-detail.component.html --> <div class="form-container"> <div class="form-card"> <h2>Edit Role</h2> <form (ngSubmit)="onSubmit()" #roleForm="ngForm"> <div class="form-group"> <label for="roleName">Role Name</label> <input type="text" id="roleName" name="roleName" [(ngModel)]="role.roleName" class="form-control" required > </div> <div class="form-group"> <label for="roleDescription">Description</label> <textarea id="roleDescription" name="roleDescription" [(ngModel)]="role.roleDescription" class="form-control" rows="3" required ></textarea> </div> <div class="metadata-section"> <div class="metadata-item"> <label>Created By:</label> <span>{{ role.createdBy }}</span> </div> <div class="metadata-item"> <label>Created Date:</label> <span>{{ role.createDate | date:'short' }}</span> </div> <div class="metadata-item"> <label>Updated By:</label> <span>{{ role.updatedBy }}</span> </div> <div class="metadata-item"> <label>Updated Date:</label> <span>{{ role.updateDate | date:'short' }}</span> </div> </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="!roleForm.form.valid">Save Changes</button> </div> </form> </div> </div>
|   |   |   |   |   +-- role-detail.component.scss: // src/app/components/admin/role-detail/role-detail.component.scss .form-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .form-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } } .metadata-section { background-color: #f8f9fa; padding: 1rem; border-radius: 4px; margin: 1.5rem 0; } .metadata-item { display: flex; margin-bottom: 0.5rem; label { font-weight: 500; width: 120px; color: #555; } span { color: #666; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } }
|   |   |   |   |   \-- role-detail.component.ts: // src/app/components/admin/role-detail/role-detail.component.ts import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, Router } from '@angular/router'; @Component({ selector: 'app-role-detail', templateUrl: './role-detail.component.html', styleUrls: ['./role-detail.component.scss'] }) export class RoleDetailComponent implements OnInit { roleId: number; role: any = { roleName: '', roleDescription: '' }; constructor( private route: ActivatedRoute, private router: Router ) { this.roleId = Number(this.route.snapshot.paramMap.get('id')); } ngOnInit(): void { // Simulate fetching role data this.role = { roleId: this.roleId, roleName: 'Admin', roleDescription: 'Full system access and management capabilities', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-15'), createdBy: 'system', updatedBy: 'admin' }; } onSubmit(): void { console.log('Saving role:', this.role); this.router.navigate(['/admin/roles']); } onCancel(): void { this.router.navigate(['/admin/roles']); } }
|   |   |   |   +-- roles
|   |   |   |   |   +-- roles.component.html: <!-- src/app/components/admin/roles/roles.component.html --> <div class="table-container"> <div class="table-card"> <h2>Role Management</h2> <table class="data-table"> <thead> <tr> <th *ngFor="let column of displayedColumns"> {{ column | titlecase }} </th> </tr> </thead> <tbody> <tr *ngFor="let role of roles"> <td> <a [routerLink]="['/admin/roles', role.roleId]" class="role-link"> {{ role.roleName }} </a> </td> <td>{{ role.roleDescription }}</td> <td>{{ role.createDate | date:'short' }}</td> <td>{{ role.updateDate | date:'short' }}</td> <td>{{ role.createdBy }}</td> <td>{{ role.updatedBy }}</td> </tr> </tbody> </table> </div> </div>
|   |   |   |   |   +-- roles.component.scss: // src/app/components/admin/roles/roles.component.scss .table-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .table-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1200px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .data-table { width: 100%; border-collapse: collapse; margin-top: 1rem; th, td { padding: 1rem; text-align: left; border-bottom: 1px solid #e0e0e0; } th { background-color: #f5f5f5; font-weight: 500; color: #333; } tr:hover { background-color: #f8f9fa; } } .role-link { color: #007bff; text-decoration: none; &:hover { text-decoration: underline; } }
|   |   |   |   |   \-- roles.component.ts: // src/app/components/admin/roles/roles.component.ts import { Component, OnInit } from '@angular/core'; interface Role { roleId: number; roleName: string; roleDescription: string; createDate: Date; updateDate: Date; createdBy: string; updatedBy: string; } @Component({ selector: 'app-roles', templateUrl: './roles.component.html', styleUrls: ['./roles.component.scss'] }) export class RolesComponent implements OnInit { roles: Role[] = [ { roleId: 1, roleName: 'Admin', roleDescription: 'Full system access and management capabilities', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-15'), createdBy: 'system', updatedBy: 'admin' }, { roleId: 2, roleName: 'User Manager', roleDescription: 'Can manage user accounts and permissions', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-20'), createdBy: 'system', updatedBy: 'admin' }, { roleId: 3, roleName: 'Report Viewer', roleDescription: 'Can view and download system reports', createDate: new Date('2024-01-01'), updateDate: new Date('2024-02-25'), createdBy: 'system', updatedBy: 'admin' } ]; displayedColumns: string[] = [ 'roleName', 'roleDescription', 'createDate', 'updateDate', 'createdBy', 'updatedBy' ]; constructor() {} ngOnInit(): void {} }
|   |   |   |   +-- user-detail
|   |   |   |   |   +-- user-detail.component.html: <!-- src/app/admin/users/user-detail/user-detail.component.html --> <div class="form-container"> <div class="form-card"> <h2>Edit User</h2> <form (ngSubmit)="onSubmit()" #userForm="ngForm"> <div class="form-group"> <label for="username">Username</label> <input type="text" id="username" name="username" [(ngModel)]="user.username" class="form-control" disabled > </div> <div class="form-group"> <label for="firstName">First Name</label> <input type="text" id="firstName" name="firstName" [(ngModel)]="user.firstName" class="form-control" required > </div> <div class="form-group"> <label for="middleInitial">Middle Initial</label> <input type="text" id="middleInitial" name="middleInitial" [(ngModel)]="user.middleInitial" class="form-control" maxlength="1" > </div> <div class="form-group"> <label for="lastName">Last Name</label> <input type="text" id="lastName" name="lastName" [(ngModel)]="user.lastName" class="form-control" required > </div> <div class="form-group"> <label for="status">Status</label> <select id="status" name="status" [(ngModel)]="user.status" class="form-control" required > <option *ngFor="let status of statuses" [value]="status"> {{ status | titlecase }} </option> </select> </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="!userForm.form.valid">Save Changes</button> </div> </form> </div> </div>
|   |   |   |   |   +-- user-detail.component.scss: // src/app/admin/users/user-detail/user-detail.component.scss .form-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .form-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &:disabled { background-color: #e9ecef; cursor: not-allowed; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } }
|   |   |   |   |   \-- user-detail.component.ts: // src/app/admin/users/user-detail/user-detail.component.ts import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, Router } from '@angular/router'; @Component({ selector: 'app-user-detail', templateUrl: './user-detail.component.html', styleUrls: ['./user-detail.component.scss'] }) export class UserDetailComponent implements OnInit { userId: number; user: any = { username: '', firstName: '', middleInitial: '', lastName: '', status: 'silver' }; statuses = ['gold', 'platinum', 'silver']; constructor( private route: ActivatedRoute, private router: Router ) { this.userId = Number(this.route.snapshot.paramMap.get('id')); } ngOnInit(): void { // In real app, fetch user data here // For now, simulate data this.user = { id: this.userId, username: 'jsmith', firstName: 'John', middleInitial: 'A', lastName: 'Smith', status: 'gold', createDate: new Date('2024-01-15'), updateDate: new Date('2024-02-20'), createdBy: 'admin', updatedBy: 'admin' }; } onSubmit(): void { // Save logic would go here console.log('Saving user:', this.user); this.router.navigate(['/admin/users']); } onCancel(): void { this.router.navigate(['/admin/users']); } }
|   |   |   |   \-- users
|   |   |   |       +-- users.component.html: <!-- src/app/admin/users/users.component.html --> <div class="table-container"> <div class="table-card"> <h2>User Management</h2> <table class="data-table"> <thead> <tr> <th *ngFor="let column of displayedColumns"> {{ column | titlecase }} </th> </tr> </thead> <tbody> <tr *ngFor="let user of users"> <td> <a [routerLink]="['/admin/users', user.id]" class="username-link"> {{ user.username }} </a> </td> <td>{{ user.firstName }}</td> <td>{{ user.middleInitial }}</td> <td>{{ user.lastName }}</td> <td> <span class="status-badge" [style.background-color]="getStatusColor(user.status)"> {{ user.status | titlecase }} </span> </td> <td>{{ user.createDate | date:'short' }}</td> <td>{{ user.updateDate | date:'short' }}</td> <td>{{ user.createdBy }}</td> <td>{{ user.updatedBy }}</td> </tr> </tbody> </table> </div> </div>
|   |   |   |       +-- users.component.scss: // src/app/admin/users/users.component.scss .table-container { display: flex; justify-content: center; padding: 2rem; background-color: #f5f5f5; min-height: 100vh; } .table-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1200px; h2 { margin: 0 0 1.5rem; color: #333; font-weight: 500; } } .data-table { width: 100%; border-collapse: collapse; margin-top: 1rem; th, td { padding: 1rem; text-align: left; border-bottom: 1px solid #e0e0e0; } th { background-color: #f5f5f5; font-weight: 500; color: #333; } tr:hover { background-color: #f8f9fa; } } .username-link { color: #007bff; text-decoration: none; &:hover { text-decoration: underline; } } .status-badge { padding: 0.25rem 0.75rem; border-radius: 1rem; font-size: 0.875rem; font-weight: 500; display: inline-block; color: #333; }
|   |   |   |       \-- users.component.ts: // src/app/admin/users/users.component.ts import { Component, OnInit } from '@angular/core'; interface User { id: number; username: string; firstName: string; middleInitial: string; lastName: string; status: 'gold' | 'platinum' | 'silver'; createDate: Date; updateDate: Date; createdBy: string; updatedBy: string; } @Component({ selector: 'app-users', templateUrl: './users.component.html', styleUrls: ['./users.component.scss'] }) export class UsersComponent implements OnInit { users: User[] = [ { id: 1, username: 'jsmith', firstName: 'John', middleInitial: 'A', lastName: 'Smith', status: 'gold', createDate: new Date('2024-01-15'), updateDate: new Date('2024-02-20'), createdBy: 'admin', updatedBy: 'admin' }, { id: 2, username: 'mjohnson', firstName: 'Mary', middleInitial: 'E', lastName: 'Johnson', status: 'platinum', createDate: new Date('2024-01-20'), updateDate: new Date('2024-02-25'), createdBy: 'admin', updatedBy: 'admin' }, { id: 3, username: 'rwilson', firstName: 'Robert', middleInitial: 'J', lastName: 'Wilson', status: 'silver', createDate: new Date('2024-02-01'), updateDate: new Date('2024-02-28'), createdBy: 'admin', updatedBy: 'admin' } ]; displayedColumns: string[] = [ 'username', 'firstName', 'middleInitial', 'lastName', 'status', 'createDate', 'updateDate', 'createdBy', 'updatedBy' ]; constructor() {} ngOnInit(): void {} getStatusColor(status: string): string { switch (status) { case 'gold': return '#FFD700'; case 'platinum': return '#E5E4E2'; case 'silver': return '#C0C0C0'; default: return '#FFFFFF'; } } }
|   |   |   +-- airport-table
|   |   |   |   +-- airport-table.component.html: <div> <!-- Add Row Button at the top of the table --> <button mat-icon-button (click)="toggleNewEntryRow()" aria-label="Add row" class="icon-blue"> <mat-icon>add</mat-icon> </button> </div> <div class="table-container"> <table mat-table [dataSource]="dataSource" class="mat-elevation-z8"> <!-- New entry row at the top --> <tr *ngIf="isAddingNewEntry"> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Code" [(ngModel)]="newEntry.code"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Region" [(ngModel)]="newEntry.region" type="number"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Name" [(ngModel)]="newEntry.name"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="City" [(ngModel)]="newEntry.city"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Country" [(ngModel)]="newEntry.country"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Latitude" [(ngModel)]="newEntry.lat" type="number"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Longitude" [(ngModel)]="newEntry.lon" type="number"> </td> <td> <!-- Icons for save and cancel actions --> <mat-icon (click)="addInlineEntry()" color="primary" class="icon-blue">save</mat-icon> <mat-icon (click)="clearNewEntry()" color="primary" class="icon-blue">cancel</mat-icon> </td> </tr> <!-- Column definitions --> <ng-container matColumnDef="code"> <th mat-header-cell *matHeaderCellDef> Code </th> <td mat-cell *matCellDef="let element"> {{ element?.code }} </td> </ng-container> <ng-container matColumnDef="region"> <th mat-header-cell *matHeaderCellDef> Region </th> <td mat-cell *matCellDef="let element"> {{ element?.region }} </td> </ng-container> <ng-container matColumnDef="name"> <th mat-header-cell *matHeaderCellDef> Name </th> <td mat-cell *matCellDef="let element"> {{ element?.name }} </td> </ng-container> <ng-container matColumnDef="city"> <th mat-header-cell *matHeaderCellDef> City </th> <td mat-cell *matCellDef="let element"> {{ element?.city }} </td> </ng-container> <ng-container matColumnDef="country"> <th mat-header-cell *matHeaderCellDef> Country </th> <td mat-cell *matCellDef="let element"> {{ element?.country }} </td> </ng-container> <ng-container matColumnDef="lat"> <th mat-header-cell *matHeaderCellDef> Latitude </th> <td mat-cell *matCellDef="let element"> {{ element?.lat }} </td> </ng-container> <ng-container matColumnDef="lon"> <th mat-header-cell *matHeaderCellDef> Longitude </th> <td mat-cell *matCellDef="let element"> {{ element?.lon }} </td> </ng-container> <ng-container matColumnDef="actions"> <th mat-header-cell *matHeaderCellDef> Actions </th> <td mat-cell *matCellDef="let element"> <mat-icon (click)="editEntry(element)" color="primary" class="icon-blue">edit</mat-icon> <mat-icon (click)="cancelEdit(element)" color="primary" class="icon-blue">cancel</mat-icon> <mat-icon (click)="saveEntry(element)" color="primary" class="icon-blue">save</mat-icon> </td> </ng-container> <!-- Header and data rows --> <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr> <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> </table> <mat-paginator #paginator [pageSize]="25" [pageSizeOptions]="[5, 10, 25, 100]" [length]="dataSource?.data.length || 0" showFirstLastButtons> </mat-paginator> </div>
|   |   |   |   +-- airport-table.component.scss: .table-container { padding: 1.25rem; background-color: #f9f9f9; border-radius: 0.5rem; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); table { width: 100%; border-collapse: collapse; table-layout: fixed; th, td { padding: 0.75rem 0.5rem; font-size: 0.875rem; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } th { font-weight: 600; background-color: #f0f0f0; } td { border-bottom: 1px solid #e0e0e0; } .code-column { width: 4rem; text-align: center; } .region-column { width: 6rem; text-align: center; } .name-column { width: 12rem; text-align: left; } .city-column { width: 8rem; text-align: left; } .country-column { width: 8rem; text-align: left; } .lat-column { width: 7rem; text-align: right; } .lon-column { width: 7rem; text-align: right; } } button { margin-top: 0.9375rem; } mat-paginator { margin-top: 1.25rem; } } .icon-blue { color: blue; } .new-entry-row { background-color: #f2f2f2; }
|   |   |   |   +-- airport-table.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing'; import { AirportTableComponent } from './airport-table.component'; describe('AirportTableComponent', () => { let component: AirportTableComponent; let fixture: ComponentFixture<AirportTableComponent>; beforeEach(() => { TestBed.configureTestingModule({ declarations: [AirportTableComponent] }); fixture = TestBed.createComponent(AirportTableComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
|   |   |   |   \-- airport-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, OnChanges, SimpleChanges, ViewChild } from '@angular/core'; import { MatTableDataSource } from '@angular/material/table'; import { MatPaginator } from '@angular/material/paginator'; import { AirportData } from '../../interfaces/airport-data.interface'; import { DataService } from '../../services/data.service'; @Component({ selector: 'app-airport-table', templateUrl: './airport-table.component.html', styleUrls: ['./airport-table.component.scss'] }) export class AirportTableComponent implements OnInit, OnChanges { @Input() airportData: AirportData[] = []; @ViewChild(MatPaginator, { static: true }) paginator: MatPaginator; dataSource: MatTableDataSource<AirportData> = new MatTableDataSource<AirportData>(); displayedColumns: string[] = ['code', 'region', 'name', 'city', 'country', 'lat', 'lon', 'actions']; // Control for displaying the new entry row isAddingNewEntry = false; newEntry: AirportData = { code: '', region: 0, name: '', city: '', country: '', lat: null, lon: null }; constructor( private dataService: DataService, private cdr: ChangeDetectorRef ) {} ngOnInit(): void { this.initializeDataSource(); } ngOnChanges(changes: SimpleChanges): void { if (changes['airportData'] && changes['airportData'].currentValue) { this.updateDataSource(); } } toggleNewEntryRow(): void { this.isAddingNewEntry = !this.isAddingNewEntry; this.cdr.markForCheck(); // Mark the component for change detection } addInlineEntry() { if (this.newEntry.code && this.newEntry.name && this.newEntry.city && this.newEntry.country && this.newEntry.lat !== null && this.newEntry.lon !== null) { const data = this.dataSource.data; data.unshift({ ...this.newEntry }); this.dataSource.data = data; this.dataService.setAirport(this.newEntry); this.clearNewEntry(); this.isAddingNewEntry = false; this.cdr.markForCheck(); // Mark the component for change detection } } clearNewEntry() { this.newEntry = { code: '', region: 0, name: '', city: '', country: '', lat: null, lon: null }; this.isAddingNewEntry = false; this.cdr.markForCheck(); // Mark the component for change detection } initializeDataSource(): void { this.dataSource.data = this.airportData; this.dataSource.paginator = this.paginator; } updateDataSource(): void { this.dataSource.data = this.airportData; } }
|   |   |   +-- identity
|   |   |   |   +-- password
|   |   |   |   |   +-- password.component.html: <!-- password.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Reset Password</h2> <!-- Error Messages --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <form (ngSubmit)="onSubmit()" #passwordForm="ngForm" *ngIf="!successMessage"> <div class="form-group"> <label for="email">Email Address</label> <input type="email" id="email" name="email" [(ngModel)]="email" maxlength="256" class="form-control" required placeholder="Enter your email address" email > </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="passwordForm.invalid">Reset Password</button> </div> </form> </div> </div>
|   |   |   |   |   +-- password.component.scss: // password.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &::placeholder { color: #999; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |   |   \-- password.component.ts: // password.component.ts import { Component, ViewChild } from '@angular/core'; import { NgForm } from '@angular/forms'; import { Router } from '@angular/router'; @Component({ selector: 'app-password', templateUrl: './password.component.html', styleUrls: ['./password.component.scss'] }) export class PasswordComponent { @ViewChild('passwordForm') passwordForm!: NgForm; email = ''; errorMessages: string[] = []; successMessage = ''; constructor(private router: Router) {} onSubmit() { this.errorMessages = []; this.successMessage = ''; if (!this.email) { this.errorMessages.push('Email address is required.'); return; } if (!this.isValidEmail(this.email)) { this.errorMessages.push('Please enter a valid email address.'); return; } // Intentionally vague success message for security this.successMessage = 'If an account exists for this email address, you will receive password reset instructions shortly.'; // Redirect to login after 3 seconds setTimeout(() => { this.router.navigate(['/login']); }, 3000); } onCancel() { this.router.navigate(['/login']); } private isValidEmail(email: string): boolean { const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/; return emailRegex.test(email); } }
|   |   |   |   +-- profile
|   |   |   |   |   +-- profile.component.html: <!-- profile.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Create Account</h2> <!-- Error Messages --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <form (ngSubmit)="onSubmit()" #registrationForm="ngForm"> <div class="form-group"> <label for="username">Username</label> <input type="text" id="username" name="username" [(ngModel)]="username" maxlength="32" class="form-control" required placeholder="Choose a username" > </div> <div class="form-group"> <label for="email">Email</label> <input type="email" id="email" name="email" [(ngModel)]="email" maxlength="256" class="form-control" required placeholder="Enter your email address" > </div> <div class="form-group name-group"> <div class="name-field"> <label for="first-name">First Name</label> <input type="text" id="first-name" name="firstName" [(ngModel)]="firstName" maxlength="32" class="form-control" required placeholder="First name" > </div> <div class="name-field middle-initial"> <label for="middle-initial">M.I.</label> <input type="text" id="middle-initial" name="middleInitial" [(ngModel)]="middleInitial" maxlength="1" class="form-control" placeholder="M.I." > </div> <div class="name-field"> <label for="last-name">Last Name</label> <input type="text" id="last-name" name="lastName" [(ngModel)]="lastName" maxlength="32" class="form-control" required placeholder="Last name" > </div> </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="registrationForm.invalid">Create Account</button> </div> </form> </div> </div>
|   |   |   |   |   +-- profile.component.scss: // profile.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .name-group { display: flex; gap: 1rem; .name-field { flex: 1; &.middle-initial { flex: 0 0 80px; } } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &::placeholder { color: #999; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |   |   \-- profile.component.ts: // profile.component.ts import { Component, ViewChild } from '@angular/core'; import { NgForm } from '@angular/forms'; import { Router } from '@angular/router'; @Component({ selector: 'app-profile', templateUrl: './profile.component.html', styleUrls: ['./profile.component.scss'] }) export class ProfileComponent { @ViewChild('registrationForm') registrationForm!: NgForm; username = ''; email = ''; firstName = ''; middleInitial = ''; lastName = ''; errorMessages: string[] = []; successMessage = ''; constructor(private router: Router) {} onSubmit() { this.errorMessages = []; this.successMessage = ''; // Validate fields if (!this.username) { this.errorMessages.push('Username is required.'); } if (!this.email) { this.errorMessages.push('Email is required.'); } if (!this.firstName || !this.lastName) { this.errorMessages.push('First and last name are required.'); } // Simulate username availability check if (this.username.toLowerCase() === 'admin') { this.errorMessages.push('This username is not available. Please choose another.'); return; } // If no errors, proceed with registration if (this.errorMessages.length === 0) { // TODO: Implement actual registration logic here this.successMessage = 'Registration successful! Please check your email for confirmation.'; // Reset form after successful submission setTimeout(() => { this.router.navigate(['/login']); }, 2000); } } onCancel() { this.router.navigate(['/login']); } }
|   |   |   |   \-- username
|   |   |   |       +-- username.component.html: <!-- username.component.html --> <div class="registration-container"> <div class="registration-card"> <h2>Recover Username</h2> <!-- Error Messages --> <div class="alert alert-danger" *ngIf="errorMessages.length > 0"> <ul> <li *ngFor="let error of errorMessages">{{ error }}</li> </ul> </div> <!-- Success Message --> <div class="alert alert-success" *ngIf="successMessage"> {{ successMessage }} </div> <form (ngSubmit)="onSubmit()" #usernameForm="ngForm" *ngIf="!successMessage"> <div class="form-group"> <label for="email">Email Address</label> <input type="email" id="email" name="email" [(ngModel)]="email" maxlength="256" class="form-control" required placeholder="Enter your email address" email > </div> <div class="button-group"> <button type="button" class="btn btn-secondary" (click)="onCancel()">Cancel</button> <button type="submit" class="btn btn-primary" [disabled]="usernameForm.invalid">Recover Username</button> </div> </form> </div> </div>
|   |   |   |       +-- username.component.scss: // username.component.scss .registration-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f5f5f5; padding: 20px; } .registration-card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; h2 { margin: 0 0 1.5rem; color: #333; text-align: center; font-weight: 500; } } .form-group { margin-bottom: 1.5rem; label { display: block; margin-bottom: 0.5rem; color: #555; font-weight: 500; } } .form-control { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s; &:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } &::placeholder { color: #999; } } .button-group { display: flex; gap: 1rem; margin-top: 2rem; } .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; &:disabled { opacity: 0.7; cursor: not-allowed; } } .btn-primary { background-color: #007bff; color: white; &:hover:not(:disabled) { background-color: #0056b3; } } .btn-secondary { background-color: #6c757d; color: white; &:hover:not(:disabled) { background-color: #5a6268; } } .alert { padding: 1rem; margin-bottom: 1rem; border-radius: 4px; ul { margin: 0; padding-left: 1.5rem; } } .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; } .alert-success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
|   |   |   |       \-- username.component.ts: // username.component.ts import { Component, ViewChild } from '@angular/core'; import { NgForm } from '@angular/forms'; import { Router } from '@angular/router'; @Component({ selector: 'app-username', templateUrl: './username.component.html', styleUrls: ['./username.component.scss'] }) export class UsernameComponent { @ViewChild('usernameForm') usernameForm!: NgForm; email = ''; errorMessages: string[] = []; successMessage = ''; constructor(private router: Router) {} onSubmit() { this.errorMessages = []; this.successMessage = ''; if (!this.email) { this.errorMessages.push('Email address is required.'); return; } if (!this.isValidEmail(this.email)) { this.errorMessages.push('Please enter a valid email address.'); return; } // Success message intentionally vague for security this.successMessage = 'If an account exists for this email address, you will receive your username recovery instructions shortly.'; // Redirect to login after 3 seconds setTimeout(() => { this.router.navigate(['/login']); }, 3000); } onCancel() { this.router.navigate(['/login']); } private isValidEmail(email: string): boolean { const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/; return emailRegex.test(email); } }
|   |   |   +-- layout
|   |   |   |   +-- main-layout.component.html: <main> <nav> <ul> <li><a routerLink="/map">Map</a></li> <li><a routerLink="/map">Satellite</a></li> <li><a routerLink="/map">Satellite 2</a></li> <li><a routerLink="/admin/users">Users</a></li> <li><a routerLink="/admin/roles">Roles</a></li> <li><a (click)="logout()">Logout</a></li> </ul> </nav> <header> <h1>GeoView Navigation</h1> </header> <section> <router-outlet></router-outlet> </section> <aside></aside> <footer></footer> </main>
|   |   |   |   +-- main-layout.component.scss: :host { display: block; height: 100vh; } main { display: grid; grid-template-areas: "nav header header" "nav section aside" "nav footer footer"; grid-template-columns: 300px 1fr 300px; grid-template-rows: 100px 1fr 80px; height: 100%; gap: 8px; padding: 8px; background: #f0f0f0; } nav { grid-area: nav; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); a { display: block; padding: 0.75rem 1rem; text-decoration: none; color: #333; border-radius: 4px; margin-bottom: 0.5rem; cursor: pointer; &:hover { background: #f5f5f5; } &.active { background: #007bff; color: white; } } } header { grid-area: header; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } section { grid-area: section; background: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); overflow: auto; } aside { grid-area: aside; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } footer { grid-area: footer; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
|   |   |   |   \-- main-layout.component.ts: // main-layout.component.ts import { Component } from '@angular/core'; import { AuthService } from '../../services/auth.service'; @Component({ selector: 'app-main-layout', templateUrl: './main-layout.component.html', styleUrls: ['./main-layout.component.scss'] }) export class MainLayoutComponent { constructor(private authService: AuthService) {} logout() { this.authService.logout(); } }
|   |   |   +-- login
|   |   |   |   +-- login.component.html: <div class="login-container"> <div class="login-card"> <h2>GeoView Login</h2> <div *ngIf="errorMessage" class="error-message"> <span class="material-icons error-icon">error_outline</span> {{ errorMessage }} </div> <form class="login-form" (ngSubmit)="onSubmit()"> <div class="form-field"> <label for="username">Username:</label> <input type="text" id="username" [(ngModel)]="username" name="username" placeholder="Enter username"> </div> <div class="form-field"> <label for="password">Password:</label> <input type="password" id="password" [(ngModel)]="password" name="password" placeholder="Enter password"> </div> <button type="submit" class="login-button">Login</button> </form> <div class="extra-links"> <a routerLink="/identity/username">Forgot Username?</a> <a routerLink="/identity/password">Forgot Password?</a> </div> </div> <!-- Registration Form --> <div class="login-card"> <h2>New Here?</h2> <p>Don't have an account? Register now to get started!</p> <button class="login-button" routerLink="/identity/profile">Register</button> </div> </div>
|   |   |   |   +-- login.component.scss: .login-container { display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f5f5f5; } .login-card { display: flex; /* Enable flex for the column layout */ flex-direction: column; /* Arrange children in a column */ align-items: stretch; /* Make children align to the container's width */ background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 400px; gap: 1rem; /* Add consistent spacing between elements */ } h2 { margin: 0; color: #333; text-align: center; } .error-message { display: flex; align-items: center; gap: 0.5rem; /* Space between icon and text */ background-color: #f8d7da; /* Light red for error messages */ color: #721c24; padding: 0.75rem; border-radius: 4px; } .error-icon { font-size: 24px; /* Icon size */ } .login-form { display: flex; flex-direction: column; /* Stack form fields */ gap: 1rem; /* Add spacing between fields */ } .form-field label { margin-bottom: 0.25rem; color: #555; font-weight: 500; } .form-field input { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; } input:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1); } .login-button { padding: 0.75rem; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; } .login-button:hover { background: #0056b3; } .extra-links { display: flex; justify-content: space-between; font-size: 0.9rem; a { color: #007bff; text-decoration: none; &:hover { text-decoration: underline; } } }
|   |   |   |   \-- login.component.ts: // src/app/components/login/login.component.ts import { Component } from '@angular/core'; import { AuthService } from '../../services/auth.service'; @Component({ selector: 'app-login', templateUrl: './login.component.html', styleUrls: ['./login.component.scss'] }) export class LoginComponent { username: string = 'admin'; password: string = 'admin'; errorMessage: string = ''; // To store the error message constructor(private authService: AuthService) {} onSubmit() { // Simulate login validation if (this.username !== 'admin' || this.password !== 'admin') { this.errorMessage = 'Username and/or password is not correct.'; // Set error message this.username = ''; // Clear username this.password = ''; // Clear password } else { this.errorMessage = ''; // Clear error message if login is successful this.authService.login(this.username, this.password); } } }
|   |   |   +-- map
|   |   |   |   +-- globe-drag-handler.ts: import { throttle, DebouncedFunc } from 'lodash'; import * as d3 from 'd3'; export class GlobeDragHandler { private v0: [number, number, number]; // Mouse position at drag start private r0: [number, number, number]; // Projection rotation at drag start private readonly throttledUpdate: DebouncedFunc<() => void>; constructor( private projection: d3.GeoProjection, private updateCallback: () => void, private throttleTime: number = 16 // ~60fps default ) { this.throttledUpdate = throttle(() => { this.updateCallback(); }, this.throttleTime); // Bind methods to ensure correct 'this' context this.dragStarted = this.dragStarted.bind(this); this.dragged = this.dragged.bind(this); this.dragEnded = this.dragEnded.bind(this); } public dragStarted(event: d3.D3DragEvent<any, any, any>): void { const point = d3.pointer(event, event.sourceEvent.currentTarget); this.v0 = [point[0], point[1], 0]; this.r0 = this.projection.rotate(); } public dragged(event: d3.D3DragEvent<any, any, any>): void { if (!this.v0 || !this.r0) return; const point = d3.pointer(event, event.sourceEvent.currentTarget); const sensitivity = 0.25; const xChange = (point[0] - this.v0[0]) * sensitivity; const yChange = (point[1] - this.v0[1]) * sensitivity; // Update projection rotation this.projection.rotate([ this.r0[0] + xChange, this.r0[1] - yChange, this.r0[2] ]); // Use throttled update this.throttledUpdate(); } public dragEnded(): void { this.v0 = undefined; this.r0 = undefined; // Force a final update to ensure we render the final position if (this.throttledUpdate.flush) { this.throttledUpdate.flush(); } } public destroy(): void { if (this.throttledUpdate.cancel) { this.throttledUpdate.cancel(); } } public attachDragBehavior(selection: d3.Selection<any, unknown, null, undefined>): void { const dragBehavior = d3.drag<any, unknown>() .on('start', this.dragStarted) .on('drag', this.dragged) .on('end', this.dragEnded); selection.call(dragBehavior); } }
|   |   |   |   +-- globe-keyboard-handler.ts: export class GlobeKeyboardHandler { constructor( private projection: d3.GeoProjection, private updateCallback: () => void, private zoomCallback: (zoomFactor: number) => void, // New callback for zoom private incrementStep: number = 5 // Degree increment for rotation adjustments ) { this.handleKeydown = this.handleKeydown.bind(this); window.addEventListener('keydown', this.handleKeydown, { passive: false }); } private handleKeydown(event: KeyboardEvent): void { event.preventDefault(); // Prevent default browser behavior for keys const currentRotation = this.projection.rotate(); let [yaw, pitch, roll] = currentRotation; switch (event.key.toUpperCase()) { // Ensure case-insensitivity case 'W': pitch = Math.min(pitch + this.incrementStep, 90); break; case 'S': pitch = Math.max(pitch - this.incrementStep, -90); break; case 'A': yaw = (yaw - this.incrementStep + 360) % 360; break; case 'D': yaw = (yaw + this.incrementStep) % 360; break; case 'Q': roll = (roll - this.incrementStep + 360) % 360; break; case 'E': roll = (roll + this.incrementStep) % 360; break; case 'R': // Reset rotation to default (0, 0, 0) yaw = 0; pitch = 0; roll = 0; break; case '+': // Zoom in this.zoomCallback(1.1); // Increase zoom factor return; case '-': // Zoom out this.zoomCallback(0.9); // Decrease zoom factor return; default: return; // Ignore other keys } this.projection.rotate([yaw, pitch, roll]); this.updateCallback(); } public removeEventListener(): void { window.removeEventListener('keydown', this.handleKeydown); } }
|   |   |   |   +-- map.component.backup
|   |   |   |   +-- map.component.html: <!-- map.component.html --> <div #mapContainer class="map-container"> <!-- The map will be appended here by D3 --> </div>
|   |   |   |   +-- map.component.scss: :host { display: block; width: 100%; height: 100%; } .map-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; } svg { width: 100%; height: 100%; display: block; }
|   |   |   |   +-- map.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild } from '@angular/core'; import * as d3 from 'd3'; import * as d3Geo from 'd3-geo'; import { Feature, FeatureCollection, Geometry, GeometryObject } from 'geojson'; import { Subscription } from 'rxjs'; import { ProjectionType } from '../../enums/projection-type.enum'; import { MatTableDataSource } from '@angular/material/table'; import { DataService } from '../../services/data.service'; import { throttle } from 'lodash'; import { GlobeDragHandler } from "./globe-drag-handler"; import { GlobeKeyboardHandler } from './globe-keyboard-handler'; @Component({ selector: 'app-map', templateUrl: './map.component.html', styleUrls: ['./map.component.scss'] }) export class MapComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('mapContainer', { static: true }) mapContainer: ElementRef; private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>; private gSphere: d3.Selection<SVGGElement, unknown, null, undefined>; private gGraticule: d3.Selection<SVGGElement, unknown, null, undefined>; private gCountries: d3.Selection<SVGGElement, unknown, null, undefined>; private gRoutes: d3.Selection<SVGGElement, unknown, null, undefined>; private gAirports: d3.Selection<SVGGElement, unknown, null, undefined>; private projection: d3.GeoProjection; private path: d3.GeoPath; private resizeObserver: ResizeObserver; private subscription: Subscription; private zoom: d3.ZoomBehavior<Element, unknown>; private projectionType: ProjectionType = ProjectionType.Orthographic; private dragHandler: GlobeDragHandler; private currentZoomScale: number = 1; private renderedAirports: Set<string> = new Set(); private keyboardHandler: GlobeKeyboardHandler; constructor(private dataService: DataService) { } ngOnInit(): void { //console.log('MapComponent ngOnInit called.'); this.initMap(); this.subscription = this.dataService.getSelectedFeatures().subscribe(features => { //console.log('MapComponent received updated features:', features); this.updateMapSelection(features); this.updateLayers(); }); } ngAfterViewInit(): void { //console.log('MapComponent ngAfterViewInit called. Ready for interaction.'); this.resizeObserver = new ResizeObserver(() => this.resizeMap()); this.resizeObserver.observe(this.mapContainer.nativeElement); } // Add a method to handle zoom changes private applyZoomChange(zoomFactor: number): void { this.zoom.scaleBy(this.svg, zoomFactor); } private updateMap(): void { //console.log('Updating the map based on new rotations or changes.'); // Re-render or refresh any D3 map layers as necessary this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } private setupSVG(): void { //console.log('Setting up SVG elements.'); const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; // Clear any existing SVG d3.select(this.mapContainer.nativeElement).selectAll('svg').remove(); this.svg = d3.select(this.mapContainer.nativeElement).append('svg') .attr('width', width) .attr('height', height) .attr('viewBox', `0 0 ${width} ${height}`) .attr('preserveAspectRatio', 'xMidYMid meet'); // Add external stylesheet reference this.svg.append('defs') .append('link') .attr('href', 'assets/styles/map.svg.css') .attr('type', 'text/css') .attr('rel', 'stylesheet'); // Create groups in correct order (bottom to top) this.gSphere = this.svg.append('g').attr('class', 'sphere-layer'); this.gGraticule = this.svg.append('g').attr('class', 'graticule-layer'); this.gCountries = this.svg.append('g').attr('class', 'countries-layer'); this.gRoutes = this.svg.append('g').attr('class', 'routes-layer'); this.gAirports = this.svg.append('g').attr('class', 'airports-layer'); } private initMap(): void { //console.log('Initializing map.'); this.setupSVG(); this.setProjection(this.projectionType); this.path = d3.geoPath().projection(this.projection); // Add the base sphere with subtle color this.gSphere.append('path') .datum({ type: 'Sphere' }) .attr('class', 'sphere') .attr('d', this.path); // Add graticule const graticule = d3.geoGraticule(); this.gGraticule.append('path') .datum(graticule) .attr('class', 'graticule') .attr('d', this.path) // Now add other layers this.updateLayers(); this.applyZoom(); this.resizeMap(); } private setProjection(type: ProjectionType): void { //console.log('Setting projection:', type); const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; this.projection = d3.geoOrthographic() .scale(Math.min(width, height) / 2.5) .translate([width / 2, height / 2]) .center([0, 0]) .rotate([74, -30, 0]) .clipAngle(90); this.path = d3.geoPath().projection(this.projection); } private updateLayers(): void { //console.log('Updating layers on the map.'); const layerNames = this.dataService.getLayerNames(); layerNames.forEach(layerName => { //console.log(`Processing layer: ${layerName}`); const layer = this.dataService.getLayer(layerName); if (layer && layer.getFeatures()) { if (layerName === 'countries') { this.updateCountriesLayer(layer.getFeatures()); } else if (layerName === 'routes' || layerName.toUpperCase() === 'PA') { this.updateRoutesLayer(layerName, layer.getFeatures()); this.updateAirportsForRoutes(layer.getFeatures()); } } }); } private updateCountriesLayer(features: Feature[]): void { this.gCountries.selectAll('path') .data(features) .join( enter => enter.append('path') .attr('class', (d: Feature) => `${d.geometry.type.toLowerCase()} country`) .attr('d', this.path) .style('fill', '#cccccc') .style('stroke', '#666666') .style('stroke-width', '0.5px'), update => update.attr('d', this.path), exit => exit.remove() ); } private updateRoutesLayer(layerName: string, features: Feature[]): void { this.gRoutes.selectAll(`path.${layerName}`) .data(features, (d: Feature) => d.id) .join( enter => enter.append('path') .attr('class', (d: Feature) => `${d.geometry.type.toLowerCase()} ${layerName}`) .attr('d', this.path) .on('click', (event: MouseEvent, feature: Feature<Geometry, { [name: string]: any }>) => this.selectFeature(event, feature) ) .style('cursor', 'pointer'), update => update.attr('d', this.path), exit => exit.remove() ); } private updateAirportsForRoutes(features: Feature[]): void { const airportsToAdd = new Set<string>(); // Collect all unique airports from the features features.forEach((feature: any) => { if (feature.properties && feature.properties.base && feature.properties.ref) { airportsToAdd.add(feature.properties.base); airportsToAdd.add(feature.properties.ref); } }); // Only add airports that haven't been rendered yet airportsToAdd.forEach(airportCode => { if (!this.renderedAirports.has(airportCode)) { this.addAirport(airportCode); this.renderedAirports.add(airportCode); } }); } private addAirport(airportCode: string): void { const airport = this.dataService.getAirport(airportCode); if (!airport) return; const lon = Number(airport.lon); const lat = Number(airport.lat); if (isNaN(lon) || isNaN(lat)) return; const coords: [number, number] = [lon, lat]; const projectedCoords = this.projection(coords as [number, number]); if (!projectedCoords || isNaN(projectedCoords[0]) || isNaN(projectedCoords[1])) return; // Add airport circle this.gAirports.append('circle') .attr('class', 'airport-circle') .attr('cx', projectedCoords[0]) .attr('cy', projectedCoords[1]) .attr('r', 1) .style('fill', '#add8e6') .style('stroke', 'blue') .style('stroke-width', '2px') .attr('data-airport', airportCode) .attr('vector-effect', 'non-scaling-stroke'); // Add single text label with consistent styling this.gAirports.append('text') .attr('class', 'airport-label') .attr('x', projectedCoords[0] + 7) .attr('y', projectedCoords[1] + 3) .text(airportCode) .style('font-size', '12px') .style('fill', 'blue') .style('stroke', 'none') .attr('data-airport', airportCode) .attr('vector-effect', 'non-scaling-stroke'); } private updateAirportPositions(): void { const zoomScale = this.currentZoomScale ? 1 / this.currentZoomScale : 1; this.gAirports.selectAll('.airport-circle, .airport-label').each((d: any, i, nodes) => { const element = d3.select(nodes[i]); const airportCode = element.attr('data-airport'); const airport = this.dataService.getAirport(airportCode); if (airport) { const coords: [number, number] = [Number(airport.lon), Number(airport.lat)]; const visible = d3.geoDistance(coords, [-this.projection.rotate()[0], -this.projection.rotate()[1]] as [number, number]) < Math.PI / 2; if (visible) { const projectedCoords = this.projection(coords as [number, number]); if (projectedCoords && !isNaN(projectedCoords[0]) && !isNaN(projectedCoords[1])) { if (element.classed('airport-circle')) { element .attr('cx', projectedCoords[0]) .attr('cy', projectedCoords[1]) .attr('r', 5 * zoomScale) .style('display', 'block'); } else { element .attr('x', projectedCoords[0] + 7 * zoomScale) .attr('y', projectedCoords[1] + 3 * zoomScale) .style('font-size', `${12 * zoomScale}px`) .style('display', 'block'); } } } else { element.style('display', 'none'); } } }); this.svg.selectAll('.airport-geometry').attr('vector-effect', 'non-scaling-stroke'); } public resizeMap(): void { //console.log('Resizing map.'); if (this.mapContainer && this.svg) { const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; this.svg .attr('width', width) .attr('height', height) .attr('viewBox', `0 0 ${width} ${height}`); this.projection .scale(Math.min(width, height) / 2.5) .translate([width / 2, height / 2]); // Update all paths and positions this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } } private selectFeature(event: MouseEvent, feature: Feature): void { console.log('Selecting feature:', feature); if (feature.id) { this.dataService.setSelectedFeatures([feature]); console.log('Selected feature set in DataModel:', feature.id); } else { console.error('Feature ID is undefined, cannot select'); } } private updateMapSelection(features: Feature[] | null): void { this.gRoutes.selectAll('.selected').classed('selected', false); if (features && features.length) { features.forEach(feature => { if (feature.id) { this.gRoutes.selectAll('path') .filter((d: any) => d.id === feature.id) .classed('selected', true) .raise(); } }); } } private applyZoom(): void { //console.log('Applying zoom behavior to the map.'); this.dragHandler = new GlobeDragHandler( this.projection, () => { this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } ); this.dragHandler.attachDragBehavior(this.gSphere.select('.sphere')); //this.dragHandler.attachDragBehavior(this.gSphere.select('*')); this.zoom = d3.zoom() .scaleExtent([1, 32]) .on('zoom', (event) => { const { transform } = event; const scaleTransformString = `translate(${transform.x}, ${transform.y}) scale(${transform.k})`; this.gSphere.attr('transform', scaleTransformString); this.gGraticule.attr('transform', scaleTransformString); this.gCountries.attr('transform', scaleTransformString); this.gRoutes.attr('transform', scaleTransformString); this.gAirports.attr('transform', scaleTransformString); this.svg.selectAll('path').attr('vector-effect', 'non-scaling-stroke'); this.currentZoomScale = event.transform.k; this.updateAirportPositions(); }); this.svg.call(this.zoom); } ngOnDestroy(): void { if (this.resizeObserver) this.resizeObserver.disconnect(); if (this.subscription) this.subscription.unsubscribe(); if (this.dragHandler) this.dragHandler.destroy(); if (this.keyboardHandler) this.keyboardHandler.removeEventListener(); // Access property here } }
|   |   |   |   \-- versor.ts: /** * versor.ts * A comprehensive utility class for handling 3D rotations using quaternions and versors. * Implements smooth interpolation and transformation between different rotation representations. */ export class Versor { /** * Converts degrees to radians */ static toRadians(degrees: number): number { return degrees * Math.PI / 180; } /** * Converts radians to degrees */ static toDegrees(radians: number): number { return radians * 180 / Math.PI; } /** * Converts latitude and longitude to 3D Cartesian coordinates on a unit sphere */ static cartesian(lambda: number, phi: number): [number, number, number] { lambda = this.toRadians(lambda); phi = this.toRadians(phi); const cosPhi = Math.cos(phi); return [ cosPhi * Math.cos(lambda), cosPhi * Math.sin(lambda), Math.sin(phi) ]; } /** * Converts 3D Cartesian coordinates to [longitude, latitude] in degrees */ static spherical(cartesian: [number, number, number]): [number, number] { const [x, y, z] = cartesian; return [ this.toDegrees(Math.atan2(y, x)), this.toDegrees(Math.asin(Math.max(-1, Math.min(1, z)))) ]; } /** * Calculates the dot product of two vectors */ static dot(a: number[], b: number[]): number { if (a.length !== b.length) { throw new Error('Vectors must have the same length'); } return Math.max(-1, Math.min(1, a.reduce((sum, _, i) => sum + a[i] * b[i], 0))); } /** * Calculates the cross product of two 3D vectors */ static cross(a: [number, number, number], b: [number, number, number]): [number, number, number] { return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; } /** * Normalizes a vector to unit length */ static normalize(v: number[]): number[] { const length = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0)); if (length === 0) { throw new Error('Cannot normalize zero-length vector'); } return v.map(x => x / length); } /** * Creates a quaternion that rotates vector v0 to align with vector v1 */ static quaternion(v0: [number, number, number], v1: [number, number, number]): [number, number, number, number] { if (!v0 || !v1) { throw new Error('Both vectors are required'); } // Normalize input vectors const normalized0 = this.normalize(v0) as [number, number, number]; const normalized1 = this.normalize(v1) as [number, number, number]; const dot = this.dot(normalized0, normalized1); // If vectors are parallel, return identity quaternion if (dot >= 0.999999) { return [1, 0, 0, 0]; } // If vectors are anti-parallel, rotate 180° around any perpendicular axis if (dot <= -0.999999) { const axis = Math.abs(normalized0[0]) < 0.1 ? this.cross(normalized0, [1, 0, 0]) : this.cross(normalized0, [0, 1, 0]); const normalizedAxis = this.normalize(axis); return [0, ...normalizedAxis] as [number, number, number, number]; } const w = this.cross(normalized0, normalized1); const theta = Math.acos(dot); const wlen = Math.sqrt(w.reduce((sum, x) => sum + x * x, 0)); if (wlen < 1e-10) { return [1, 0, 0, 0]; } const sinHalfTheta = Math.sin(theta / 2); return [ Math.cos(theta / 2), (w[0] / wlen) * sinHalfTheta, (w[1] / wlen) * sinHalfTheta, (w[2] / wlen) * sinHalfTheta ]; } /** * Multiplies two quaternions */ static multiply(a: [number, number, number, number], b: [number, number, number, number]): [number, number, number, number] { return [ a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3], a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2], a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1], a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0] ]; } /** * Converts a quaternion to a rotation matrix */ static quaternionToMatrix(q: [number, number, number, number]): number[] { const [w, x, y, z] = this.normalize(q) as [number, number, number, number]; const xx = x * x, yy = y * y, zz = z * z; const xy = x * y, xz = x * z, yz = y * z; const wx = w * x, wy = w * y, wz = w * z; return [ 1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy), 2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx), 2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy) ]; } /** * Converts a rotation matrix to Euler angles [phi, theta, psi] in degrees */ static matrixToEuler(matrix: number[]): [number, number, number] { const [m11, m12, m13, m21, m22, m23, m31, m32, m33] = matrix; let phi: number, theta: number, psi: number; if (Math.abs(m31) !== 1) { theta = -Math.asin(Math.max(-1, Math.min(1, m31))); const cosTheta = Math.cos(theta); phi = Math.atan2(m32 / cosTheta, m33 / cosTheta); psi = Math.atan2(m21 / cosTheta, m11 / cosTheta); } else { // Gimbal lock case phi = 0; if (m31 === -1) { theta = Math.PI / 2; psi = phi + Math.atan2(m12, m13); } else { theta = -Math.PI / 2; psi = -phi + Math.atan2(-m12, -m13); } } return [ this.toDegrees(phi), this.toDegrees(theta), this.toDegrees(psi) ]; } /** * Creates a quaternion from Euler angles [phi, theta, psi] in degrees */ static eulerToQuaternion(euler: [number, number, number]): [number, number, number, number] { const [phi, theta, psi] = euler.map(this.toRadians); const c1 = Math.cos(phi / 2); const c2 = Math.cos(theta / 2); const c3 = Math.cos(psi / 2); const s1 = Math.sin(phi / 2); const s2 = Math.sin(theta / 2); const s3 = Math.sin(psi / 2); return [ c1 * c2 * c3 + s1 * s2 * s3, s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3 ]; } /** * Interpolates between two quaternions using spherical linear interpolation (slerp) */ static slerp(q1: [number, number, number, number], q2: [number, number, number, number], t: number): [number, number, number, number] { // Normalize quaternions const n1 = this.normalize(q1) as [number, number, number, number]; const n2 = this.normalize(q2) as [number, number, number, number]; // Calculate cosine of angle between quaternions let dot = this.dot(n1, n2); // If quaternions are very close, use linear interpolation if (Math.abs(dot) > 0.9995) { const result = n1.map((x, i) => x + t * (n2[i] - x)); return this.normalize(result) as [number, number, number, number]; } // Ensure shortest path if (dot < 0) { n2.forEach((_, i) => n2[i] = -n2[i]); dot = -dot; } // Clamp dot product to valid range dot = Math.max(-1, Math.min(1, dot)); const theta0 = Math.acos(dot); const theta = theta0 * t; const sinTheta = Math.sin(theta); const sinTheta0 = Math.sin(theta0); const s1 = Math.cos(theta) - dot * sinTheta / sinTheta0; const s2 = sinTheta / sinTheta0; return [ s1 * n1[0] + s2 * n2[0], s1 * n1[1] + s2 * n2[1], s1 * n1[2] + s2 * n2[2], s1 * n1[3] + s2 * n2[3] ]; } /** * Converts a rotation in [longitude, latitude, rotation] format to a quaternion */ static rotationToQuaternion(rotation: [number, number, number]): [number, number, number, number] { const [lambda, phi, gamma] = rotation.map(this.toRadians); const cLambda = Math.cos(lambda / 2); const sLambda = Math.sin(lambda / 2); const cPhi = Math.cos(phi / 2); const sPhi = Math.sin(phi / 2); const cGamma = Math.cos(gamma / 2); const sGamma = Math.sin(gamma / 2); return [ cLambda * cPhi * cGamma - sLambda * sPhi * sGamma, sLambda * cPhi * cGamma + cLambda * sPhi * sGamma, cLambda * sPhi * cGamma - sLambda * cPhi * sGamma, cLambda * cPhi * sGamma + sLambda * sPhi * cGamma ]; } /** * Converts a quaternion to [longitude, latitude, rotation] in degrees */ static quaternionToRotation(q: [number, number, number, number]): [number, number, number] { const normalized = this.normalize(q) as [number, number, number, number]; const [w, x, y, z] = normalized; const sinPhi = 2 * (w * y - z * x); let phi = Math.asin(Math.max(-1, Math.min(1, sinPhi))); const lambda = Math.atan2( 2 * (w * x + y * z), 1 - 2 * (x * x + y * y) ); const gamma = Math.atan2( 2 * (w * z + x * y), 1 - 2 * (y * y + z * z) ); return [ this.toDegrees(lambda), this.toDegrees(phi), this.toDegrees(gamma) ]; } }
|   |   |   +-- map-view
|   |   |   |   +-- map-view.component.html: <div *ngIf="isLoading" class="loading-container"> <img src="assets/spinner.gif" alt="Loading..." /> </div> <div *ngIf="!isLoading" class="map-view-container"> <app-double-pane> <app-pane class="left-panel"> <app-map #map></app-map> </app-pane> <app-pane class="right-panel"> <ixt-tabset title="Employee Form"> <ixt-tab title="City Pairs"> <app-table></app-table> </ixt-tab> <ixt-tab title="City Editor"> <ixt-table [data]="airportData" [config]="tableConfig"> </ixt-table> </ixt-tab> <ixt-tab title="Style Editor"> <h1></h1> <style-editor></style-editor> </ixt-tab> </ixt-tabset> </app-pane> </app-double-pane> </div>
|   |   |   |   +-- map-view.component.scss: :host { display: block; height: 100%; width: 100%; } .map-view-container { height: 100%; width: 100%; display: flex; flex-direction: column; } app-double-pane { flex: 1; min-height: 0; // Important for flex child scrolling } .left-panel, .right-panel { height: 100%; overflow: hidden; } .left-panel { app-map { height: 100%; width: 100%; display: block; } }
|   |   |   |   \-- map-view.component.ts: import { AfterViewInit, ChangeDetectorRef, Component, OnInit, ViewChild } from '@angular/core'; import { MatPaginator } from '@angular/material/paginator'; import { MatTableDataSource } from "@angular/material/table"; import { MatIconModule } from '@angular/material/icon'; import { MatTooltipModule } from '@angular/material/tooltip'; import { Feature, LineString, FeatureCollection } from 'geojson'; import { Observable } from 'rxjs'; import * as Papa from 'papaparse'; //import { TableConfig } from '@dvanauken/ixtlan'; import { TableConfig } from '@dvanauken/ixtlan/dist/ixtlan'; import { ITabContent, ITabsetConfig } from '@dvanauken/ixtlan/dist/ixtlan'; import { AirportData } from 'src/app/interfaces/airport-data.interface'; import { DataService } from 'src/app/services/data.service'; import { Resources } from 'src/app/services/resources'; import { Layer } from 'src/app/models/layer'; @Component({ selector: 'map-view', templateUrl: './map-view.component.html', styleUrls: ['./map-view.component.scss'] }) export class MapViewComponent implements OnInit, AfterViewInit { @ViewChild(MatPaginator, { static: false }) paginator: MatPaginator; title = 'Airport and Route Manager'; isLoading = true; displayedColumns: string[] = ['code', 'region', 'name', 'city', 'country', 'lat', 'lon']; //airportData = new MatTableDataSource<AirportData>([]); airportData: AirportData[] = []; countries: Layer | null = null; routes: Layer | null = null; airports: Layer | null = null; selectedFeatures$: Observable<Feature[]>; layers: Layer[] = []; formatCoord = (coord: number) => coord.toFixed(1); tableConfig: TableConfig<AirportData> = { columns: [ { key: 'code', header: 'Code' }, { key: 'name', header: 'Name' }, { key: 'city', header: 'City' }, { key: 'country', header: 'Country' }, { key: 'lat', header: 'Latitude' }, { key: 'lon', header: 'Longitude' } ], selectionMode: 'multiple', allowAdd: false, allowEdit: false, allowDelete: false }; tabConfig: ITabsetConfig = { showNotificationBand: true, notificationText: '🗺️ GeoView Navigation', animationDuration: 300 }; tabs: ITabContent[] = [ { id: 'map', title: 'Map', content: '', active: true }, { id: 'airports', title: 'Airports', content: '', active: false }, { id: 'style', title: 'Style Editor', content: '', active: false } ]; constructor( private cdr: ChangeDetectorRef, private dataService: DataService ) { this.selectedFeatures$ = this.dataService.getSelectedFeatures(); } ngOnInit(): void { (async () => { try { const loadedData = await Resources.load(["assets/Airport.json"]); if (loadedData.length === 0 || !loadedData[0].data) { throw new Error('Invalid airport data structure'); } this.dataService.setAirports(loadedData[0].data); console.log('Airports loaded and set in DataService.'); this.airportData = this.dataService.getAirports(); //this.airportData = new MatTableDataSource<AirportData>(this.dataService.getAirports()); //console.log('Loaded airport data for display:', this.airportData.data); const files = await Resources.load(['assets/110m/countries.geojson', 'assets/routes.json', 'assets/pa.csv']); files.forEach(({ data, path }) => { if (path.endsWith('countries.geojson')) { this.dataService.addLayer('countries', new Layer('FeatureCollection', data.features || data)); console.log("countries.geojson:path=" + path + ", data=" + data.features.length); } else if (path.endsWith('routes.json')) { // Ensure `airports[0].data` contains airport data for lookups //const airportData = airports[0].data; const hubs = ['ATL', 'SLC', 'MSP', 'DTW', 'JFK', 'AUS', 'CVG', 'LAX', 'SEA', 'BOS', 'LGA', 'DCA', 'RDU', 'DFW']; // List of DL hubs // Create GeoJSON features for routes based on base and ref lookups using map and filter const features = data .filter((route: { al: string }) => route.al === 'DL') // Filter for routes with `al: DL` .filter((route: { base: string; ref: string }) => !hubs.includes(route.base) && !hubs.includes(route.ref)) // Exclude routes with hubs as base or ref .map((route: { base: string; ref: string; al: string }) => { // Find the base and ref coordinates from airportData const baseAirport = this.dataService.getAirports().find((airport: any) => airport.code === route.base); const refAirport = this.dataService.getAirports().find((airport: any) => airport.code === route.ref); // Return a feature if both airports are found; otherwise, return null return (baseAirport && refAirport) ? { type: 'Feature', id: `${route.base}-${route.ref}-${route.al}`, // Ensure each feature has a unique ID geometry: { type: 'LineString', coordinates: [ [baseAirport.lon, baseAirport.lat], [refAirport.lon, refAirport.lat] ] }, properties: { id: `${route.base}-${route.ref}-${route.al}`, // Ensure each feature has a unique ID Airline: route.al, base: route.base, ref: route.ref, 'City 1': `${baseAirport.city}`, 'City 2': `${refAirport.city}`, 'Coords 1': [this.formatCoord(baseAirport.lon), this.formatCoord(baseAirport.lat)], 'Coords 2': [this.formatCoord(refAirport.lon), this.formatCoord(refAirport.lat)] }, } : null; }) .filter(feature => feature !== null) as GeoJSON.Feature[]; // Filter out null values this.dataService.addLayer('routes', new Layer("routes", features)); } else if (path.endsWith('pa.csv')) { console.log("pa.csv:path=" + path + ", data=" + data.length); // Print sample data for verification console.log('Filtered data sample:', data.filter(row => row['origin'] && row['destination']).slice(0, 3)); const cityPairSet = new Set(); const features = data .filter(row => row['origin'] && row['destination']) .map(row => { const base = (row['origin'] < row['destination']) ? row['origin'] : row['destination']; const ref = (row['origin'] < row['destination']) ? row['destination'] : row['origin']; // Ensure base and ref are not the same if (base === ref) { return null; } // Create a unique key for the city pair const pairKey = `${base}-${ref}-PA`; // Include airline in uppercase in the key if (cityPairSet.has(pairKey)) { return null; // Skip if the pair already exists } cityPairSet.add(pairKey); // Get the airport data directly from DataService const baseAirport = this.dataService.getAirport(base); const refAirport = this.dataService.getAirport(ref); // Ensure both coordinates are valid if (!baseAirport || !refAirport) { return null; } // const originCoords = ; // const destinationCoords = ; return { type: 'Feature', id: pairKey, // Assign the unique pair key with the airline as the id geometry: { type: 'LineString', coordinates: [[baseAirport.lon, baseAirport.lat], [refAirport.lon, refAirport.lat]] }, properties: { id: pairKey, Airline: 'PA', base: base, ref: ref, 'City 1': baseAirport.city, 'City 2': refAirport.city, 'Coords 1': [this.formatCoord(baseAirport.lon), this.formatCoord(baseAirport.lat)], 'Coords 2': [this.formatCoord(refAirport.lon), this.formatCoord(refAirport.lat)] } }; }) .filter(feature => feature !== null) .sort((a, b) => a.id.localeCompare(b.id)); // Sort features by id in alphabetical order // Print the sorted features for verification console.log('Sorted Features:', features.length); // Optional: Add the features to DataService as a new layer this.dataService.addLayer('PA', new Layer("PA", features)); } }); //console.log('All resource loading completed.'); this.dataService.setSelectedLayer("routes"); this.isLoading = false; } catch (err) { //console.error('An error occurred during loading:', err); this.isLoading = false; } })(); } ngAfterViewInit(): void { // setTimeout(() => { // if (this.paginator) { // //this.airportData.paginator = this.paginator; // this.cdr.detectChanges(); // console.log("Paginator linked successfully"); // } else { // console.warn("Paginator not found"); // } // }); } // onTabChange(event: any): void { // if (event.index === 1) { // Airport tab index // setTimeout(() => { // if (this.paginator) { // //this.airportData.paginator = this.paginator; // this.cdr.detectChanges(); // } // }); // } // } onLayerSelect(layerName: string): void { this.dataService.setSelectedLayer(layerName); } onTabChange(tab: ITabContent): void { if (tab.id === 'airports') { setTimeout(() => { if (this.paginator) { this.cdr.detectChanges(); } }); } } }
|   |   |   +-- pane
|   |   |   |   +-- double-pane
|   |   |   |   |   +-- double-pane.component.html: <div #container class="double-pane-container"> <ng-content select="app-pane.left-panel"></ng-content> <div #divider class="divider" (mousedown)="onMouseDown($event)" [style.left]="dividerPosition"></div> <ng-content select="app-pane.right-panel"></ng-content> </div>
|   |   |   |   |   +-- double-pane.component.scss: :host { display: block; width: 100%; height: 100%; } .double-pane-container { display: flex; /* Flex layout for left and right panels */ width: 100%; /* Full width of the container */ height: 100%; /* Full height of the container */ position: relative; /* For positioning the divider */ } .left-panel { flex: 0 0 50%; /* Start with 50% width, allow resizing */ max-width: 50%; /* Prevent overflow */ display: flex; /* Use flex for centering */ justify-content: center; /* Horizontally center the content */ align-items: center; /* Vertically center the content */ overflow: hidden; /* Prevent overflow scrollbars */ } .right-panel { flex: 1; /* Take up remaining space */ height: 100%; /* Full height for the right pane */ overflow: auto; /* Allow scrolling if necessary */ } .divider { position: absolute; top: 0; bottom: 0; width: 5px; background-color: #ccc; cursor: col-resize; z-index: 10; /* Ensure the divider stays on top */ }
|   |   |   |   |   \-- double-pane.component.ts: import { Component, ElementRef, ViewChild, AfterViewInit, AfterContentInit, ContentChildren, QueryList, OnDestroy, ChangeDetectorRef } from '@angular/core'; import { fromEvent, Subscription } from 'rxjs'; import { throttleTime, takeUntil } from 'rxjs/operators'; import { PaneComponent } from '../pane/pane.component'; import { MapComponent } from '../../map/map.component'; // Correct import @Component({ selector: 'app-double-pane', templateUrl: './double-pane.component.html', styleUrls: ['./double-pane.component.scss'] }) export class DoublePaneComponent implements AfterViewInit, AfterContentInit, OnDestroy { @ViewChild('map', { static: false }) mapComponent!: MapComponent; // Use template reference @ViewChild('divider', { static: true }) divider!: ElementRef; @ViewChild('container', { static: true }) container!: ElementRef; @ContentChildren(PaneComponent) panes!: QueryList<PaneComponent>; isDragging = false; leftPaneWidth = 50; dividerPosition = '50%'; private subscriptions: Subscription = new Subscription(); constructor(private cdr: ChangeDetectorRef) {} ngAfterViewInit(): void { //console.log('ngAfterViewInit: Checking if MapComponent is detected.'); //console.log('MapComponent:', this.mapComponent); this.updatePaneWidths(); } ngAfterContentInit() { //console.log('DoublePaneComponent - ngAfterContentInit'); //console.log('Number of panes:', this.panes.length); } ngOnDestroy(): void { this.subscriptions.unsubscribe(); } onMouseDown(event: MouseEvent): void { event.preventDefault(); this.isDragging = true; const moveSubscription = fromEvent<MouseEvent>(document, 'mousemove').pipe( takeUntil(fromEvent(document, 'mouseup')), throttleTime(16) // Approx. 60fps ).subscribe(e => this.resize(e.clientX)); const upSubscription = fromEvent(document, 'mouseup').subscribe(() => { this.isDragging = false; moveSubscription.unsubscribe(); upSubscription.unsubscribe(); }); this.subscriptions.add(moveSubscription); this.subscriptions.add(upSubscription); } resize(x: number): void { const containerRect = this.container.nativeElement.getBoundingClientRect(); const containerWidth = containerRect.width; const newLeftWidth = ((x - containerRect.left) / containerWidth) * 100; this.leftPaneWidth = Math.max(10, Math.min(90, newLeftWidth)); this.dividerPosition = `${this.leftPaneWidth}%`; this.updatePaneWidths(); } private updatePaneWidths(): void { //console.log('Updating pane widths...'); const paneArray = this.panes.toArray(); //console.log('Pane array:', paneArray); if (paneArray.length === 2) { //console.log(`Setting left pane width to ${this.leftPaneWidth}%`); paneArray[0].setWidth(`${this.leftPaneWidth}%`); //console.log(`Setting right pane width to ${100 - this.leftPaneWidth}%`); paneArray[1].setWidth(`${100 - this.leftPaneWidth}%`); this.cdr.detectChanges(); //console.log('Change detection triggered.'); //// Ensure the map component exists and trigger its resize logic //if (this.mapComponent) { // console.log('Calling resizeMap on the MapComponent instance.'); // this.mapComponent.resizeMap(); //} else { // console.warn('MapComponent instance not found.'); //} } else { console.warn('Expected 2 panes, but found:', paneArray.length); } } }
|   |   |   |   +-- pane
|   |   |   |   |   +-- pane.component.html: <ng-content></ng-content>
|   |   |   |   |   +-- pane.component.scss: :host { display: block; height: 100%; overflow: auto; }
|   |   |   |   |   \-- pane.component.ts: import { Component, ElementRef, Renderer2, ChangeDetectorRef, AfterContentInit } from '@angular/core'; @Component({ selector: 'app-pane', templateUrl: './pane.component.html', styleUrls: ['./pane.component.scss'] }) export class PaneComponent implements AfterContentInit { constructor( public elementRef: ElementRef, private renderer: Renderer2, private cdr: ChangeDetectorRef ) {} ngAfterContentInit() { //console.log('PaneComponent - ngAfterContentInit'); //console.log('Pane content:', this.el.nativeElement.innerHTML); } setWidth(width: string) { //console.log('Setting pane width:', width); this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); this.cdr.detectChanges(); // Force change detection } }
|   |   |   |   \-- pane.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { PaneComponent } from './pane/pane.component'; import { DoublePaneComponent } from './double-pane/double-pane.component'; @NgModule({ declarations: [PaneComponent, DoublePaneComponent], imports: [CommonModule], exports: [PaneComponent, DoublePaneComponent] }) export class PaneModule { }
|   |   |   +-- style-editor
|   |   |   |   +-- style-editor.component.html: <div> <button mat-icon-button (click)="addRow()" aria-label="Add row"> <mat-icon>add</mat-icon> </button> </div> <table mat-table [dataSource]="dataSource" class="mat-elevation-z8"> <ng-container matColumnDef="al"> <th mat-header-cell *matHeaderCellDef> AL </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readAl"> <input matInput [(ngModel)]="row.al" /> </ng-container> <ng-template #readAl>{{ row.al }}</ng-template> </td> </ng-container> <ng-container matColumnDef="base"> <th mat-header-cell *matHeaderCellDef> Base </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readBase"> <input matInput [(ngModel)]="row.base" /> </ng-container> <ng-template #readBase>{{ row.base }}</ng-template> </td> </ng-container> <ng-container matColumnDef="ref"> <th mat-header-cell *matHeaderCellDef> Ref </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readRef"> <input matInput [(ngModel)]="row.ref" /> </ng-container> <ng-template #readRef>{{ row.ref }}</ng-template> </td> </ng-container> <ng-container matColumnDef="strokeColor"> <th mat-header-cell *matHeaderCellDef> Stroke Color </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readStrokeColor"> <input matInput type="color" [(ngModel)]="row.strokeColor" /> </ng-container> <ng-template #readStrokeColor> <div [style.background]="row.strokeColor" class="color-preview"></div> </ng-template> </td> </ng-container> <ng-container matColumnDef="fillColor"> <th mat-header-cell *matHeaderCellDef> Fill Color </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readFillColor"> <input matInput type="color" [(ngModel)]="row.fillColor" /> </ng-container> <ng-template #readFillColor> <div [style.background]="row.fillColor" class="color-preview"></div> </ng-template> </td> </ng-container> <ng-container matColumnDef="style"> <th mat-header-cell *matHeaderCellDef> Style </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readStyle"> <mat-select [(value)]="row.style"> <mat-option *ngFor="let s of styles" [value]="s">{{ s }}</mat-option> </mat-select> </ng-container> <ng-template #readStyle>{{ row.style }}</ng-template> </td> </ng-container> <ng-container matColumnDef="actions"> <th mat-header-cell *matHeaderCellDef> Actions </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing"> <!-- Save Icon --> <button mat-icon-button (click)="saveRow(row)" aria-label="Save row"> <mat-icon>check</mat-icon> </button> <!-- Cancel Icon --> <button mat-icon-button (click)="cancelEdit(row)" aria-label="Cancel edit"> <mat-icon>close</mat-icon> </button> </ng-container> <ng-container *ngIf="!row.isEditing"> <!-- Edit Icon --> <button mat-icon-button (click)="editRow(row)" aria-label="Edit row"> <mat-icon>edit</mat-icon> </button> </ng-container> </td> </ng-container> <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr> <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> </table>
|   |   |   |   +-- style-editor.component.scss: .color-preview { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #ddd; } /* Make icons flat and apply royal blue color */ .mat-icon-button.flat { background: none; color: royalblue; border: none; box-shadow: none; } .mat-icon-button.flat:hover { background: rgba(65, 105, 225, 0.1); /* Adds a subtle hover effect */ } .mat-icon-button.flat:active { background: rgba(65, 105, 225, 0.2); /* Slightly darker hover on click */ } .icon-blue { color: blue; } .new-entry-row { background-color: #f2f2f2; }
|   |   |   |   +-- style-editor.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing'; import { StyleEditorComponent } from './style-editor.component'; describe('StyleEditorComponent', () => { let component: StyleEditorComponent; let fixture: ComponentFixture<StyleEditorComponent>; beforeEach(() => { TestBed.configureTestingModule({ declarations: [StyleEditorComponent] }); fixture = TestBed.createComponent(StyleEditorComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
|   |   |   |   \-- style-editor.component.ts: import { Component } from '@angular/core'; interface StyleRow { al: string; base: string; ref: string; strokeColor: string; fillColor: string; style: string; isEditing?: boolean; } @Component({ selector: 'style-editor', templateUrl: './style-editor.component.html', styleUrls: ['./style-editor.component.scss'] }) export class StyleEditorComponent { displayedColumns: string[] = ['al', 'base', 'ref', 'strokeColor', 'fillColor', 'style', 'actions']; styles: string[] = ['solid', 'dashed', 'dotted']; // D3 line styles dataSource: StyleRow[] = [ { al: 'SampleAl', base: 'SampleBase', ref: 'SampleRef', strokeColor: '#000000', fillColor: '#FFFFFF', style: 'solid', isEditing: false } ]; addRow() { // Add a new row at the top, in editing mode const newRow: StyleRow = { al: '', base: '', ref: '', strokeColor: '#000000', fillColor: '#FFFFFF', style: 'solid', isEditing: true // Set to true to start editing mode immediately }; this.dataSource = [newRow, ...this.dataSource]; // Assign a new array to trigger change detection } editRow(row: StyleRow) { row.isEditing = true; } saveRow(row: StyleRow) { row.isEditing = false; } cancelEdit(row: StyleRow) { if (!row.al && !row.base && !row.ref) { // Remove row if it's empty and a new entry const index = this.dataSource.indexOf(row); if (index > -1) { this.dataSource.splice(index, 1); } } else { row.isEditing = false; } } }
|   |   |   \-- table
|   |   |       +-- table.component.html: <div class="table-container" #tableContainer> <div class="table-content"> <table> <caption> <div class="table-controls"> <button (click)="onAddNewRow()"> <mat-icon>add_circle</mat-icon> </button> <button (click)="onSaveAll()"> <mat-icon>save</mat-icon> </button> </div> </caption> <thead> <!-- Column Headers with Sort/Filter Icons --> <tr class="header-row"> <th *ngFor="let column of displayedColumns" class="column-header"> <div class="header-content"> <div class="header-title"> {{column}} </div> <div class="header-actions"> <button class="icon-button sort-button" matTooltip="Sort"> <mat-icon class="small-icon">unfold_more</mat-icon> </button> <button class="icon-button filter-button" matTooltip="Toggle Filters" (click)="toggleFilters()" [class.active]="showFilters"> <mat-icon class="small-icon" [class.active]="showFilters">filter_list</mat-icon> </button> </div> </div> </th> <th class="actions-cell column-header"> <div class="header-content"> <div class="header-title">Actions</div> <div class="header-actions"> <button class="icon-button filter-toggle" matTooltip="Toggle All Filters" (click)="toggleFilters()" [class.active]="showFilters"> <mat-icon class="small-icon" [class.active]="showFilters">filter_list</mat-icon> </button> </div> </div> </th> </tr> <!-- Filter Inputs Row - Now with animation classes --> <tr class="filter-row" [@filterAnimation]="showFilters ? 'visible' : 'hidden'"> <th *ngFor="let column of displayedColumns"> <input type="text" class="filter-input" [placeholder]="'Filter ' + column" matTooltip="Enter filter criteria"> </th> <th class="actions-cell"> <button class="clear-filters" matTooltip="Clear all filters"> <mat-icon class="small-icon">clear</mat-icon> </button> </th> </tr> </thead> <tbody> <tr *ngFor="let row of paginatedData; let i = index" [class.selected]="row.selected" (click)="onRowClick(row, i, $event)"> <td *ngFor="let column of displayedColumns"> <ng-container *ngIf="!row.isEditing"> {{row[column]}} </ng-container> <ng-container *ngIf="row.isEditing"> <input *ngIf="column === 'base' || column === 'ref'" [value]="row[column]" (input)="onFieldChange($event.target.value, column, row, i)" (click)="$event.stopPropagation()"> <span *ngIf="column !== 'base' && column !== 'ref'">{{row[column]}}</span> </ng-container> </td> <td class="actions-cell"> <ng-container *ngIf="!row.isEditing"> <button (click)="onEdit(row, i, $event)"> <mat-icon>edit</mat-icon> </button> <button class="delete-button" (click)="onDelete(row, i, $event)"> <mat-icon>delete</mat-icon> </button> </ng-container> <ng-container *ngIf="row.isEditing"> <button (click)="onSave(row, i)"> <mat-icon>save</mat-icon> </button> <button (click)="onCancel(row, i)"> <mat-icon>close</mat-icon> </button> </ng-container> </td> </tr> </tbody> <tfoot> <tr> <td [attr.colspan]="displayedColumns.length + 1"> <div class="pagination-container"> <div class="pagination-controls"> <button class="pagination-button" (click)="goToFirstPage()" [disabled]="pagination.currentPage === 1"> <mat-icon>first_page</mat-icon> </button> <button class="pagination-button" (click)="goToPreviousPage()" [disabled]="pagination.currentPage === 1"> <mat-icon>chevron_left</mat-icon> </button> <div class="pagination-pages"> <button *ngFor="let page of visiblePages" class="pagination-button" [class.active]="page === pagination.currentPage" [class.ellipsis]="page === -1" [disabled]="page === -1" (click)="onPageChange(page)"> {{page === -1 ? '...' : page}} </button> </div> <button class="pagination-button" (click)="goToNextPage()" [disabled]="pagination.currentPage === totalPages"> <mat-icon>chevron_right</mat-icon> </button> <button class="pagination-button" (click)="goToLastPage()" [disabled]="pagination.currentPage === totalPages"> <mat-icon>last_page</mat-icon> </button> </div> <div class="page-size-selector"> <select (change)="onPageSizeChange($event.target.value)"> <option *ngFor="let size of pagination.pageSizeOptions" [value]="size" [selected]="size === pagination.pageSize"> {{size === -1 ? 'All' : size}} </option> </select> <span class="page-size-label">items per page</span> </div> </div> </td> </tr> </tfoot> </table> </div> </div>
|   |   |       +-- table.component.scss: // table.component.scss .table-controls { padding: 10px; display: flex; gap: 10px; align-items: center; button { background: none; border: none; padding: 0; cursor: pointer; color: #1976d2; &:hover { color: #1565c0; } } } .table-container { width: 100%; height: 100%; display: flex; flex-direction: column; font-family: 'Helvetica Neue', Arial, sans-serif; } .table-content { overflow: auto; position: relative; table { width: 95%; margin: 10px auto; border-collapse: collapse; table-layout: fixed; caption { caption-side: top; padding: 10px; .table-controls { display: flex; gap: 10px; align-items: center; justify-content: flex-start; button { background: none; border: none; padding: 4px; cursor: pointer; color: #1976d2; display: flex; align-items: center; justify-content: center; border-radius: 4px; &:hover { background-color: rgba(25, 118, 210, 0.04); color: #1565c0; } mat-icon { font-size: 20px; width: 20px; height: 20px; line-height: 20px; } } } } thead { th { position: sticky; top: 0; z-index: 10; background-color: #f5f5f5; padding: 8px; font-weight: 500; color: #333; border-bottom: 1px solid #e0e0e0; white-space: nowrap; transition: background-color 0.2s; box-shadow: 0 2px 2px -1px rgba(0,0,0,0.4); &:hover { background-color: #eeeeee; } } .header-row { th { padding: 0; } } .column-header { .header-content { display: flex; align-items: center; justify-content: space-between; padding: 8px; min-height: 48px; } .header-title { font-weight: 500; margin-right: 8px; } .header-actions { display: flex; gap: 4px; align-items: center; } .icon-button { background: none; border: none; padding: 4px; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666; transition: all 0.2s; &:hover { background-color: rgba(0, 0, 0, 0.04); color: #333; } .small-icon { font-size: 18px; width: 18px; height: 18px; line-height: 18px; &.active { color: #1976d2; } } } } .filter-row { background-color: #fafafa; transition: all 0.3s ease; &.hidden { display: none; } th { padding: 8px; background-color: #fafafa; border-top: 1px solid #e0e0e0; } .filter-input { width: 100%; padding: 6px 8px; border: 1px solid #e0e0e0; border-radius: 4px; font-size: 12px; background-color: white; transition: border-color 0.2s; &:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 0 1px rgba(25, 118, 210, 0.2); } &::placeholder { color: #999; } } .clear-filters { background: none; border: none; padding: 4px; cursor: pointer; color: #666; display: flex; align-items: center; justify-content: center; width: 100%; &:hover { color: #d32f2f; } } } } tbody { td { padding: 2px; text-align: left; border-bottom: 1px solid #e0e0e0; font-size: 12px; color: #333; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 150px; } tr { &:nth-child(even) { background-color: #ffffff; } &:nth-child(odd) { background-color: #f7f7f7; } &:hover { background-color: #f0f0f0; } &.selected { background-color: #add8e6; font-weight: bold; } } } .actions-cell { min-width: 100px; text-align: right; } tfoot { tr td { padding: 0; } } } // Pagination styles .pagination-container { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background-color: #fff; border-top: 1px solid #e0e0e0; } .pagination-controls { display: flex; align-items: center; gap: 4px; } .pagination-pages { display: flex; gap: 4px; } .pagination-button { min-width: 32px; height: 32px; padding: 0 4px; margin: 0 2px; border: none; background: none; border-radius: 4px; cursor: pointer; color: #1976d2; font-size: 13px; mat-icon { font-size: 18px; width: 18px; height: 18px; line-height: 18px; } &:hover:not(:disabled) { background-color: rgba(0, 0, 0, 0.04); } &:disabled { color: rgba(0, 0, 0, 0.26); cursor: default; } &.active { background-color: #1976d2; color: white; } &.ellipsis { cursor: default; &:hover { background: none; } } } .page-size-selector { display: flex; align-items: center; gap: 8px; select { padding: 4px 8px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: white; cursor: pointer; font-size: 13px; &:focus { outline: none; border-color: #1976d2; } } .page-size-label { color: rgba(0, 0, 0, 0.54); font-size: 13px; } } } .text-center { text-align: center; } .text-right { text-align: right; } .flex-grow { flex-grow: 1; } .ellipsis { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .column-header { .icon-button { &.active { color: #1976d2; background-color: rgba(25, 118, 210, 0.12); } } } .filter-row { background-color: #fafafa; th { border-top: 1px solid #e0e0e0; transition: padding 200ms cubic-bezier(0.4, 0.0, 0.2, 1); .filter-input { opacity: 1; transition: opacity 200ms cubic-bezier(0.4, 0.0, 0.2, 1); } } &.ng-animating { th { overflow: hidden; } } }
|   |   |       \-- table.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild } from '@angular/core'; import { ChangeDetectorRef } from '@angular/core'; import { FeatureCollection, Feature } from 'geojson'; import { DataService } from '../../services/data.service'; import { Subscription } from 'rxjs'; import { trigger, state, style, transition, animate } from '@angular/animations'; interface PaginationConfig { pageSize: number; currentPage: number; totalItems: number; pageSizeOptions: number[]; } @Component({ selector: 'app-table', templateUrl: './table.component.html', styleUrls: ['./table.component.scss'], animations: [ trigger('filterAnimation', [ state('hidden', style({ opacity: 0, height: '0px', minHeight: '0', padding: '0', overflow: 'hidden' })), state('visible', style({ opacity: 1, height: '*', minHeight: '48px' })), transition('hidden <=> visible', [ animate('200ms cubic-bezier(0.4, 0.0, 0.2, 1)') ]) ]) ] }) export class TableComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('tableContainer', { static: true }) tableContainer: ElementRef; displayedColumns: string[] = []; dataSource: any[] = []; private resizeObserver!: ResizeObserver; private subscription: Subscription; selectedRows = new Set(); lastClickedRowIndex: number | null = null; editingRows = new Set<number>(); formatCoord = (coord: number) => coord.toFixed(3); showFilters = false; paginatedData: any[] = []; // Add this line pagination: PaginationConfig = { pageSize: 10, currentPage: 1, totalItems: 0, pageSizeOptions: [10, 25, 50, 100, -1] // -1 represents 'All' }; constructor(private dataService: DataService, private cdr: ChangeDetectorRef) {} ngOnInit(): void { this.dataService.setSelectedFeatures([]); this.initTable(); this.subscription = this.dataService.getSelectedFeatures().subscribe(features => { this.updateTableSelection(features); }); } ngAfterViewInit(): void { this.resizeObserver = new ResizeObserver(() => { this.resizeTable(); }); this.resizeObserver.observe(this.tableContainer.nativeElement); } ngOnDestroy(): void { if (this.resizeObserver) { this.resizeObserver.disconnect(); } this.subscription.unsubscribe(); } private initTable(): void { const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer?.getFeatures()?.length > 0) { const features = selectedLayer.getFeatures(); if (features[0].properties) { this.displayedColumns = Object.keys(features[0].properties); this.dataSource = features.map(feature => ({ ...feature.properties, id: feature.id, selected: false, isEditing: false })); this.pagination.totalItems = this.dataSource.length; this.updatePaginatedData(); } } } initializeNewEntry(): any { return { id: 'NEW', Airline: 'DL', base: '', ref: '', 'City 1': '', 'City 2': '', 'Coords 1': '(0.000, 0.000)', 'Coords 2': '(0.000, 0.000)', isEditing: true, isNew: true }; } onAddNewRow(): void { const newEntry = this.initializeNewEntry(); this.dataSource.unshift(newEntry); } onFieldChange(value: string, field: string, row: any, index: number): void { // Sanitize the input const sanitizedValue = value.toUpperCase().replace(/[^A-Z0-9]/g, ''); // Update the specific row's field row[field] = sanitizedValue; // Only trigger the airport lookup if we have a complete code if (sanitizedValue.length === 3) { if (field === 'base') { const baseAirport = this.dataService.getAirport(sanitizedValue); if (baseAirport) { row['City 1'] = baseAirport.city; row['Coords 1'] = `(${this.formatCoord(baseAirport.lon)}, ${this.formatCoord(baseAirport.lat)})`; this.updateId(row); } else { alert('Base airport not found'); row.base = ''; } } else if (field === 'ref') { const refAirport = this.dataService.getAirport(sanitizedValue); if (refAirport) { row['City 2'] = refAirport.city; row['Coords 2'] = `(${this.formatCoord(refAirport.lon)}, ${this.formatCoord(refAirport.lat)})`; this.updateId(row); } else { alert('Ref airport not found'); row.ref = ''; } } } } updateId(row: any): void { if (row.base && row.ref) { const newId = `${row.base}-${row.ref}-DL`; const idExists = this.dataSource.some(r => r.id === newId && r !== row); if (idExists) { alert('Route with this ID already exists'); row.id = row.isNew ? 'NEW' : row.originalData.id; } else { row.id = newId; } } } resizeTable(): void { if (this.tableContainer) { const width = this.tableContainer.nativeElement.offsetWidth; const height = this.tableContainer.nativeElement.offsetHeight; console.log(`Resizing table to ${width}x${height}`); } } onRowClick(row: any, index: number, event: MouseEvent): void { if (this.editingRows.size > 0) { return; // Prevent selection while editing } this.lastClickedRowIndex = index; let newSelection; if (event.shiftKey && this.lastClickedRowIndex !== null) { const start = Math.min(index, this.lastClickedRowIndex); const end = Math.max(index, this.lastClickedRowIndex); newSelection = this.dataSource.slice(start, end + 1); } else if (event.ctrlKey || event.metaKey) { newSelection = [...this.dataService.getSelectedFeatures().value || []]; const idx = newSelection.findIndex(item => item.id === row.id); if (idx > -1) { newSelection.splice(idx, 1); } else { newSelection.push(row); } } else { newSelection = [row]; } this.dataService.setSelectedFeatures(newSelection); } updateTableSelection(features: Feature[] | null): void { if (!features) { console.log('No features to update in table.'); return; } this.dataSource.forEach(row => { const isSelected = features.some(feature => feature && feature.id === row.id); if (isSelected !== row.selected) { row.selected = isSelected; } }); } onEdit(row: any, index: number, event: Event): void { event.stopPropagation(); row.originalData = { ...row }; row.isEditing = true; this.editingRows.add(index); } onSave(row: any, index: number): void { if (row.id === 'NEW' || !row.base || !row.ref) { alert('Please complete all required fields before saving'); return; } const feature = this.createFeatureFromEntry(row); const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer) { if (row.isNew) { this.dataService.addFeature(feature); } else { this.dataService.updateFeature(feature); } this.dataService.addLayer('routes', selectedLayer); row.isEditing = false; row.isNew = false; delete row.originalData; this.editingRows.delete(index); const currentlySelectedFeatures = this.dataService.getSelectedFeatures().value || []; this.dataService.setSelectedFeatures([...currentlySelectedFeatures]); } } onCancel(row: any, index: number): void { if (row.isNew) { this.dataSource = this.dataSource.filter((_, i) => i !== index); } else { Object.assign(row, row.originalData); row.isEditing = false; delete row.originalData; } this.editingRows.delete(index); } onDelete(row: any, index: number, event: Event): void { event.stopPropagation(); if (confirm('Are you sure you want to delete this row?')) { const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer && !row.isNew) { this.dataService.removeFeature(row.id); this.dataService.addLayer('routes', selectedLayer); } this.dataSource = this.dataSource.filter((_, i) => i !== index); } } onSaveAll(): void { const selectedLayer = this.dataService.getSelectedLayer(); if (!selectedLayer) { alert('No layer selected'); return; } for (const row of this.dataSource) { if (row.isNew || row.isEditing) { if (row.id === 'NEW' || !row.base || !row.ref) { alert('Please complete all required fields before saving'); return; } const feature = this.createFeatureFromEntry(row); if (row.isNew) { this.dataService.addFeature(feature); } else { this.dataService.updateFeature(feature); } row.isEditing = false; row.isNew = false; delete row.originalData; } } this.editingRows.clear(); this.dataService.addLayer('routes', selectedLayer); const currentlySelectedFeatures = this.dataService.getSelectedFeatures().value || []; this.dataService.setSelectedFeatures([...currentlySelectedFeatures]); } private createFeatureFromEntry(entry: any): Feature { const city1 = this.dataService.getAirport(entry.base); const city2 = this.dataService.getAirport(entry.ref); const coords1 = [city1.lon, city1.lat]; const coords2 = [city2.lon, city2.lat]; return { type: 'Feature', id: entry.id, geometry: { type: 'LineString', coordinates: [ coords1, coords2 ] }, properties: { Airline: entry.Airline, base: entry.base, ref: entry.ref, 'City 1': entry['City 1'], 'City 2': entry['City 2'], 'Coords 1': entry['Coords 1'], 'Coords 2': entry['Coords 2'] }, }; } // Pagination Methods updatePaginatedData(): void { if (this.pagination.pageSize === -1) { // Show all data this.paginatedData = [...this.dataSource]; return; } const startIndex = (this.pagination.currentPage - 1) * this.pagination.pageSize; const endIndex = startIndex + this.pagination.pageSize; this.paginatedData = this.dataSource.slice(startIndex, endIndex); } get totalPages(): number { if (this.pagination.pageSize === -1) return 1; return Math.ceil(this.pagination.totalItems / this.pagination.pageSize); } get visiblePages(): number[] { const totalPages = this.totalPages; const current = this.pagination.currentPage; const pages: number[] = []; if (totalPages <= 7) { // Show all pages if total is 7 or less for (let i = 1; i <= totalPages; i++) pages.push(i); } else { // Always show first page pages.push(1); if (current > 3) pages.push(-1); // Add ellipsis // Show pages around current page for (let i = Math.max(2, current - 1); i <= Math.min(totalPages - 1, current + 1); i++) { pages.push(i); } if (current < totalPages - 2) pages.push(-1); // Add ellipsis // Always show last page pages.push(totalPages); } return pages; } onPageSizeChange(newSize: number): void { this.pagination.pageSize = newSize; this.pagination.currentPage = 1; // Reset to first page this.updatePaginatedData(); } onPageChange(page: number): void { if (page < 1 || page > this.totalPages) return; this.pagination.currentPage = page; this.updatePaginatedData(); } // Navigation methods goToFirstPage(): void { this.onPageChange(1); } goToLastPage(): void { this.onPageChange(this.totalPages); } goToPreviousPage(): void { this.onPageChange(this.pagination.currentPage - 1); } goToNextPage(): void { this.onPageChange(this.pagination.currentPage + 1); } toggleFilters(event?: Event): void { if (event) { event.stopPropagation(); } this.showFilters = !this.showFilters; } }
|   |   +-- enums
|   |   |   \-- projection-type.enum.ts: // src/app/enums/projection-type.enum.ts export enum ProjectionType { Armadillo = 'armadillo', Gnomonic = 'gnomonic', LambertConicConformal = 'lambertConicConformal', Mercator = 'mercator', Orthographic = 'orthographic', TiltedPerspective = 'tiltedPerspective', TransverseMercator = 'transverseMercator', Equirectangular = 'equirectangular', NaturalEarth = 'naturalEarth', AzimuthalEqualArea = 'azimuthalEqualArea', Stereographic = 'stereographic', AlbersUSA = 'albersUSA', Sinusoidal = 'sinusoidal', Mollweide= 'mollweide' }
|   |   +-- guards
|   |   |   \-- auth.guard.ts: // src/app/guards/auth.guard.ts import { Injectable } from '@angular/core'; import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router'; import { AuthService } from '../services/auth.service'; @Injectable({ providedIn: 'root' }) export class AuthGuard implements CanActivate { constructor(private authService: AuthService, private router: Router) {} canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean { // Define public routes that don't require authentication const publicRoutes = ['/admin/users', '/login', '/identity/profile', '/identity/password', '/identity/username']; // Check if the current route is in public routes if (publicRoutes.some(route => state.url.startsWith(route))) { return true; } // Check if user is authenticated if (this.authService.isAuthenticated()) { return true; } // Not authenticated and not a public route, redirect to login this.router.navigate(['/login']); return false; } }
|   |   +-- interfaces
|   |   |   +-- airport-data.interface.ts: export interface AirportData { code: string; // Airport code (e.g., IATA code) region: number; // Region code or ID, if applicable name: string; // Name of the airport city: string; // City in which the airport is located country: string; // Country in which the airport is located lat: number; // Latitude of the airport lon: number; // Longitude of the airport }
|   |   |   +-- filter-listener.ts: export interface FilterCriteria { [key: string]: any; } export interface FilterListener { /** * Called when a filter is applied. * @param criteria The filter criteria */ onFilter(criteria: FilterCriteria): void; /** * Called when the filter is cleared. */ onClearFilter(): void; }
|   |   |   +-- flight-data.interface.ts: export interface FlightData { flight_number?: string; origin?: string; destination?: string; frequency?: string; days?: string; departure_time?: string; arrival_time?: string; effective_date?: string | null; discontinued_date?: string | null; suspension_start?: string | null; suspension_end?: string | null; notes?: string | null; }
|   |   |   +-- model-listener.ts: import { GeoModel } from '../models/geo-model'; export interface ModelListener { /** * Called when the model data is updated. * @param model The updated GeoJSONModel */ onModelChange(model: GeoModel): void; }
|   |   |   \-- selection-listener.ts: import { Feature } from 'geojson'; export interface SelectionListener { /** * Called when a feature is selected. * @param feature The selected feature */ onSelect(feature: Feature): void; /** * Called when a feature is deselected. * @param feature The deselected feature */ onDeselect(feature: Feature): void; /** * Called when the selection is cleared. */ onClearSelection(): void; }
|   |   +-- models
|   |   |   +-- criteria.model.ts: export interface CriteriaModel { filterString: string; // Add any additional filter criteria properties as needed }
|   |   |   \-- layer.ts: // Importing the GeoJSON Feature type import { Feature } from 'geojson'; export class Layer { public name: string; private features: Feature[]; // An array of GeoJSON Features constructor(name: string, features: Feature[] = []) { this.name = name; this.features = features; } // Method to get all features getFeatures(): Feature[] { return this.features; } // Method to add a feature addFeature(feature: Feature): void { this.features.push(feature); } // Method to find a feature by ID findFeatureById(id: string | number): Feature | undefined { return this.features.find(feature => feature.id === id); } // Method to remove a feature by ID removeFeatureById(id: string | number): void { this.features = this.features.filter(feature => feature.id !== id); } getProperty(index: number): { [key: string]: any } | undefined { const feature = this.features[index]; return feature ? feature.properties : undefined; } // Method to get properties of all features getProperties(): { [key: string]: any }[] { return this.features .map(feature => feature.properties) .filter(properties => properties !== undefined); } // Custom toString() method for the Layer class toString(): string { if (this.features.length === 0) { return `Layer Name: ${this.name}, Number of Features: 0 (No feature data available)`; } // Extract property names from the first feature const propertyNames = this.features[0].properties ? Object.keys(this.features[0].properties) : []; return `Layer Name: ${this.name}, Number of Features: ${this.features.length}, Property Names: ${propertyNames.join(', ')}`; } }
|   |   +-- services
|   |   |   +-- airport.service.ts: import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { AirportData } from '../interfaces/airport-data.interface'; // Update the path as necessary @Injectable({ providedIn: 'root' }) export class AirportService { constructor(private http: HttpClient) {} loadAirportData(): Observable<AirportData[]> { return this.http.get<AirportData[]>('assets/Airport.json'); } }
|   |   |   +-- auth.service.ts: // src/app/services/auth.service.ts import { Injectable } from '@angular/core'; import { Router } from '@angular/router'; @Injectable({ providedIn: 'root' }) export class AuthService { constructor(private router: Router) {} login(username: string, password: string): boolean { if (username === 'admin' && password === 'admin') { localStorage.setItem('isLoggedIn', 'true'); this.router.navigate(['/map']); return true; } return false; } logout() { localStorage.removeItem('isLoggedIn'); this.router.navigate(['/login']); } isAuthenticated(): boolean { return localStorage.getItem('isLoggedIn') === 'true'; } }
|   |   |   +-- data.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { Layer } from '../models/layer'; import { AirportData } from '../interfaces/airport-data.interface'; import { Feature } from 'geojson'; @Injectable({ providedIn: 'root' }) export class DataService { private airports: Map<string, AirportData> = new Map(); // Stores airport data by code private layersMap: Map<string, Layer> = new Map(); private selectedLayerName: string | null = null; private selectedFeatures: BehaviorSubject<Feature[] | null> = new BehaviorSubject([]); // Layer Getters and Setters public addLayer(name: string, layer: Layer): void { this.layersMap.set(name, layer); } public getLayer(name: string): Layer | undefined { return this.layersMap.get(name); } public getLayerNames(): string[] { return Array.from(this.layersMap.keys()); } public getLayers(): Layer[] { return Array.from(this.layersMap.values()); } public getSelectedLayer(): Layer | undefined { if (this.selectedLayerName) { return this.layersMap.get(this.selectedLayerName); } return undefined; } public setSelectedLayer(layerName: string): void { this.selectedLayerName = layerName; const selectedLayer = this.layersMap.get(layerName); if (selectedLayer && selectedLayer.getFeatures()) { //console.log(`Setting selected layer: ${layerName} with ${selectedLayer.getFeatures().length} features`); this.setSelectedFeatures(selectedLayer.getFeatures()); } else { this.setSelectedFeatures([]); // Clear features if the layer is undefined or has no features } } public setSelectedFeatures(features: Feature[]): void { //console.log('DataService.setSelectedFeatures called with features:', features); this.selectedFeatures.next(features); } public getSelectedFeatures(): BehaviorSubject<Feature[]> { return this.selectedFeatures; } // Airport Getters and Setters public getAirports(): AirportData[] { return Array.from(this.airports.values()); } public setAirports(airports: AirportData[]): void { this.airports.clear(); airports.forEach(airport => { this.airports.set(airport.code, airport); }); //console.log('Airports data set in DataService'); } public getAirport(code: string): AirportData | undefined { return this.airports.get(code); } public setAirport(airport: AirportData): void { if (airport && airport.code) { this.airports.set(airport.code, airport); //console.log(`Airport data updated for ${airport.code} in DataService`); } else { //console.error('Invalid airport data provided'); } } // New methods for feature management updateFeature(feature: Feature) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); const index = features.findIndex((f: Feature) => f.id === feature.id); if (index !== -1) { features[index] = feature; //this.getSelectedLayer().setFeatures(features); } } } removeFeature(featureId: string) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); const filteredFeatures = features.filter((f: Feature) => f.id !== featureId); //this.getSelectedLayer().setFeatures(filteredFeatures); } } addFeature(feature: Feature) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); features.push(feature); //this.getSelectedLayer().setFeatures(features); } } }
|   |   |   +-- query-processor.spec.ts: // import { processAndSortData } from './queryProcessor'; // describe('Query Processor', () => { // const mockData = [ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]; // it('should filter data with a simple "eq" condition', () => { // const query = { // and: [{ field: 'al', operator: 'eq', value: 'DL' }] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' } // ]); // }); // it('should filter data with "not_in" condition', () => { // const query = { // and: [{ field: 'base', operator: 'not_in', value: ['ATL', 'MSP'] }] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]); // }); // it('should filter data with nested "or" and "and" conditions', () => { // const query = { // or: [ // { field: 'al', operator: 'eq', value: 'UA' }, // { // and: [ // { field: 'al', operator: 'eq', value: 'DL' }, // { field: 'ref', operator: 'in', value: ['SEA', 'ORD'] } // ] // } // ] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]); // }); // it('should sort data based on the "base" field in ascending order', () => { // const query = { // sort: { field: 'base', order: 'asc' } // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'UA', base: 'DEN', ref: 'IAH' }, // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'DL', base: 'SLC', ref: 'SEA' } // ]); // }); // });
|   |   |   +-- query-processor.ts: // export type QueryCondition = { // field: string; // operator: 'eq' | 'in' | 'not_in'; // value: any; // }; // export type Query = { // and?: QueryCondition[] | Query[]; // or?: QueryCondition[] | Query[]; // sort?: { field: string; order: 'asc' | 'desc' }; // }; // // Function to evaluate a single condition // function evaluateCondition(item: any, condition: QueryCondition): boolean { // switch (condition.operator) { // case 'eq': // return item[condition.field] === condition.value; // case 'in': // return Array.isArray(condition.value) && condition.value.includes(item[condition.field]); // case 'not_in': // return Array.isArray(condition.value) && !condition.value.includes(item[condition.field]); // default: // throw new Error(`Unsupported operator: ${condition.operator}`); // } // } // // Function to process a query with nested logic // export function processQuery(data: any[], query: Query): any[] { // if (query.and) { // return data.filter(item => query.and!.every(subQuery => Array.isArray(subQuery) ? processQuery([item], subQuery).length > 0 : evaluateCondition(item, subQuery))); // } // if (query.or) { // return data.filter(item => query.or!.some(subQuery => Array.isArray(subQuery) ? processQuery([item], subQuery).length > 0 : evaluateCondition(item, subQuery))); // } // return data; // } // // Function to apply sorting // export function sortData(data: any[], sort: { field: string; order: 'asc' | 'desc' }): any[] { // return data.sort((a, b) => { // if (sort.order === 'asc') return a[sort.field] > b[sort.field] ? 1 : -1; // return a[sort.field] < b[sort.field] ? 1 : -1; // }); // } // // Main function to process and sort data based on query // export function processAndSortData(data: any[], query: Query): any[] { // let filteredData = processQuery(data, query); // if (query.sort) { // filteredData = sortData(filteredData, query.sort); // } // return filteredData; // }
|   |   |   \-- resources.ts: import * as Papa from 'papaparse'; export class Resources { static async load(filePaths: string[]): Promise<any[]> { try { const results = []; for (const path of filePaths) { let data; if (path.endsWith('.json') || path.endsWith('.geojson')) { const response = await fetch(path); if (!response.ok) throw new Error(`Failed to load ${path}`); data = await response.json(); } else if (path.endsWith('.csv')) { const response = await fetch(path); if (!response.ok) throw new Error(`Failed to load ${path}`); const csvText = await response.text(); data = Papa.parse(csvText, { header: true, skipEmptyLines: true, }).data; } results.push({ data, path }); } return results; } catch (err) { console.error('Error during resource loading:', err); throw err; } } }
|   |   +-- utils
|   |   |   \-- geo-feature.util.ts: import { Feature, LineString } from 'geojson'; import * as d3 from 'd3-geo'; import { AirportService } from '../services/airport.service'; import { AirlineService } from '../services/airline.service'; export function createGreatCircleFeature( cityPair: any, airportService: AirportService, airlineService: AirlineService ): Feature<LineString> | null { //console.log('Looking up base airport:', cityPair.base); const baseAirport = airportService.getAirportByCode(cityPair.base); //console.log('Looking up ref airport:', cityPair.ref); const refAirport = airportService.getAirportByCode(cityPair.ref); if (!baseAirport || !refAirport) { //console.error('Airport not found for base or ref:', cityPair.base, cityPair.ref); return null; } const baseCoords: [number, number] = [baseAirport.lon, baseAirport.lat]; const refCoords: [number, number] = [refAirport.lon, refAirport.lat]; const greatCircle = d3.geoInterpolate(baseCoords, refCoords); const steps = 50; const pathCoords = Array.from({ length: steps + 1 }, (_, i) => greatCircle(i / steps)); const feature: Feature<LineString> = { type: 'Feature', geometry: { type: 'LineString', coordinates: pathCoords }, properties: { base: baseAirport.code, ref: refAirport.code, baseName: baseAirport.name, refName: refAirport.name, airline: airlineService.getAirlineByCode(cityPair.al)?.name || 'Unknown Airline', distance: d3.geoDistance(baseCoords, refCoords), layer: 'puck' } }; return feature; }
|   |   +-- app-routing.module.ts: // src/app/app-routing.module.ts import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { LoginComponent } from './components/login/login.component'; import { MainLayoutComponent } from './components/layout/main-layout.component'; import { MapViewComponent } from './components/map-view/map-view.component'; import { AuthGuard } from './guards/auth.guard'; import { PasswordComponent } from './components/identity/password/password.component'; import { ProfileComponent } from './components/identity/profile/profile.component'; import { UsernameComponent } from './components/identity/username/username.component'; import { UsersComponent } from './components/admin/users/users.component'; import { UserDetailComponent } from './components/admin/user-detail/user-detail.component'; import { RoleDetailComponent } from './components/admin/role-detail/role-detail.component'; import { RolesComponent } from './components/admin/roles/roles.component'; const routes: Routes = [ { path: '', redirectTo: '/login', pathMatch: 'full' }, { path: 'login', component: LoginComponent }, { path: '', component: MainLayoutComponent, canActivate: [AuthGuard], children: [ { path: 'map', component: MapViewComponent }, { path: 'admin/users', component: UsersComponent, canActivate: [AuthGuard] }, { path: 'admin/users/:id', component: UserDetailComponent, canActivate: [AuthGuard] }, { path: 'admin/roles', component: RolesComponent, canActivate: [AuthGuard] }, { path: 'admin/roles/:id', component: RoleDetailComponent, canActivate: [AuthGuard] }, { path: 'logout', redirectTo: '/login', pathMatch: 'full' } ] }, { path: 'identity/profile', component: ProfileComponent }, // Route for user registration { path: 'identity/password', component: PasswordComponent }, // Route for password reset { path: 'identity/username', component: UsernameComponent }, // Route for username assistance { path: '**', redirectTo: '/login', pathMatch: 'full' } // Wildcard route for a 404 page ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }
|   |   +-- app.component.html
|   |   +-- app.component.scss
|   |   +-- app.component.ts: import { Component } from '@angular/core'; @Component({ selector: 'app-root', template: '<router-outlet></router-outlet>', styleUrls: ['./app.component.scss'] }) export class AppComponent {}
|   |   \-- app.module.ts: import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { HttpClientModule } from '@angular/common/http'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { RouterModule } from '@angular/router'; import { CommonModule } from '@angular/common'; import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component'; import { MatPaginatorModule } from '@angular/material/paginator'; import { MatSortModule } from '@angular/material/sort'; import { MatTooltipModule } from '@angular/material/tooltip'; import { MatTabsModule } from '@angular/material/tabs'; import { MatTableModule } from '@angular/material/table'; import { MatIconModule } from '@angular/material/icon'; import { MapComponent } from './components/map/map.component'; import { MapViewComponent } from './components/map-view/map-view.component'; import { TableComponent } from './components/table/table.component'; import { DataService } from './services/data.service'; import { PaneModule } from './components/pane/pane.module'; import { AirportTableComponent } from './components/airport-table/airport-table.component'; import { StyleEditorComponent } from './components/style-editor/style-editor.component'; import { LoginComponent } from './components/login/login.component'; import { AuthService } from './services/auth.service'; import { AuthGuard } from './guards/auth.guard'; import { PasswordComponent } from './components/identity/password/password.component'; import { UsernameComponent } from './components/identity/username/username.component'; import { ProfileComponent } from './components/identity/profile/profile.component'; import { MainLayoutComponent } from './components/layout/main-layout.component'; import { IxtTableModule, IxtTabsetModule } from '@dvanauken/ixtlan/dist/ixtlan'; import { UserDetailComponent } from './components/admin/user-detail/user-detail.component'; import { UsersComponent } from './components/admin/users/users.component'; import { RoleDetailComponent } from './components/admin/role-detail/role-detail.component'; import { RolesComponent } from './components/admin/roles/roles.component'; @NgModule({ declarations: [ AppComponent, MapComponent, TableComponent, AirportTableComponent, StyleEditorComponent, LoginComponent, MapViewComponent, MainLayoutComponent, UsernameComponent, PasswordComponent, ProfileComponent, UsernameComponent, UsersComponent, UserDetailComponent, RolesComponent, RoleDetailComponent ], imports: [ CommonModule, BrowserModule, BrowserAnimationsModule, HttpClientModule, FormsModule, ReactiveFormsModule, RouterModule, AppRoutingModule, PaneModule, MatTabsModule, MatTableModule, MatPaginatorModule, MatSortModule, MatIconModule, MatTooltipModule, IxtTableModule, IxtTabsetModule ], providers: [ DataService, AuthService, AuthGuard ], bootstrap: [AppComponent] }) export class AppModule { }
|   +-- assets
|   |   +-- 10m
|   |   |   +-- ne_10m_admin_0_boundary_lines_land.geojson
|   |   |   +-- ne_10m_airports.geojson
|   |   |   +-- ne_10m_graticules_30.geojson
|   |   |   +-- ne_10m_populated_places_simple.geojson
|   |   |   +-- ne_10m_railroads_north_america.geojson
|   |   |   \-- ne_10m_time_zones.geojson
|   |   +-- 110m
|   |   |   +-- countries.geojson
|   |   |   +-- lakes.geojson
|   |   |   +-- ne_110m_admin_0_countries_lakes.geojson
|   |   |   +-- ne_110m_admin_1_states_provinces.geojson
|   |   |   +-- ne_110m_coastline.geojson
|   |   |   +-- ne_110m_lakes.geojson
|   |   |   +-- ne_110m_land.geojson
|   |   |   +-- ne_110m_ocean.geojson
|   |   |   +-- ne_110m_populated_places.geojson
|   |   |   +-- ne_110m_populated_places_simple.geojson
|   |   |   +-- ne_110m_rivers_lake_centerlines.geojson
|   |   |   +-- test.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Geographical Projection</title> <script src="https://d3js.org/d3.v6.min.js"></script> <style> svg { width: 100%; height: auto; } </style> </head> <body> <svg></svg> <script> // Constants const R = 6371; // Mean radius of the Earth in kilometers function perspectiveProjection(P, φ0, λ0) { return function(λ, φ) { const φRad = φ * Math.PI / 180; const λRad = λ * Math.PI / 180; const φ0Rad = φ0 * Math.PI / 180; const λ0Rad = λ0 * Math.PI / 180; const cosC = Math.sin(φ0Rad) * Math.sin(φRad) + Math.cos(φ0Rad) * Math.cos(φRad) * Math.cos(λRad - λ0Rad); if (cosC < 1 / P) { return [NaN, NaN]; // Reject points outside the projection } const k = (P - 1) / (P * Math.cos(cosC) - 1); const x = R * k * Math.cos(φRad) * Math.sin(λRad - λ0Rad); const y = R * k * (Math.cos(φ0Rad) * Math.sin(φRad) - Math.sin(φ0Rad) * Math.cos(φRad) * Math.cos(λRad - λ0Rad)); return [x, y]; }; } const projection = perspectiveProjection(2, 0, 0); // P = 2, φ0 = 0, λ0 = 0 console.log(typeof projection); // Check if it's a function const svg = d3.select("svg"); const path = d3.geoPath().projection(projection); d3.json("countries.geojson").then(data => { console.log(data); // Inspect the data structure svg.selectAll("path") .data(data.features) .enter().append("path") .attr("d", path) .attr("fill", "steelblue") .attr("stroke", "black"); }).catch(error => { console.error("Error loading the GeoJSON data:", error); }); </script> </body> </html>
|   |   |   \-- world-110m.v1.json
|   |   +-- 50m
|   |   |   +-- ne_50m_land.geojson
|   |   |   +-- ne_50m_ocean.geojson
|   |   |   +-- ne_50m_populated_places_simple.geojson
|   |   |   \-- ne_50m_urban_areas.geojson
|   |   +-- styles
|   |   |   \-- map.svg.css
|   |   +-- .gitkeep
|   |   +-- Airline.json
|   |   +-- Airport.json
|   |   +-- logo.png
|   |   +-- logo2.png
|   |   +-- moscow.geojson
|   |   +-- pa.csv
|   |   +-- routes.json
|   |   \-- spinner.gif
|   +-- favicon.ico
|   +-- index.html: <!doctype html> <html lang="en"> <head> <meta charset="utf-8" /> <title>GeoView</title> <base href="/" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <link rel="icon" type="image/x-icon" href="favicon.ico" /> <link rel="preconnect" href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> </head> <body class="mat-typography"> <app-root></app-root> </body> </html>
|   +-- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) => console.error(err));
|   \-- styles.scss: /* styles.scss */ html, body { height: 100vh; margin: 0; padding: 0; overflow: hidden; background-color: #f5f5f5; } // Login layout .login-container { height: 100vh; display: flex; justify-content: center; align-items: center; background: #f5f5f5; } // Main app layout main { display: grid; grid-template-areas: "nav header header" "nav section aside" "nav footer footer"; grid-template-columns: 300px 1fr 300px; grid-template-rows: 100px 1fr 80px; height: 100vh; gap: 8px; padding: 8px; background: #f0f0f0; } nav { grid-area: nav; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); a { display: block; padding: 0.75rem 1rem; text-decoration: none; color: #333; border-radius: 4px; margin-bottom: 0.5rem; &:hover { background: #f5f5f5; } &.active { background: #007bff; color: white; } } } header { grid-area: header; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } section { grid-area: section; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: auto; } aside { grid-area: aside; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } footer { grid-area: footer; background: white; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
+-- .editorconfig
+-- .gitignore
+-- .npmrc
+-- Figure37.png
+-- README.md
+-- Snyder 1994 Map_Projections_a_Working_Manual.pdf
+-- angular.json
+-- clean.ps1
+-- clean2.ps1
+-- error.txt
+-- package-lock.json
+-- package.json
+-- summary.bat
+-- tag.bat
+-- tag.py
+-- test.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Geographical Projection</title> <script src="https://d3js.org/d3.v6.min.js"></script> <style> svg { width: 100%; height: auto; } </style> </head> <body> <svg width="800" height="600"></svg> <script> // Constants const R = 6371; // Mean radius of the Earth in kilometers // Custom perspective projection function perspectiveProjection(P, φ0, λ0) { return function(λ, φ) { const φRad = φ * Math.PI / 180; const λRad = λ * Math.PI / 180; const φ0Rad = φ0 * Math.PI / 180; const λ0Rad = λ0 * Math.PI / 180; const cosC = Math.sin(φ0Rad) * Math.sin(φRad) + Math.cos(φ0Rad) * Math.cos(φRad) * Math.cos(λRad - λ0Rad); if (cosC < 1 / P) { return [NaN, NaN]; // Reject points outside the projection } const k = (P - 1) / (P * cosC - 1); const x = R * k * Math.cos(φRad) * Math.sin(λRad - λ0Rad); const y = R * k * (Math.cos(φ0Rad) * Math.sin(φRad) - Math.sin(φ0Rad) * Math.cos(φRad) * Math.cos(λRad - λ0Rad)); return [x, y]; }; } // Wrap the custom projection with d3.geoProjection const projection = d3.geoProjection(perspectiveProjection(2, 0, 0)) .scale(1) // Scale down the projection to fit the SVG .translate([400, 300]); // Center the map in an 800x600 SVG const svg = d3.select("svg"); const path = d3.geoPath().projection(projection); // Load GeoJSON data d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson").then(data => { console.log(data); // Inspect the data structure svg.selectAll("path") .data(data.features) .enter().append("path") .attr("d", path) .attr("fill", "steelblue") .attr("stroke", "black"); }).catch(error => { console.error("Error loading the GeoJSON data:", error); }); </script> </body> </html>
+-- test10.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Tilted Perspective Projection with Zoom and Graticule</title> <script src="https://d3js.org/d3.v7.min.js"></script> <style> body { font-family: Arial, sans-serif; } svg { display: block; margin: auto; background-color: #f0f0f0; } .controls { display: flex; justify-content: center; gap: 20px; margin: 20px; } .controls label { display: block; } .controls input { width: 80px; } </style> </head> <body> <h1 style="text-align: center;">Tilted Perspective Projection with Zoom and Graticule</h1> <div class="controls"> <div> <label> Longitude Center <input type="number" id="longitude" value="-74" step="1"> </label> </div> <div> <label> Latitude Center <input type="number" id="latitude" value="41.5" step="1"> </label> </div> <div> <label> Tilt (Degrees) <input type="number" id="tilt" value="55" step="1"> </label> </div> <div> <label> Yaw (Degrees) <input type="number" id="yaw" value="210" step="1"> </label> </div> <div> <label> Perspective Distance (P) <input type="number" id="distance" value="1.025" step="0.01"> </label> </div> <div> <label> Earth Radius (R) <input type="number" id="radius" value="6371" step="100"> </label> </div> <button id="update">Update Projection</button> </div> <svg width="800" height="600"></svg> <script> function geoTiltedPerspective() { let lambda0 = -74, // Longitude of projection center phi0 = 41.5, // Latitude of projection center omega = 55, // Tilt angle in degrees gamma = 210, // Yaw angle in degrees R = 6371, // Earth's radius in kilometers P = 1.025; // Perspective distance (relative to Earth's radius) function projection(lambda, phi) { const rad = Math.PI / 180; lambda *= rad; phi *= rad; const lambda0Rad = lambda0 * rad; const phi0Rad = phi0 * rad; const omegaRad = omega * rad; const gammaRad = gamma * rad; const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi); const sinPhi0 = Math.sin(phi0Rad), cosPhi0 = Math.cos(phi0Rad); const cosC = sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad); if (cosC < 1 / P) return null; const kPrime = (P - 1) / (P - cosC); const x = R * kPrime * Math.cos(phi) * Math.sin(lambda - lambda0Rad); const y = R * kPrime * (cosPhi0 * sinPhi - sinPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const z = R * kPrime * (sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const xt = x; const yt = y * Math.cos(omegaRad) - z * Math.sin(omegaRad); const zt = y * Math.sin(omegaRad) + z * Math.cos(omegaRad); const xFinal = xt * Math.cos(gammaRad) - yt * Math.sin(gammaRad); const yFinal = xt * Math.sin(gammaRad) + yt * Math.cos(gammaRad); return [xFinal, yFinal]; } projection.stream = function(outputStream) { return { point: function(lambda, phi) { const point = projection(lambda, phi); if (point) outputStream.point(point[0], point[1]); }, lineStart: function() { outputStream.lineStart(); }, lineEnd: function() { outputStream.lineEnd(); }, polygonStart: function() { outputStream.polygonStart(); }, polygonEnd: function() { outputStream.polygonEnd(); } }; }; projection.center = function([lambda, phi]) { if (!arguments.length) return [lambda0, phi0]; lambda0 = lambda; phi0 = phi; return projection; }; projection.tilt = function(value) { if (!arguments.length) return omega; omega = value; return projection; }; projection.yaw = function(value) { if (!arguments.length) return gamma; gamma = value; return projection; }; projection.perspectiveDistance = function(value) { if (!arguments.length) return P; P = value; return projection; }; projection.radius = function(value) { if (!arguments.length) return R; R = value; return projection; }; return projection; } const svg = d3.select("svg"); const width = +svg.attr("width"); const height = +svg.attr("height"); const projection = geoTiltedPerspective() .center([-74, 41.5]) // Newburgh, NY .tilt(55) // Tilt angle .yaw(210) // Yaw angle .perspectiveDistance(1.025) .radius(6371); const path = d3.geoPath().projection(projection); const g = svg.append("g"); const graticule = d3.geoGraticule().step([10, 10]); // 10-degree graticule const updateMap = () => { g.selectAll("*").remove(); // Clear the map and graticule // Draw graticule g.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc"); // Draw map d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(geojson => { g.selectAll("path.map") .data(geojson.features) .join("path") .attr("class", "map") .attr("d", path) .attr("fill", "#69b3a2") .attr("stroke", "#333"); }); }; document.getElementById("update").addEventListener("click", () => { const lambda = +document.getElementById("longitude").value; const phi = +document.getElementById("latitude").value; const omega = +document.getElementById("tilt").value; const gamma = +document.getElementById("yaw").value; const P = +document.getElementById("distance").value; const R = +document.getElementById("radius").value; projection .center([lambda, phi]) .tilt(omega) .yaw(gamma) .perspectiveDistance(P) .radius(R); updateMap(); }); const zoom = d3.zoom() .scaleExtent([0.5, 10]) // Set zoom range .on("zoom", function (event) { g.attr("transform", event.transform); }); svg.call(zoom); updateMap(); </script> </body> </html>
+-- test11.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Tilted Perspective Projection with Zoom and Graticule</title> <script src="https://d3js.org/d3.v7.min.js"></script> <style> body { font-family: Arial, sans-serif; } svg { display: block; margin: auto; background-color: #f0f0f0; } .controls { display: flex; justify-content: center; gap: 20px; margin: 20px; } .controls label { display: block; } .controls input { width: 80px; } </style> </head> <body> <h1 style="text-align: center;">Tilted Perspective Projection with Zoom and Graticule</h1> <div class="controls"> <div> <label> Longitude Center <input type="number" id="longitude" value="-74" step="1"> </label> </div> <div> <label> Latitude Center <input type="number" id="latitude" value="41.5" step="1"> </label> </div> <div> <label> Tilt (Degrees) <input type="number" id="tilt" value="55" step="1"> </label> </div> <div> <label> Yaw (Degrees) <input type="number" id="yaw" value="210" step="1"> </label> </div> <div> <label> Perspective Distance (P) <input type="number" id="distance" value="1.025" step="0.01"> </label> </div> <div> <label> Earth Radius (R) <input type="number" id="radius" value="6371" step="100"> </label> </div> <button id="update">Update Projection</button> </div> <svg width="800" height="600"></svg> <script> function geoTiltedPerspective() { let lambda0 = -74, // Longitude of projection center phi0 = 41.5, // Latitude of projection center omega = 55, // Tilt angle in degrees gamma = 210, // Yaw angle in degrees R = 6371, // Earth's radius in kilometers P = 1.025; // Perspective distance (relative to Earth's radius) function projection(lambda, phi) { const rad = Math.PI / 180; lambda *= rad; phi *= rad; const lambda0Rad = lambda0 * rad; const phi0Rad = phi0 * rad; const omegaRad = omega * rad; const gammaRad = gamma * rad; const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi); const sinPhi0 = Math.sin(phi0Rad), cosPhi0 = Math.cos(phi0Rad); const cosC = sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad); if (cosC < 1 / P) return null; // Clip points outside visible hemisphere const kPrime = (P - 1) / (P - cosC); const x = R * kPrime * Math.cos(phi) * Math.sin(lambda - lambda0Rad); const y = R * kPrime * (cosPhi0 * sinPhi - sinPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const z = R * kPrime * (sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const xt = x; const yt = y * Math.cos(omegaRad) - z * Math.sin(omegaRad); const zt = y * Math.sin(omegaRad) + z * Math.cos(omegaRad); const xFinal = xt * Math.cos(gammaRad) - yt * Math.sin(gammaRad); const yFinal = xt * Math.sin(gammaRad) + yt * Math.cos(gammaRad); return [xFinal, yFinal]; } projection.stream = function(outputStream) { return { point: function(lambda, phi) { const point = projection(lambda, phi); if (point) outputStream.point(point[0], point[1]); }, lineStart: function() { outputStream.lineStart(); }, lineEnd: function() { outputStream.lineEnd(); }, polygonStart: function() { outputStream.polygonStart(); }, polygonEnd: function() { outputStream.polygonEnd(); } }; }; projection.center = function([lambda, phi]) { if (!arguments.length) return [lambda0, phi0]; lambda0 = lambda; phi0 = phi; return projection; }; projection.tilt = function(value) { if (!arguments.length) return omega; omega = value; return projection; }; projection.yaw = function(value) { if (!arguments.length) return gamma; gamma = value; return projection; }; projection.perspectiveDistance = function(value) { if (!arguments.length) return P; P = value; return projection; }; projection.radius = function(value) { if (!arguments.length) return R; R = value; return projection; }; return projection; } const svg = d3.select("svg"); const width = +svg.attr("width"); const height = +svg.attr("height"); const projection = geoTiltedPerspective() .center([-74, 41.5]) // Newburgh, NY .tilt(55) // Tilt angle .yaw(210) // Yaw angle .perspectiveDistance(1.025) .radius(6371); const path = d3.geoPath().projection(projection); const g = svg.append("g"); const graticule = d3.geoGraticule().step([10, 10]); // 10-degree graticule const updateMap = () => { g.selectAll("*").remove(); // Clear the map and graticule // Draw graticule g.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc"); // Draw map d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(geojson => { g.selectAll("path.map") .data(geojson.features) .join("path") .attr("class", "map") .attr("d", path) .attr("fill", "#69b3a2") .attr("stroke", "#333"); }); }; document.getElementById("update").addEventListener("click", () => { const lambda = +document.getElementById("longitude").value; const phi = +document.getElementById("latitude").value; const omega = +document.getElementById("tilt").value; const gamma = +document.getElementById("yaw").value; const P = +document.getElementById("distance").value; const R = +document.getElementById("radius").value; projection .center([lambda, phi]) .tilt(omega) .yaw(gamma) .perspectiveDistance(P) .radius(R); updateMap(); }); const zoom = d3.zoom() .scaleExtent([0.5, 10]) // Set zoom range .on("zoom", function (event) { g.attr("transform", event.transform); }); svg.call(zoom); updateMap(); </script> </body> </html>
+-- test12.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Tilted Perspective Projection with Graticule and Full Extent</title> <script src="https://d3js.org/d3.v7.min.js"></script> <style> body { font-family: Arial, sans-serif; } svg { display: block; margin: auto; background-color: #f0f0f0; } .controls { display: flex; justify-content: center; gap: 20px; margin: 20px; } .controls label { display: block; } .controls input { width: 80px; } button { margin: 5px; } </style> </head> <body> <h1 style="text-align: center;">Tilted Perspective Projection with Graticule and Full Extent</h1> <div class="controls"> <div> <label> Longitude Center <input type="number" id="longitude" value="-74" step="1"> </label> </div> <div> <label> Latitude Center <input type="number" id="latitude" value="41.5" step="1"> </label> </div> <div> <label> Tilt (Degrees) <input type="number" id="tilt" value="55" step="1"> </label> </div> <div> <label> Yaw (Degrees) <input type="number" id="yaw" value="210" step="1"> </label> </div> <div> <label> Perspective Distance (P) <input type="number" id="distance" value="1.025" step="0.01"> </label> </div> <div> <label> Earth Radius (R) <input type="number" id="radius" value="6371" step="100"> </label> </div> <button id="update">Update Projection</button> <button id="zoom-extent">Zoom to Full Extent</button> </div> <svg width="800" height="600"></svg> <script> function geoTiltedPerspective() { let lambda0 = -74, // Longitude of projection center phi0 = 41.5, // Latitude of projection center omega = 55, // Tilt angle in degrees gamma = 210, // Yaw angle in degrees R = 6371, // Earth's radius in kilometers P = 1.025; // Perspective distance (relative to Earth's radius) function projection(lambda, phi) { const rad = Math.PI / 180; lambda *= rad; phi *= rad; const lambda0Rad = lambda0 * rad; const phi0Rad = phi0 * rad; const omegaRad = omega * rad; const gammaRad = gamma * rad; const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi); const sinPhi0 = Math.sin(phi0Rad), cosPhi0 = Math.cos(phi0Rad); const cosC = sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad); if (cosC < 1 / P) return null; // Clip points outside visible hemisphere const kPrime = (P - 1) / (P - cosC); if (!isFinite(kPrime)) return null; // Avoid invalid scale factors const x = R * kPrime * Math.cos(phi) * Math.sin(lambda - lambda0Rad); const y = R * kPrime * (cosPhi0 * sinPhi - sinPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const z = R * kPrime * (sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const xt = x; const yt = y * Math.cos(omegaRad) - z * Math.sin(omegaRad); const zt = y * Math.sin(omegaRad) + z * Math.cos(omegaRad); const xFinal = xt * Math.cos(gammaRad) - yt * Math.sin(gammaRad); const yFinal = xt * Math.sin(gammaRad) + yt * Math.cos(gammaRad); return [xFinal, yFinal]; } projection.stream = function(outputStream) { return { point: function(lambda, phi) { const point = projection(lambda, phi); if (point) outputStream.point(point[0], point[1]); }, lineStart: function() { outputStream.lineStart(); }, lineEnd: function() { outputStream.lineEnd(); }, polygonStart: function() { outputStream.polygonStart(); }, polygonEnd: function() { outputStream.polygonEnd(); } }; }; projection.center = function([lambda, phi]) { if (!arguments.length) return [lambda0, phi0]; lambda0 = lambda; phi0 = phi; return projection; }; projection.tilt = function(value) { if (!arguments.length) return omega; omega = value; return projection; }; projection.yaw = function(value) { if (!arguments.length) return gamma; gamma = value; return projection; }; projection.perspectiveDistance = function(value) { if (!arguments.length) return P; P = value; return projection; }; projection.radius = function(value) { if (!arguments.length) return R; R = value; return projection; }; return projection; } const svg = d3.select("svg"); const width = +svg.attr("width"); const height = +svg.attr("height"); const projection = geoTiltedPerspective() .center([-74, 41.5]) // Newburgh, NY .tilt(55) // Tilt angle .yaw(210) // Yaw angle .perspectiveDistance(1.025) .radius(6371); const path = d3.geoPath().projection(projection); const g = svg.append("g"); const graticule = d3.geoGraticule().step([10, 10]); // 10-degree graticule const updateMap = () => { g.selectAll("*").remove(); // Clear the map and graticule // Draw graticule g.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc"); // Draw map d3.json("https://github.com/datasets/geo-countries/blob/main/data/countries.geojson").then(geojson => { //d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(geojson => { g.selectAll("path.map") .data(geojson.features) .join("path") .attr("class", "map") .attr("d", path) .attr("fill", "#69b3a2") .attr("stroke", "#333"); }); }; const zoom = d3.zoom() .scaleExtent([0.5, 10]) // Set zoom range .on("zoom", function (event) { g.attr("transform", event.transform); }); svg.call(zoom); document.getElementById("update").addEventListener("click", () => { const lambda = +document.getElementById("longitude").value; const phi = +document.getElementById("latitude").value; const omega = +document.getElementById("tilt").value; const gamma = +document.getElementById("yaw").value; const P = +document.getElementById("distance").value; const R = +document.getElementById("radius").value; projection .center([lambda, phi]) .tilt(omega) .yaw(gamma) .perspectiveDistance(P) .radius(R); updateMap(); }); document.getElementById("zoom-extent").addEventListener("click", () => { const bounds = g.node().getBBox(); const dx = bounds.width, dy = bounds.height, x = bounds.x + dx / 2, y = bounds.y + dy / 2, scale = 0.9 / Math.max(dx / width, dy / height), translate = [width / 2 - scale * x, height / 2 - scale * y]; svg.transition() .duration(750) .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)); }); updateMap(); </script> </body> </html>
+-- test14.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Load Local File with Tilted Perspective Projection</title> <script src="https://d3js.org/d3.v7.min.js"></script> <style> body { font-family: Arial, sans-serif; } svg { display: block; margin: auto; background-color: #f0f0f0; } .controls { display: flex; justify-content: center; gap: 20px; margin: 20px; } .controls label { display: block; } .controls input { width: 80px; } button { margin: 5px; } </style> </head> <body> <h1 style="text-align: center;">Load Local File with Tilted Perspective Projection</h1> <div class="controls"> <div> <label> Longitude Center <input type="number" id="longitude" value="-74" step="1"> </label> </div> <div> <label> Latitude Center <input type="number" id="latitude" value="41.5" step="1"> </label> </div> <div> <label> Tilt (Degrees) <input type="number" id="tilt" value="55" step="1"> </label> </div> <div> <label> Yaw (Degrees) <input type="number" id="yaw" value="210" step="1"> </label> </div> <div> <label> Perspective Distance (P) <input type="number" id="distance" value="1.025" step="0.01"> </label> </div> <div> <label> Earth Radius (R) <input type="number" id="radius" value="6371" step="100"> </label> </div> <button id="update">Update Projection</button> <button id="zoom-extent">Zoom to Full Extent</button> <input type="file" id="fileInput" accept=".geojson" style="margin-left: 20px;"> </div> <svg width="800" height="600"></svg> <script> function geoTiltedPerspective() { let lambda0 = -74, // Longitude of projection center phi0 = 41.5, // Latitude of projection center omega = 55, // Tilt angle in degrees gamma = 210, // Yaw angle in degrees R = 6371, // Earth's radius in kilometers P = 1.025; // Perspective distance (relative to Earth's radius) function projection(lambda, phi) { const rad = Math.PI / 180; lambda *= rad; phi *= rad; const lambda0Rad = lambda0 * rad; const phi0Rad = phi0 * rad; const omegaRad = omega * rad; const gammaRad = gamma * rad; const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi); const sinPhi0 = Math.sin(phi0Rad), cosPhi0 = Math.cos(phi0Rad); const cosC = sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad); if (cosC < 1 / P) return null; // Clip points outside visible hemisphere const kPrime = (P - 1) / (P - cosC); if (!isFinite(kPrime)) return null; // Avoid invalid scale factors const x = R * kPrime * Math.cos(phi) * Math.sin(lambda - lambda0Rad); const y = R * kPrime * (cosPhi0 * sinPhi - sinPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const z = R * kPrime * (sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const xt = x; const yt = y * Math.cos(omegaRad) - z * Math.sin(omegaRad); const zt = y * Math.sin(omegaRad) + z * Math.cos(omegaRad); const xFinal = xt * Math.cos(gammaRad) - yt * Math.sin(gammaRad); const yFinal = xt * Math.sin(gammaRad) + yt * Math.cos(gammaRad); return [xFinal, yFinal]; } projection.stream = function(outputStream) { return { point: function(lambda, phi) { const point = projection(lambda, phi); if (point) outputStream.point(point[0], point[1]); }, lineStart: function() { outputStream.lineStart(); }, lineEnd: function() { outputStream.lineEnd(); }, polygonStart: function() { outputStream.polygonStart(); }, polygonEnd: function() { outputStream.polygonEnd(); } }; }; projection.center = function([lambda, phi]) { if (!arguments.length) return [lambda0, phi0]; lambda0 = lambda; phi0 = phi; return projection; }; projection.tilt = function(value) { if (!arguments.length) return omega; omega = value; return projection; }; projection.yaw = function(value) { if (!arguments.length) return gamma; gamma = value; return projection; }; projection.perspectiveDistance = function(value) { if (!arguments.length) return P; P = value; return projection; }; projection.radius = function(value) { if (!arguments.length) return R; R = value; return projection; }; return projection; } const svg = d3.select("svg"); const width = +svg.attr("width"); const height = +svg.attr("height"); const projection = geoTiltedPerspective() .center([-74, 41.5]) // Newburgh, NY .tilt(55) // Tilt angle .yaw(210) // Yaw angle .perspectiveDistance(1.025) .radius(6371); const path = d3.geoPath().projection(projection); const g = svg.append("g"); const updateMap = (geojson) => { g.selectAll("*").remove(); // Clear the map and graticule // Draw map g.selectAll("path.map") .data(geojson.features) .join("path") .attr("class", "map") .attr("d", path) .attr("fill", "#69b3a2") .attr("stroke", "#333"); }; const zoom = d3.zoom() .scaleExtent([0.5, 10]) // Set zoom range .on("zoom", function (event) { g.attr("transform", event.transform); }); svg.call(zoom); document.getElementById("update").addEventListener("click", () => { const lambda = +document.getElementById("longitude").value; const phi = +document.getElementById("latitude").value; const omega = +document.getElementById("tilt").value; const gamma = +document.getElementById("yaw").value; const P = +document.getElementById("distance").value; const R = +document.getElementById("radius").value; projection .center([lambda, phi]) .tilt(omega) .yaw(gamma) .perspectiveDistance(P) .radius(R); updateMap(currentGeoJSON); }); let currentGeoJSON = null; document.getElementById("fileInput").addEventListener("change", (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { const geojson = JSON.parse(e.target.result); currentGeoJSON = geojson; updateMap(geojson); }; reader.readAsText(file); } }); </script> </body> </html>
+-- test2.html: <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>General Perspective Projection</title> <script defer src="https://d3js.org/d3.v7.min.js"></script> </head> <body> <script> window.addEventListener('DOMContentLoaded', (event) => { function generalPerspective() { let distance = 2; let scale = 250; let translate = [480, 250]; let center = [0, 0]; function projection(coordinates) { const [lambda, phi] = coordinates.map(d => d * Math.PI / 180); const [lambda0, phi0] = center.map(d => d * Math.PI / 180); const cosc = Math.sin(phi0) * Math.sin(phi) + Math.cos(phi0) * Math.cos(phi) * Math.cos(lambda - lambda0); if (cosc < 1.0 / distance) return null; const k = (distance - 1.0) / (distance - cosc); const x = k * Math.cos(phi) * Math.sin(lambda - lambda0); const y = k * (Math.cos(phi0) * Math.sin(phi) - Math.sin(phi0) * Math.cos(phi) * Math.cos(lambda - lambda0)); return [x * scale + translate[0], -y * scale + translate[1]]; } projection.distance = function(_) { return arguments.length ? (distance = +_, projection) : distance; }; projection.scale = function(_) { return arguments.length ? (scale = +_, projection) : scale; }; projection.translate = function(_) { return arguments.length ? (translate = _, projection) : translate; }; projection.center = function(_) { return arguments.length ? (center = _, projection) : center; }; projection.invert = function(_) { const x = (_[0] - translate[0]) / scale; const y = -(_[1] - translate[1]) / scale; const rho = Math.sqrt(x * x + y * y); const c = Math.atan(rho); const sinC = Math.sin(c); const cosC = Math.cos(c); const lambda0 = center[0] * Math.PI / 180; const phi0 = center[1] * Math.PI / 180; const phi = Math.asin(cosC * Math.sin(phi0) + (y * sinC * Math.cos(phi0)) / (rho || 1)); const lambda = lambda0 + Math.atan2(x * sinC, rho * Math.cos(phi0) * cosC - y * Math.sin(phi0) * sinC); return [lambda * 180 / Math.PI, phi * 180 / Math.PI]; }; projection.stream = function(stream) { // This is a placeholder stream method to make it D3-compatible. // We can use d3.geoTransform to create a stream transformer. return d3.geoTransform({ point: function(x, y) { const point = projection([x, y]); if (point) stream.point(point[0], point[1]); } }).stream(stream); }; return projection; } const width = window.innerWidth - 40; const height = window.innerHeight - 40; const svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); const projection = generalPerspective() .scale(250) .translate([width / 2, height / 2]) .center([0, 0]); const path = d3.geoPath().projection(projection); const graticule = d3.geoGraticule(); // Load GeoJSON data d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson") .then(data => { if (data && data.features) { svg.selectAll("path") .data(data.features) .enter().append("path") .attr("d", path) .attr("fill", "steelblue") .attr("stroke", "black"); } else { console.error("Invalid GeoJSON data:", data); } }) .catch(error => { console.error("Error loading the GeoJSON data:", error); }); }); </script> </body> </html>
+-- test3.html: <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>General Perspective Projection</title> <script defer src="https://d3js.org/d3.v7.min.js"></script> </head> <body> <script> window.addEventListener('DOMContentLoaded', (event) => { function generalPerspective() { let distance = 1.025; let scale = 250; let translate = [480, 250]; let center = [0, 0]; let tilt = 55; let azimuth = 210; let rotate = [0, 0, 0]; function projection(coordinates) { const [lambda, phi] = coordinates.map(d => d * Math.PI / 180); const [lambda0, phi0] = center.map(d => d * Math.PI / 180); const cosc = Math.sin(phi0) * Math.sin(phi) + Math.cos(phi0) * Math.cos(phi) * Math.cos(lambda - lambda0); if (cosc < 1.0 / distance) return null; const k = (distance - 1.0) / (distance - cosc); const x = k * Math.cos(phi) * Math.sin(lambda - lambda0); const y = k * (Math.cos(phi0) * Math.sin(phi) - Math.sin(phi0) * Math.cos(phi) * Math.cos(lambda - lambda0)); return [x * scale + translate[0], -y * scale + translate[1]]; } projection.distance = function(_) { return arguments.length ? (distance = +_, projection) : distance; }; projection.scale = function(_) { return arguments.length ? (scale = +_, projection) : scale; }; projection.translate = function(_) { return arguments.length ? (translate = _, projection) : translate; }; projection.center = function(_) { return arguments.length ? (center = _, projection) : center; }; projection.tilt = function(_) { return arguments.length ? (tilt = +_, projection) : tilt; }; projection.azimuth = function(_) { return arguments.length ? (azimuth = +_, projection) : azimuth; }; projection.rotate = function(_) { return arguments.length ? (rotate = _, projection) : rotate; }; projection.invert = function(_) { const x = (_[0] - translate[0]) / scale; const y = -(_[1] - translate[1]) / scale; const rho = Math.sqrt(x * x + y * y); const c = Math.atan(rho); const sinC = Math.sin(c); const cosC = Math.cos(c); const lambda0 = center[0] * Math.PI / 180; const phi0 = center[1] * Math.PI / 180; const phi = Math.asin(cosC * Math.sin(phi0) + (y * sinC * Math.cos(phi0)) / (rho || 1)); const lambda = lambda0 + Math.atan2(x * sinC, rho * Math.cos(phi0) * cosC - y * Math.sin(phi0) * sinC); return [lambda * 180 / Math.PI, phi * 180 / Math.PI]; }; projection.stream = function(stream) { return d3.geoTransform({ point: function(x, y) { const point = projection([x, y]); if (point) stream.point(point[0], point[1]); } }).stream(stream); }; return projection; } const width = window.innerWidth - 40; const height = window.innerHeight - 40; const svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); const projection = generalPerspective() .distance(1.025) .tilt(55) .azimuth(210) .scale(Math.min(width, height) / 2) .translate([width / 2, height / 2]) .center([0, 0]) .rotate([74, -41.5, 0]); const path = d3.geoPath().projection(projection); const graticule = d3.geoGraticule(); d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson").then(data => { if (data && data.features) { svg.selectAll("path") .data(data.features) .enter().append("path") .attr("d", path) .attr("fill", "steelblue") .attr("stroke", "black"); } else { console.error("Invalid GeoJSON data:", data); } }).catch(error => { console.error("Error loading the GeoJSON data:", error); }); }); </script> </body> </html>
+-- test4.html: <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>General Perspective Projection</title> <script defer src="https://d3js.org/d3.v7.min.js"></script> </head> <body> <script> window.addEventListener('DOMContentLoaded', (event) => { function generalPerspective() { let distance = 1.025; let scale = 250; let translate = [480, 250]; let center = [0, 0]; let tilt = 55; let azimuth = 210; let rotate = [0, 0, 0]; function projection(coordinates) { const [lambda, phi] = coordinates.map(d => d * Math.PI / 180); const [lambda0, phi0] = center.map(d => d * Math.PI / 180); const cosc = Math.sin(phi0) * Math.sin(phi) + Math.cos(phi0) * Math.cos(phi) * Math.cos(lambda - lambda0); if (cosc < 1.0 / distance) return null; const k = (distance - 1.0) / (distance - cosc); const x = k * Math.cos(phi) * Math.sin(lambda - lambda0); const y = k * (Math.cos(phi0) * Math.sin(phi) - Math.sin(phi0) * Math.cos(phi) * Math.cos(lambda - lambda0)); return [x * scale + translate[0], -y * scale + translate[1]]; } projection.distance = function(_) { return arguments.length ? (distance = +_, projection) : distance; }; projection.scale = function(_) { return arguments.length ? (scale = +_, projection) : scale; }; projection.translate = function(_) { return arguments.length ? (translate = _, projection) : translate; }; projection.center = function(_) { return arguments.length ? (center = _, projection) : center; }; projection.tilt = function(_) { return arguments.length ? (tilt = +_, projection) : tilt; }; projection.azimuth = function(_) { return arguments.length ? (azimuth = +_, projection) : azimuth; }; projection.rotate = function(_) { return arguments.length ? (rotate = _, projection) : rotate; }; projection.invert = function(_) { const x = (_[0] - translate[0]) / scale; const y = -(_[1] - translate[1]) / scale; const rho = Math.sqrt(x * x + y * y); const c = Math.atan(rho); const sinC = Math.sin(c); const cosC = Math.cos(c); const lambda0 = center[0] * Math.PI / 180; const phi0 = center[1] * Math.PI / 180; const phi = Math.asin(cosC * Math.sin(phi0) + (y * sinC * Math.cos(phi0)) / (rho || 1)); const lambda = lambda0 + Math.atan2(x * sinC, rho * Math.cos(phi0) * cosC - y * Math.sin(phi0) * sinC); return [lambda * 180 / Math.PI, phi * 180 / Math.PI]; }; projection.stream = function(stream) { return { point: function(x, y) { const point = projection([x, y]); if (point) stream.point(point[0], point[1]); }, sphere: function() { stream.sphere(); }, lineStart: function() { stream.lineStart(); }, lineEnd: function() { stream.lineEnd(); }, polygonStart: function() { stream.polygonStart(); }, polygonEnd: function() { stream.polygonEnd(); } }; }; return projection; } const width = window.innerWidth - 40; const height = window.innerHeight - 40; const svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); // Add a circle for clipping svg.append("defs") .append("clipPath") .attr("id", "circle-clip") .append("circle") .attr("cx", width / 2) .attr("cy", height / 2) .attr("r", Math.min(width, height) / 2.2); const projection = generalPerspective() .distance(1.1) .tilt(55) .azimuth(210) .scale(Math.min(width, height) / 2) .translate([width / 2, height / 2]) .center([0, 0]) .rotate([74, -41.5, 0]); const path = d3.geoPath().projection(projection); const graticule = d3.geoGraticule(); // Create a group for all map elements and apply the clip path const mapGroup = svg.append("g") .attr("clip-path", "url(#circle-clip)"); // Add graticule to the clipped group mapGroup.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc") .attr("stroke-width", 0.5); // Add countries to the clipped group d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson") .then(data => { if (data && data.features) { mapGroup.selectAll("path.country") .data(data.features) .enter() .append("path") .attr("class", "country") .attr("d", d => { try { const pathData = path(d); return pathData || ""; } catch (e) { console.warn("Error generating path for feature:", d); return ""; } }) .attr("fill", "steelblue") .attr("stroke", "white") .attr("stroke-width", 0.5); } }) .catch(error => { console.error("Error loading the GeoJSON data:", error); svg.append("text") .attr("x", width / 2) .attr("y", height / 2) .attr("text-anchor", "middle") .text("Error loading map data"); }); // Add circle outline svg.append("circle") .attr("cx", width / 2) .attr("cy", height / 2) .attr("r", Math.min(width, height) / 2.2) .attr("fill", "none") .attr("stroke", "#000") .attr("stroke-width", 1); }); </script> </body> </html>
+-- test5.html: <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>General Perspective Projection</title> <script defer src="https://d3js.org/d3.v7.min.js"></script> </head> <body> <script> window.addEventListener('DOMContentLoaded', (event) => { function generalPerspective() { let distance = 1.025; let scale = 250; let translate = [480, 250]; let center = [45, 0]; let tilt = 55; let azimuth = 210; let rotate = [0, 45, 0]; function projection(coordinates) { // Apply rotation first let [lambda, phi] = coordinates; let [lambda_r, phi_r, gamma] = rotate; // Convert angles to radians lambda = lambda * Math.PI / 180; phi = phi * Math.PI / 180; lambda_r = lambda_r * Math.PI / 180; phi_r = phi_r * Math.PI / 180; gamma = gamma * Math.PI / 180; // Apply rotation const cos_phi = Math.cos(phi); const sin_phi = Math.sin(phi); const cos_lambda = Math.cos(lambda); const sin_lambda = Math.sin(lambda); const cos_phi_r = Math.cos(phi_r); const sin_phi_r = Math.sin(phi_r); const cos_lambda_r = Math.cos(lambda_r); const sin_lambda_r = Math.sin(lambda_r); const x1 = cos_phi * cos_lambda; const y1 = cos_phi * sin_lambda; const z1 = sin_phi; // Rotate around z axis (lambda) const x2 = x1 * cos_lambda_r + y1 * sin_lambda_r; const y2 = -x1 * sin_lambda_r + y1 * cos_lambda_r; const z2 = z1; // Rotate around x axis (phi) const x3 = x2; const y3 = y2 * cos_phi_r + z2 * sin_phi_r; const z3 = -y2 * sin_phi_r + z2 * cos_phi_r; // Apply tilt and azimuth const tilt_rad = tilt * Math.PI / 180; const azimuth_rad = azimuth * Math.PI / 180; const cos_tilt = Math.cos(tilt_rad); const sin_tilt = Math.sin(tilt_rad); const cos_azimuth = Math.cos(azimuth_rad); const sin_azimuth = Math.sin(azimuth_rad); const x4 = x3 * cos_azimuth - y3 * sin_azimuth; const y4 = x3 * sin_azimuth + y3 * cos_azimuth; const z4 = z3; const x5 = x4; const y5 = y4 * cos_tilt - z4 * sin_tilt; const z5 = y4 * sin_tilt + z4 * cos_tilt; // Perspective projection if (z5 >= distance) return null; const k = 1 / (distance - z5); return [ x5 * k * scale + translate[0], -y5 * k * scale + translate[1] ]; } projection.distance = function(_) { return arguments.length ? (distance = +_, projection) : distance; }; projection.scale = function(_) { return arguments.length ? (scale = +_, projection) : scale; }; projection.translate = function(_) { return arguments.length ? (translate = _, projection) : translate; }; projection.center = function(_) { return arguments.length ? (center = _, projection) : center; }; projection.tilt = function(_) { return arguments.length ? (tilt = +_, projection) : tilt; }; projection.azimuth = function(_) { return arguments.length ? (azimuth = +_, projection) : azimuth; }; projection.rotate = function(_) { return arguments.length ? (rotate = _, projection) : rotate; }; projection.stream = function(stream) { return { point: function(x, y) { const point = projection([x, y]); if (point) stream.point(point[0], point[1]); }, sphere: function() { stream.sphere(); }, lineStart: function() { stream.lineStart(); }, lineEnd: function() { stream.lineEnd(); }, polygonStart: function() { stream.polygonStart(); }, polygonEnd: function() { stream.polygonEnd(); } }; }; return projection; } const width = window.innerWidth - 40; const height = window.innerHeight - 40; const svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); // Add a circle for clipping svg.append("defs") .append("clipPath") .attr("id", "circle-clip") .append("circle") .attr("cx", width / 2) .attr("cy", height / 2) .attr("r", Math.min(width, height) / 2.2); const projection = generalPerspective() .distance(1.1) .tilt(55) .azimuth(210) .scale(Math.min(width, height) / 2) .translate([width / 2, height / 2]) .center([45, 0]) .rotate([74, -41.5, 0]); const path = d3.geoPath().projection(projection); const graticule = d3.geoGraticule(); // Create a group for all map elements and apply the clip path const mapGroup = svg.append("g") .attr("clip-path", "url(#circle-clip)"); // Add graticule to the clipped group mapGroup.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc") .attr("stroke-width", 0.5); // Add countries to the clipped group d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson") .then(data => { if (data && data.features) { mapGroup.selectAll("path.country") .data(data.features) .enter() .append("path") .attr("class", "country") .attr("d", d => { try { const pathData = path(d); return pathData || ""; } catch (e) { console.warn("Error generating path for feature:", d); return ""; } }) .attr("fill", "steelblue") .attr("stroke", "white") .attr("stroke-width", 0.5); } }) .catch(error => { console.error("Error loading the GeoJSON data:", error); svg.append("text") .attr("x", width / 2) .attr("y", height / 2) .attr("text-anchor", "middle") .text("Error loading map data"); }); }); </script> </body> </html>
+-- test6.html: <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>General Perspective Projection</title> <script defer src="https://d3js.org/d3.v7.min.js"></script> </head> <body> <script> window.addEventListener('DOMContentLoaded', (event) => { function generalPerspective() { // Using parameters from Snyder's Figure 37: // Point ~160 km above Newburgh, NY // φ₁ = 41°30'N lat., λ₀ = 74°00'W long. // tilt = 35°, P = 1.025 let distance = 1.025; // P value let scale = 250; let translate = [480, 250]; let center = [-74, 41.5]; // Newburgh, NY let tilt = 35; // Match Figure 37 tilt let azimuth = -10; // Adjusted to match view angle let rotate = [-74, -41.5, 0]; // Center on Newburgh // Rest of the projection code remains the same function projection(coordinates) { let [lambda, phi] = coordinates; let [lambda_r, phi_r, gamma] = rotate; // Convert angles to radians lambda = lambda * Math.PI / 180; phi = phi * Math.PI / 180; lambda_r = lambda_r * Math.PI / 180; phi_r = phi_r * Math.PI / 180; gamma = gamma * Math.PI / 180; // Apply rotation const cos_phi = Math.cos(phi); const sin_phi = Math.sin(phi); const cos_lambda = Math.cos(lambda); const sin_lambda = Math.sin(lambda); const cos_phi_r = Math.cos(phi_r); const sin_phi_r = Math.sin(phi_r); const cos_lambda_r = Math.cos(lambda_r); const sin_lambda_r = Math.sin(lambda_r); const x1 = cos_phi * cos_lambda; const y1 = cos_phi * sin_lambda; const z1 = sin_phi; // Rotate around z axis (lambda) const x2 = x1 * cos_lambda_r + y1 * sin_lambda_r; const y2 = -x1 * sin_lambda_r + y1 * cos_lambda_r; const z2 = z1; // Rotate around x axis (phi) const x3 = x2; const y3 = y2 * cos_phi_r + z2 * sin_phi_r; const z3 = -y2 * sin_phi_r + z2 * cos_phi_r; // Apply tilt and azimuth const tilt_rad = tilt * Math.PI / 180; const azimuth_rad = azimuth * Math.PI / 180; const cos_tilt = Math.cos(tilt_rad); const sin_tilt = Math.sin(tilt_rad); const cos_azimuth = Math.cos(azimuth_rad); const sin_azimuth = Math.sin(azimuth_rad); const x4 = x3 * cos_azimuth - y3 * sin_azimuth; const y4 = x3 * sin_azimuth + y3 * cos_azimuth; const z4 = z3; const x5 = x4; const y5 = y4 * cos_tilt - z4 * sin_tilt; const z5 = y4 * sin_tilt + z4 * cos_tilt; // Perspective projection if (z5 >= distance) return null; const k = 1 / (distance - z5); return [ x5 * k * scale + translate[0], -y5 * k * scale + translate[1] ]; } // Accessor methods remain the same... projection.distance = function(_) { return arguments.length ? (distance = +_, projection) : distance; }; projection.scale = function(_) { return arguments.length ? (scale = +_, projection) : scale; }; projection.translate = function(_) { return arguments.length ? (translate = _, projection) : translate; }; projection.center = function(_) { return arguments.length ? (center = _, projection) : center; }; projection.tilt = function(_) { return arguments.length ? (tilt = +_, projection) : tilt; }; projection.azimuth = function(_) { return arguments.length ? (azimuth = +_, projection) : azimuth; }; projection.rotate = function(_) { return arguments.length ? (rotate = _, projection) : rotate; }; // projection.stream = function(stream) { // return { // point: function(x, y) { // const point = projection([x, y]); // if (point) stream.point(point[0], point[1]); // }, // sphere: function() { stream.sphere(); }, // lineStart: function() { stream.lineStart(); }, // lineEnd: function() { stream.lineEnd(); }, // polygonStart: function() { stream.polygonStart(); }, // polygonEnd: function() { stream.polygonEnd(); } // }; // }; projection.stream = function(stream) { const epsilon = 1e-6; const infinity = 1e3; let visible; // Pre-compute rotation matrices for efficiency const rotationMatrix = computeRotationMatrix(rotate); const tiltMatrix = computeTiltMatrix(tilt, azimuth); function visible3d(x, y, z) { const k = distance - z; // Handle near and far clipping planes if (k < epsilon || k > infinity) return false; // Check if point is beyond horizon const cosC = x * x + y * y + z * z; if (cosC > 1 + epsilon) return false; // Handle points near the antipode const antipodalDist = 2 - cosC; if (antipodalDist < epsilon) return false; return true; } function project3d(lambda, phi) { // Convert from degrees to radians lambda *= Math.PI / 180; phi *= Math.PI / 180; // Convert to 3D cartesian const cosPhi = Math.cos(phi); const x = Math.cos(lambda) * cosPhi; const y = Math.sin(lambda) * cosPhi; const z = Math.sin(phi); // Apply rotation matrix const [x1, y1, z1] = multiplyMatrix(rotationMatrix, [x, y, z]); // Apply tilt and azimuth const [x2, y2, z2] = multiplyMatrix(tiltMatrix, [x1, y1, z1]); if (!visible3d(x2, y2, z2)) return null; // Project to 2D with perspective division const k = 1 / (distance - z2); return { x: x2 * k * scale + translate[0], y: -y2 * k * scale + translate[1], z: z2, k: k }; } // Line segment handler with adaptive sampling const line = { point0: null, point1: null, segment: [], size: 0, reset: function() { this.point0 = this.point1 = null; this.segment = []; this.size = 0; }, subdivide: function(lambda0, phi0, lambda1, phi1, depth) { if (depth > 8) return; // Maximum recursion depth const mid_lambda = (lambda0 + lambda1) / 2; const mid_phi = (phi0 + phi1) / 2; const p = project3d(mid_lambda, mid_phi); if (p) { // Check if subdivision is needed const dx = p.x - (this.point0.x + this.point1.x) / 2; const dy = p.y - (this.point0.y + this.point1.y) / 2; if (dx * dx + dy * dy > epsilon) { this.subdivide(lambda0, phi0, mid_lambda, mid_phi, depth + 1); this.segment.push(p); this.subdivide(mid_lambda, mid_phi, lambda1, phi1, depth + 1); } } } }; return { point: function(lambda, phi) { const p = project3d(lambda, phi); if (p) stream.point(p.x, p.y); }, lineStart: function() { line.reset(); visible = false; stream.lineStart(); }, lineEnd: function() { // Handle line segments that cross the horizon if (line.point0 && line.point1) { const segment = line.segment; for (let i = 0; i < segment.length; i++) { stream.point(segment[i].x, segment[i].y); } } if (visible) stream.lineEnd(); line.reset(); }, polygonStart: function() { visible = true; stream.polygonStart(); }, polygonEnd: function() { stream.polygonEnd(); }, sphere: function() { stream.sphere(); } }; // Helper functions function computeRotationMatrix([lambda, phi, gamma]) { // Convert to radians const [lr, pr, gr] = [lambda, phi, gamma].map(d => d * Math.PI / 180); const cosLambda = Math.cos(lr), sinLambda = Math.sin(lr); const cosPhi = Math.cos(pr), sinPhi = Math.sin(pr); const cosGamma = Math.cos(gr), sinGamma = Math.sin(gr); return [ [cosLambda * cosGamma - sinLambda * sinPhi * sinGamma, -cosLambda * sinGamma - sinLambda * sinPhi * cosGamma, -sinLambda * cosPhi], [sinLambda * cosGamma + cosLambda * sinPhi * sinGamma, -sinLambda * sinGamma + cosLambda * sinPhi * cosGamma, cosLambda * cosPhi], [cosPhi * sinGamma, cosPhi * cosGamma, -sinPhi] ]; } function computeTiltMatrix(tilt, azimuth) { const t = tilt * Math.PI / 180; const a = azimuth * Math.PI / 180; const cosT = Math.cos(t), sinT = Math.sin(t); const cosA = Math.cos(a), sinA = Math.sin(a); return [ [cosA, -sinA * cosT, sinA * sinT], [sinA, cosA * cosT, -cosA * sinT], [0, sinT, cosT] ]; } function multiplyMatrix(m, v) { return [ m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2], m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2], m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] ]; } }; return projection; } const width = window.innerWidth - 40; const height = window.innerHeight - 40; const svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); // Add a circle for clipping svg.append("defs") .append("clipPath") .attr("id", "circle-clip") .append("circle") .attr("cx", width / 2) .attr("cy", height / 2) .attr("r", Math.min(width, height) / 2.2); const projection = generalPerspective() .distance(1.1) .tilt(55) .azimuth(210) .scale(Math.min(width, height) / 2) .translate([width / 2, height / 2]) .center([45, 0]) .rotate([74, -41.5, 0]); const path = d3.geoPath().projection(projection); const graticule = d3.geoGraticule(); // Create a group for all map elements and apply the clip path const mapGroup = svg.append("g") .attr("clip-path", "url(#circle-clip)"); // Add graticule to the clipped group mapGroup.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc") .attr("stroke-width", 0.5); // Add countries to the clipped group d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson") .then(data => { if (data && data.features) { mapGroup.selectAll("path.country") .data(data.features) .enter() .append("path") .attr("class", "country") .attr("d", d => { try { const pathData = path(d); return pathData || ""; } catch (e) { console.warn("Error generating path for feature:", d); return ""; } }) .attr("fill", "steelblue") .attr("stroke", "white") .attr("stroke-width", 0.5); } }) .catch(error => { console.error("Error loading the GeoJSON data:", error); svg.append("text") .attr("x", width / 2) .attr("y", height / 2) .attr("text-anchor", "middle") .text("Error loading map data"); }); }); </script> </body> </html>
+-- test7.html: <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>General Perspective Projection</title> <script defer src="https://d3js.org/d3.v7.min.js"></script> </head> <body> <script> window.addEventListener('DOMContentLoaded', (event) => { function generalPerspective() { // Using parameters from Snyder's Figure 37: // Point ~160 km above Newburgh, NY // φ₁ = 41°30'N lat., λ₀ = 74°00'W long. // tilt = 35°, P = 1.025 let distance = 1.025; // P value let scale = 250; let translate = [480, 250]; let center = [-74, 41.5]; // Newburgh, NY let tilt = 35; // Match Figure 37 tilt let azimuth = -10; // Adjusted to match view angle let rotate = [-74, -41.5, 0]; // Center on Newburgh // Rest of the projection code remains the same function projection(coordinates) { let [lambda, phi] = coordinates; let [lambda_r, phi_r, gamma] = rotate; // Convert angles to radians lambda = lambda * Math.PI / 180; phi = phi * Math.PI / 180; lambda_r = lambda_r * Math.PI / 180; phi_r = phi_r * Math.PI / 180; gamma = gamma * Math.PI / 180; // Apply rotation const cos_phi = Math.cos(phi); const sin_phi = Math.sin(phi); const cos_lambda = Math.cos(lambda); const sin_lambda = Math.sin(lambda); const cos_phi_r = Math.cos(phi_r); const sin_phi_r = Math.sin(phi_r); const cos_lambda_r = Math.cos(lambda_r); const sin_lambda_r = Math.sin(lambda_r); const x1 = cos_phi * cos_lambda; const y1 = cos_phi * sin_lambda; const z1 = sin_phi; // Rotate around z axis (lambda) const x2 = x1 * cos_lambda_r + y1 * sin_lambda_r; const y2 = -x1 * sin_lambda_r + y1 * cos_lambda_r; const z2 = z1; // Rotate around x axis (phi) const x3 = x2; const y3 = y2 * cos_phi_r + z2 * sin_phi_r; const z3 = -y2 * sin_phi_r + z2 * cos_phi_r; // Apply tilt and azimuth const tilt_rad = tilt * Math.PI / 180; const azimuth_rad = azimuth * Math.PI / 180; const cos_tilt = Math.cos(tilt_rad); const sin_tilt = Math.sin(tilt_rad); const cos_azimuth = Math.cos(azimuth_rad); const sin_azimuth = Math.sin(azimuth_rad); const x4 = x3 * cos_azimuth - y3 * sin_azimuth; const y4 = x3 * sin_azimuth + y3 * cos_azimuth; const z4 = z3; const x5 = x4; const y5 = y4 * cos_tilt - z4 * sin_tilt; const z5 = y4 * sin_tilt + z4 * cos_tilt; // Perspective projection if (z5 >= distance) return null; const k = 1 / (distance - z5); return [ x5 * k * scale + translate[0], -y5 * k * scale + translate[1] ]; } // Accessor methods remain the same... projection.distance = function(_) { return arguments.length ? (distance = +_, projection) : distance; }; projection.scale = function(_) { return arguments.length ? (scale = +_, projection) : scale; }; projection.translate = function(_) { return arguments.length ? (translate = _, projection) : translate; }; projection.center = function(_) { return arguments.length ? (center = _, projection) : center; }; projection.tilt = function(_) { return arguments.length ? (tilt = +_, projection) : tilt; }; projection.azimuth = function(_) { return arguments.length ? (azimuth = +_, projection) : azimuth; }; projection.rotate = function(_) { return arguments.length ? (rotate = _, projection) : rotate; }; // projection.stream = function(stream) { // return { // point: function(x, y) { // const point = projection([x, y]); // if (point) stream.point(point[0], point[1]); // }, // sphere: function() { stream.sphere(); }, // lineStart: function() { stream.lineStart(); }, // lineEnd: function() { stream.lineEnd(); }, // polygonStart: function() { stream.polygonStart(); }, // polygonEnd: function() { stream.polygonEnd(); } // }; // }; projection.stream = function(stream) { const epsilon = 1e-6; const infinity = 1e3; let visible; // Pre-compute rotation matrices for efficiency const rotationMatrix = computeRotationMatrix(rotate); const tiltMatrix = computeTiltMatrix(tilt, azimuth); function visible3d(x, y, z) { const k = distance - z; // Handle near and far clipping planes if (k < epsilon || k > infinity) return false; // Check if point is beyond horizon const cosC = x * x + y * y + z * z; if (cosC > 1 + epsilon) return false; // Handle points near the antipode const antipodalDist = 2 - cosC; if (antipodalDist < epsilon) return false; return true; } function project3d(lambda, phi) { // Convert from degrees to radians lambda *= Math.PI / 180; phi *= Math.PI / 180; // Convert to 3D cartesian const cosPhi = Math.cos(phi); const x = Math.cos(lambda) * cosPhi; const y = Math.sin(lambda) * cosPhi; const z = Math.sin(phi); // Apply rotation matrix const [x1, y1, z1] = multiplyMatrix(rotationMatrix, [x, y, z]); // Apply tilt and azimuth const [x2, y2, z2] = multiplyMatrix(tiltMatrix, [x1, y1, z1]); if (!visible3d(x2, y2, z2)) return null; // Project to 2D with perspective division const k = 1 / (distance - z2); return { x: x2 * k * scale + translate[0], y: -y2 * k * scale + translate[1], z: z2, k: k }; } // Line segment handler with adaptive sampling const line = { point0: null, point1: null, segment: [], size: 0, reset: function() { this.point0 = this.point1 = null; this.segment = []; this.size = 0; }, subdivide: function(lambda0, phi0, lambda1, phi1, depth) { if (depth > 8) return; // Maximum recursion depth const mid_lambda = (lambda0 + lambda1) / 2; const mid_phi = (phi0 + phi1) / 2; const p = project3d(mid_lambda, mid_phi); if (p) { // Check if subdivision is needed const dx = p.x - (this.point0.x + this.point1.x) / 2; const dy = p.y - (this.point0.y + this.point1.y) / 2; if (dx * dx + dy * dy > epsilon) { this.subdivide(lambda0, phi0, mid_lambda, mid_phi, depth + 1); this.segment.push(p); this.subdivide(mid_lambda, mid_phi, lambda1, phi1, depth + 1); } } } }; return { point: function(lambda, phi) { const p = project3d(lambda, phi); if (p) stream.point(p.x, p.y); }, lineStart: function() { line.reset(); visible = false; stream.lineStart(); }, lineEnd: function() { // Handle line segments that cross the horizon if (line.point0 && line.point1) { const segment = line.segment; for (let i = 0; i < segment.length; i++) { stream.point(segment[i].x, segment[i].y); } } if (visible) stream.lineEnd(); line.reset(); }, polygonStart: function() { visible = true; stream.polygonStart(); }, polygonEnd: function() { stream.polygonEnd(); }, sphere: function() { stream.sphere(); } }; // Helper functions function computeRotationMatrix([lambda, phi, gamma]) { // Convert to radians const [lr, pr, gr] = [lambda, phi, gamma].map(d => d * Math.PI / 180); const cosLambda = Math.cos(lr), sinLambda = Math.sin(lr); const cosPhi = Math.cos(pr), sinPhi = Math.sin(pr); const cosGamma = Math.cos(gr), sinGamma = Math.sin(gr); return [ [cosLambda * cosGamma - sinLambda * sinPhi * sinGamma, -cosLambda * sinGamma - sinLambda * sinPhi * cosGamma, -sinLambda * cosPhi], [sinLambda * cosGamma + cosLambda * sinPhi * sinGamma, -sinLambda * sinGamma + cosLambda * sinPhi * cosGamma, cosLambda * cosPhi], [cosPhi * sinGamma, cosPhi * cosGamma, -sinPhi] ]; } function computeTiltMatrix(tilt, azimuth) { const t = tilt * Math.PI / 180; const a = azimuth * Math.PI / 180; const cosT = Math.cos(t), sinT = Math.sin(t); const cosA = Math.cos(a), sinA = Math.sin(a); return [ [cosA, -sinA * cosT, sinA * sinT], [sinA, cosA * cosT, -cosA * sinT], [0, sinT, cosT] ]; } function multiplyMatrix(m, v) { return [ m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2], m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2], m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] ]; } }; return projection; } const width = window.innerWidth - 40; const height = window.innerHeight - 40; const svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); // Add a circle for clipping svg.append("defs") .append("clipPath") .attr("id", "circle-clip") .append("circle") .attr("cx", width / 2) .attr("cy", height / 2) .attr("r", Math.min(width, height) / 2.2); const projection = generalPerspective() .distance(1.1) .tilt(55) .azimuth(210) .scale(Math.min(width, height) / 2) .translate([width / 2, height / 2]) .center([45, 0]) .rotate([74, -41.5, 0]); const path = d3.geoPath().projection(projection); const graticule = d3.geoGraticule(); // Create a group for all map elements and apply the clip path const mapGroup = svg.append("g") .attr("clip-path", "url(#circle-clip)"); // Add graticule to the clipped group mapGroup.append("path") .datum(graticule) .attr("class", "graticule") .attr("d", path) .attr("fill", "none") .attr("stroke", "#ccc") .attr("stroke-width", 0.5); // Add countries to the clipped group d3.json("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/refs/heads/master/geojson/ne_110m_admin_0_countries.geojson") .then(data => { if (data && data.features) { mapGroup.selectAll("path.country") .data(data.features) .enter() .append("path") .attr("class", "country") .attr("d", d => { try { const pathData = path(d); return pathData || ""; } catch (e) { console.warn("Error generating path for feature:", d); return ""; } }) .attr("fill", "steelblue") .attr("stroke", "white") .attr("stroke-width", 0.5); } }) .catch(error => { console.error("Error loading the GeoJSON data:", error); svg.append("text") .attr("x", width / 2) .attr("y", height / 2) .attr("text-anchor", "middle") .text("Error loading map data"); }); }); </script> </body> </html>
+-- test8.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>General Perspective Projection</title> <script src="https://d3js.org/d3.v7.min.js"></script> <style> body { font-family: Arial, sans-serif; } svg { display: block; margin: auto; background-color: #f0f0f0; } .controls { display: flex; justify-content: center; gap: 20px; margin: 20px; } .controls label { display: block; } .controls input { width: 80px; } </style> </head> <body> <h1 style="text-align: center;">General Perspective Projection</h1> <div class="controls"> <div> <label> Longitude Center <input type="number" id="longitude" value="0" step="1"> </label> </div> <div> <label> Latitude Center <input type="number" id="latitude" value="0" step="1"> </label> </div> <div> <label> Perspective Distance (P) <input type="number" id="distance" value="2" step="0.1"> </label> </div> <div> <label> Earth Radius (R) <input type="number" id="radius" value="6371" step="100"> </label> </div> <button id="update">Update Projection</button> </div> <svg width="800" height="600"></svg> <script> // General Perspective Projection function geoGeneralPerspective() { let lambda0 = 0, phi0 = 0, R = 6371, P = 2; function projection(lambda, phi) { const rad = Math.PI / 180; lambda *= rad; phi *= rad; const lambda0Rad = lambda0 * rad; const phi0Rad = phi0 * rad; const cosC = Math.sin(phi0Rad) * Math.sin(phi) + Math.cos(phi0Rad) * Math.cos(phi) * Math.cos(lambda - lambda0Rad); if (cosC < 1 / P) return null; const kPrime = (P - 1) / (P - cosC); const x = R * kPrime * Math.cos(phi) * Math.sin(lambda - lambda0Rad); const y = R * kPrime * (Math.cos(phi0Rad) * Math.sin(phi) - Math.sin(phi0Rad) * Math.cos(phi) * Math.cos(lambda - lambda0Rad)); return [x, y]; } projection.stream = function(outputStream) { return { point: function(lambda, phi) { const point = projection(lambda, phi); if (point) outputStream.point(point[0], point[1]); }, lineStart: function() { outputStream.lineStart(); }, lineEnd: function() { outputStream.lineEnd(); }, polygonStart: function() { outputStream.polygonStart(); }, polygonEnd: function() { outputStream.polygonEnd(); } }; }; projection.center = function([lambda, phi]) { if (!arguments.length) return [lambda0, phi0]; lambda0 = lambda; phi0 = phi; return projection; }; projection.perspectiveDistance = function(value) { if (!arguments.length) return P; P = value; return projection; }; projection.radius = function(value) { if (!arguments.length) return R; R = value; return projection; }; return projection; } const svg = d3.select("svg"); const width = +svg.attr("width"); const height = +svg.attr("height"); const projection = geoGeneralPerspective() .center([0, 0]) .perspectiveDistance(2) .radius(6371); const path = d3.geoPath().projection(projection); const updateMap = () => { d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(geojson => { svg.selectAll("path") .data(geojson.features) .join("path") .attr("d", path) .attr("fill", "#69b3a2") .attr("stroke", "#333"); }); }; document.getElementById("update").addEventListener("click", () => { const lambda = +document.getElementById("longitude").value; const phi = +document.getElementById("latitude").value; const P = +document.getElementById("distance").value; const R = +document.getElementById("radius").value; projection .center([lambda, phi]) .perspectiveDistance(P) .radius(R); updateMap(); }); updateMap(); </script> </body> </html>
+-- test9.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Tilted Perspective Projection</title> <script src="https://d3js.org/d3.v7.min.js"></script> <style> body { font-family: Arial, sans-serif; } svg { display: block; margin: auto; background-color: #f0f0f0; } </style> </head> <body> <h1 style="text-align: center;">Tilted Perspective Projection</h1> <svg width="800" height="600"></svg> <script> function geoTiltedPerspective() { let lambda0 = -74, // Longitude of projection center phi0 = 41.5, // Latitude of projection center omega = 55, // Tilt angle in degrees gamma = 210, // Yaw angle in degrees R = 6371, // Earth's radius in kilometers P = 1.025; // Perspective distance (relative to Earth's radius) function projection(lambda, phi) { const rad = Math.PI / 180; lambda *= rad; phi *= rad; const lambda0Rad = lambda0 * rad; const phi0Rad = phi0 * rad; const omegaRad = omega * rad; const gammaRad = gamma * rad; // Rotate for tilt and yaw const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi); const sinPhi0 = Math.sin(phi0Rad), cosPhi0 = Math.cos(phi0Rad); const cosC = sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad); // Clip points outside the visible hemisphere if (cosC < 1 / P) return null; const kPrime = (P - 1) / (P - cosC); // Transform for tilt const x = R * kPrime * Math.cos(phi) * Math.sin(lambda - lambda0Rad); const y = R * kPrime * (cosPhi0 * sinPhi - sinPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); const z = R * kPrime * (sinPhi0 * sinPhi + cosPhi0 * cosPhi * Math.cos(lambda - lambda0Rad)); // Apply tilt (rotation about x-axis) and yaw (rotation about z-axis) const xt = x; const yt = y * Math.cos(omegaRad) - z * Math.sin(omegaRad); const zt = y * Math.sin(omegaRad) + z * Math.cos(omegaRad); const xFinal = xt * Math.cos(gammaRad) - yt * Math.sin(gammaRad); const yFinal = xt * Math.sin(gammaRad) + yt * Math.cos(gammaRad); return [xFinal, yFinal]; } projection.stream = function(outputStream) { return { point: function(lambda, phi) { const point = projection(lambda, phi); if (point) outputStream.point(point[0], point[1]); }, lineStart: function() { outputStream.lineStart(); }, lineEnd: function() { outputStream.lineEnd(); }, polygonStart: function() { outputStream.polygonStart(); }, polygonEnd: function() { outputStream.polygonEnd(); } }; }; projection.center = function([lambda, phi]) { if (!arguments.length) return [lambda0, phi0]; lambda0 = lambda; phi0 = phi; return projection; }; projection.tilt = function(value) { if (!arguments.length) return omega; omega = value; return projection; }; projection.yaw = function(value) { if (!arguments.length) return gamma; gamma = value; return projection; }; projection.perspectiveDistance = function(value) { if (!arguments.length) return P; P = value; return projection; }; projection.radius = function(value) { if (!arguments.length) return R; R = value; return projection; }; return projection; } const svg = d3.select("svg"); const width = +svg.attr("width"); const height = +svg.attr("height"); const projection = geoTiltedPerspective() .center([-74, 41.5]) // Newburgh, NY .tilt(55) // Tilt angle .yaw(210) // Yaw angle .perspectiveDistance(1.025) .radius(6371); const path = d3.geoPath().projection(projection); const updateMap = () => { d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(geojson => { svg.selectAll("path") .data(geojson.features) .join("path") .attr("d", path) .attr("fill", "#69b3a2") .attr("stroke", "#333"); }); }; updateMap(); </script> </body> </html>
+-- tree-content.py
+-- tree.20241202152513.txt
+-- tree.ps1
+-- tree.py
+-- tsconfig.app.json
+-- tsconfig.json
\-- tsconfig.spec.json
