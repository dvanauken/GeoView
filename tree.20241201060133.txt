+-- src
|   +-- app
|   |   +-- components
|   |   |   +-- airport-table
|   |   |   |   +-- airport-table.component.html: <div> <!-- Add Row Button at the top of the table --> <button mat-icon-button (click)="toggleNewEntryRow()" aria-label="Add row" class="icon-blue"> <mat-icon>add</mat-icon> </button> </div> <div class="table-container"> <table mat-table [dataSource]="dataSource" class="mat-elevation-z8"> <!-- New entry row at the top --> <tr *ngIf="isAddingNewEntry"> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Code" [(ngModel)]="newEntry.code"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Region" [(ngModel)]="newEntry.region" type="number"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Name" [(ngModel)]="newEntry.name"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="City" [(ngModel)]="newEntry.city"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Country" [(ngModel)]="newEntry.country"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Latitude" [(ngModel)]="newEntry.lat" type="number"> </td> <td mat-footer-cell *matFooterCellDef> <input matInput placeholder="Longitude" [(ngModel)]="newEntry.lon" type="number"> </td> <td> <!-- Icons for save and cancel actions --> <mat-icon (click)="addInlineEntry()" color="primary" class="icon-blue">save</mat-icon> <mat-icon (click)="clearNewEntry()" color="primary" class="icon-blue">cancel</mat-icon> </td> </tr> <!-- Column definitions --> <ng-container matColumnDef="code"> <th mat-header-cell *matHeaderCellDef> Code </th> <td mat-cell *matCellDef="let element"> {{ element?.code }} </td> </ng-container> <ng-container matColumnDef="region"> <th mat-header-cell *matHeaderCellDef> Region </th> <td mat-cell *matCellDef="let element"> {{ element?.region }} </td> </ng-container> <ng-container matColumnDef="name"> <th mat-header-cell *matHeaderCellDef> Name </th> <td mat-cell *matCellDef="let element"> {{ element?.name }} </td> </ng-container> <ng-container matColumnDef="city"> <th mat-header-cell *matHeaderCellDef> City </th> <td mat-cell *matCellDef="let element"> {{ element?.city }} </td> </ng-container> <ng-container matColumnDef="country"> <th mat-header-cell *matHeaderCellDef> Country </th> <td mat-cell *matCellDef="let element"> {{ element?.country }} </td> </ng-container> <ng-container matColumnDef="lat"> <th mat-header-cell *matHeaderCellDef> Latitude </th> <td mat-cell *matCellDef="let element"> {{ element?.lat }} </td> </ng-container> <ng-container matColumnDef="lon"> <th mat-header-cell *matHeaderCellDef> Longitude </th> <td mat-cell *matCellDef="let element"> {{ element?.lon }} </td> </ng-container> <ng-container matColumnDef="actions"> <th mat-header-cell *matHeaderCellDef> Actions </th> <td mat-cell *matCellDef="let element"> <mat-icon (click)="editEntry(element)" color="primary" class="icon-blue">edit</mat-icon> <mat-icon (click)="cancelEdit(element)" color="primary" class="icon-blue">cancel</mat-icon> <mat-icon (click)="saveEntry(element)" color="primary" class="icon-blue">save</mat-icon> </td> </ng-container> <!-- Header and data rows --> <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr> <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> </table> <mat-paginator #paginator [pageSize]="25" [pageSizeOptions]="[5, 10, 25, 100]" [length]="dataSource?.data.length || 0" showFirstLastButtons> </mat-paginator> </div>
|   |   |   |   +-- airport-table.component.scss: .table-container { padding: 1.25rem; background-color: #f9f9f9; border-radius: 0.5rem; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); table { width: 100%; border-collapse: collapse; table-layout: fixed; th, td { padding: 0.75rem 0.5rem; font-size: 0.875rem; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } th { font-weight: 600; background-color: #f0f0f0; } td { border-bottom: 1px solid #e0e0e0; } .code-column { width: 4rem; text-align: center; } .region-column { width: 6rem; text-align: center; } .name-column { width: 12rem; text-align: left; } .city-column { width: 8rem; text-align: left; } .country-column { width: 8rem; text-align: left; } .lat-column { width: 7rem; text-align: right; } .lon-column { width: 7rem; text-align: right; } } button { margin-top: 0.9375rem; } mat-paginator { margin-top: 1.25rem; } } .icon-blue { color: blue; } .new-entry-row { background-color: #f2f2f2; }
|   |   |   |   +-- airport-table.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing'; import { AirportTableComponent } from './airport-table.component'; describe('AirportTableComponent', () => { let component: AirportTableComponent; let fixture: ComponentFixture<AirportTableComponent>; beforeEach(() => { TestBed.configureTestingModule({ declarations: [AirportTableComponent] }); fixture = TestBed.createComponent(AirportTableComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
|   |   |   |   \-- airport-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, OnChanges, SimpleChanges, ViewChild } from '@angular/core'; import { MatTableDataSource } from '@angular/material/table'; import { MatPaginator } from '@angular/material/paginator'; import { AirportData } from '../../interfaces/airport-data.interface'; import { DataService } from '../../services/data.service'; @Component({ selector: 'app-airport-table', templateUrl: './airport-table.component.html', styleUrls: ['./airport-table.component.scss'] }) export class AirportTableComponent implements OnInit, OnChanges { @Input() airportData: AirportData[] = []; @ViewChild(MatPaginator, { static: true }) paginator: MatPaginator; dataSource: MatTableDataSource<AirportData> = new MatTableDataSource<AirportData>(); displayedColumns: string[] = ['code', 'region', 'name', 'city', 'country', 'lat', 'lon', 'actions']; // Control for displaying the new entry row isAddingNewEntry = false; newEntry: AirportData = { code: '', region: 0, name: '', city: '', country: '', lat: null, lon: null }; constructor( private dataService: DataService, private cdr: ChangeDetectorRef ) {} ngOnInit(): void { this.initializeDataSource(); } ngOnChanges(changes: SimpleChanges): void { if (changes['airportData'] && changes['airportData'].currentValue) { this.updateDataSource(); } } toggleNewEntryRow(): void { this.isAddingNewEntry = !this.isAddingNewEntry; this.cdr.markForCheck(); // Mark the component for change detection } addInlineEntry() { if (this.newEntry.code && this.newEntry.name && this.newEntry.city && this.newEntry.country && this.newEntry.lat !== null && this.newEntry.lon !== null) { const data = this.dataSource.data; data.unshift({ ...this.newEntry }); this.dataSource.data = data; this.dataService.setAirport(this.newEntry); this.clearNewEntry(); this.isAddingNewEntry = false; this.cdr.markForCheck(); // Mark the component for change detection } } clearNewEntry() { this.newEntry = { code: '', region: 0, name: '', city: '', country: '', lat: null, lon: null }; this.isAddingNewEntry = false; this.cdr.markForCheck(); // Mark the component for change detection } initializeDataSource(): void { this.dataSource.data = this.airportData; this.dataSource.paginator = this.paginator; } updateDataSource(): void { this.dataSource.data = this.airportData; } }
|   |   |   +-- login
|   |   |   |   +-- login.component.html: <div class="login-container"> <form (ngSubmit)="onSubmit()"> <div> <label for="username">Username:</label> <input type="text" id="username" [(ngModel)]="username" name="username"> </div> <div> <label for="password">Password:</label> <input type="password" id="password" [(ngModel)]="password" name="password"> </div> <button type="submit">Login</button> </form> </div>
|   |   |   |   +-- login.component.scss: .login-container { display: flex; justify-content: center; align-items: center; height: 100vh; form { padding: 20px; border: 1px solid #ccc; border-radius: 4px; div { margin-bottom: 10px; } label { display: block; margin-bottom: 5px; } input { padding: 5px; width: 200px; } button { margin-top: 10px; padding: 5px 10px; } } }
|   |   |   |   \-- login.component.ts: // src/app/components/login/login.component.ts import { Component } from '@angular/core'; import { AuthService } from '../../services/auth.service'; @Component({ selector: 'app-login', templateUrl: './login.component.html', styleUrls: ['./login.component.scss'] }) export class LoginComponent { username: string = 'admin'; password: string = 'admin'; constructor(private authService: AuthService) {} onSubmit() { this.authService.login(this.username, this.password); } }
|   |   |   +-- map
|   |   |   |   +-- globe-drag-handler.ts: import { throttle, DebouncedFunc } from 'lodash'; import * as d3 from 'd3'; export class GlobeDragHandler { private v0: [number, number, number]; // Mouse position at drag start private r0: [number, number, number]; // Projection rotation at drag start private readonly throttledUpdate: DebouncedFunc<() => void>; constructor( private projection: d3.GeoProjection, private updateCallback: () => void, private throttleTime: number = 16 // ~60fps default ) { this.throttledUpdate = throttle(() => { this.updateCallback(); }, this.throttleTime); // Bind methods to ensure correct 'this' context this.dragStarted = this.dragStarted.bind(this); this.dragged = this.dragged.bind(this); this.dragEnded = this.dragEnded.bind(this); } public dragStarted(event: d3.D3DragEvent<any, any, any>): void { const point = d3.pointer(event, event.sourceEvent.currentTarget); this.v0 = [point[0], point[1], 0]; this.r0 = this.projection.rotate(); } public dragged(event: d3.D3DragEvent<any, any, any>): void { if (!this.v0 || !this.r0) return; const point = d3.pointer(event, event.sourceEvent.currentTarget); const sensitivity = 0.25; const xChange = (point[0] - this.v0[0]) * sensitivity; const yChange = (point[1] - this.v0[1]) * sensitivity; // Update projection rotation this.projection.rotate([ this.r0[0] + xChange, this.r0[1] - yChange, this.r0[2] ]); // Use throttled update this.throttledUpdate(); } public dragEnded(): void { this.v0 = undefined; this.r0 = undefined; // Force a final update to ensure we render the final position if (this.throttledUpdate.flush) { this.throttledUpdate.flush(); } } public destroy(): void { if (this.throttledUpdate.cancel) { this.throttledUpdate.cancel(); } } public attachDragBehavior(selection: d3.Selection<any, unknown, null, undefined>): void { const dragBehavior = d3.drag<any, unknown>() .on('start', this.dragStarted) .on('drag', this.dragged) .on('end', this.dragEnded); selection.call(dragBehavior); } }
|   |   |   |   +-- globe-keyboard-handler.ts: export class GlobeKeyboardHandler { constructor( private projection: d3.GeoProjection, private updateCallback: () => void, private zoomCallback: (zoomFactor: number) => void, // New callback for zoom private incrementStep: number = 5 // Degree increment for rotation adjustments ) { this.handleKeydown = this.handleKeydown.bind(this); window.addEventListener('keydown', this.handleKeydown, { passive: false }); } private handleKeydown(event: KeyboardEvent): void { event.preventDefault(); // Prevent default browser behavior for keys const currentRotation = this.projection.rotate(); let [yaw, pitch, roll] = currentRotation; switch (event.key.toUpperCase()) { // Ensure case-insensitivity case 'W': pitch = Math.min(pitch + this.incrementStep, 90); break; case 'S': pitch = Math.max(pitch - this.incrementStep, -90); break; case 'A': yaw = (yaw - this.incrementStep + 360) % 360; break; case 'D': yaw = (yaw + this.incrementStep) % 360; break; case 'Q': roll = (roll - this.incrementStep + 360) % 360; break; case 'E': roll = (roll + this.incrementStep) % 360; break; case 'R': // Reset rotation to default (0, 0, 0) yaw = 0; pitch = 0; roll = 0; break; case '+': // Zoom in this.zoomCallback(1.1); // Increase zoom factor return; case '-': // Zoom out this.zoomCallback(0.9); // Decrease zoom factor return; default: return; // Ignore other keys } this.projection.rotate([yaw, pitch, roll]); this.updateCallback(); } public removeEventListener(): void { window.removeEventListener('keydown', this.handleKeydown); } }
|   |   |   |   +-- map.component.backup
|   |   |   |   +-- map.component.html: <!-- map.component.html --> <div #mapContainer class="map-container"> <!-- The map will be appended here by D3 --> </div>
|   |   |   |   +-- map.component.scss: :host { display: block; width: 100%; height: 100%; } .map-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; } svg { width: 95%; height: 95%; display: block; }
|   |   |   |   +-- map.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild } from '@angular/core'; import * as d3 from 'd3'; import * as d3Geo from 'd3-geo'; import { Feature, FeatureCollection, Geometry, GeometryObject } from 'geojson'; import { Subscription } from 'rxjs'; import { ProjectionType } from '../../enums/projection-type.enum'; import { MatTableDataSource } from '@angular/material/table'; import { DataService } from '../../services/data.service'; import { throttle } from 'lodash'; import { GlobeDragHandler } from "./globe-drag-handler"; import { GlobeKeyboardHandler } from './globe-keyboard-handler'; @Component({ selector: 'app-map', templateUrl: './map.component.html', styleUrls: ['./map.component.scss'] }) export class MapComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('mapContainer', { static: true }) mapContainer: ElementRef; private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>; private gSphere: d3.Selection<SVGGElement, unknown, null, undefined>; private gGraticule: d3.Selection<SVGGElement, unknown, null, undefined>; private gCountries: d3.Selection<SVGGElement, unknown, null, undefined>; private gRoutes: d3.Selection<SVGGElement, unknown, null, undefined>; private gAirports: d3.Selection<SVGGElement, unknown, null, undefined>; private projection: d3.GeoProjection; private path: d3.GeoPath; private resizeObserver: ResizeObserver; private subscription: Subscription; private zoom: d3.ZoomBehavior<Element, unknown>; private projectionType: ProjectionType = ProjectionType.Orthographic; private dragHandler: GlobeDragHandler; private currentZoomScale: number = 1; private renderedAirports: Set<string> = new Set(); private keyboardHandler: GlobeKeyboardHandler; constructor(private dataService: DataService) { } ngOnInit(): void { //console.log('MapComponent ngOnInit called.'); this.initMap(); this.subscription = this.dataService.getSelectedFeatures().subscribe(features => { //console.log('MapComponent received updated features:', features); this.updateMapSelection(features); this.updateLayers(); }); } ngAfterViewInit(): void { //console.log('MapComponent ngAfterViewInit called. Ready for interaction.'); this.resizeObserver = new ResizeObserver(() => this.resizeMap()); this.resizeObserver.observe(this.mapContainer.nativeElement); } // Add a method to handle zoom changes private applyZoomChange(zoomFactor: number): void { this.zoom.scaleBy(this.svg, zoomFactor); } private updateMap(): void { //console.log('Updating the map based on new rotations or changes.'); // Re-render or refresh any D3 map layers as necessary this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } private setupSVG(): void { //console.log('Setting up SVG elements.'); const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; // Clear any existing SVG d3.select(this.mapContainer.nativeElement).selectAll('svg').remove(); this.svg = d3.select(this.mapContainer.nativeElement).append('svg') .attr('width', width) .attr('height', height) .attr('viewBox', `0 0 ${width} ${height}`) .attr('preserveAspectRatio', 'xMidYMid meet'); // Create groups in correct order (bottom to top) this.gSphere = this.svg.append('g').attr('class', 'sphere-layer'); this.gGraticule = this.svg.append('g').attr('class', 'graticule-layer'); this.gCountries = this.svg.append('g').attr('class', 'countries-layer'); this.gRoutes = this.svg.append('g').attr('class', 'routes-layer'); this.gAirports = this.svg.append('g').attr('class', 'airports-layer'); } private initMap(): void { //console.log('Initializing map.'); this.setupSVG(); this.setProjection(this.projectionType); this.path = d3.geoPath().projection(this.projection); // Add the base sphere with subtle color this.gSphere.append('path') .datum({ type: 'Sphere' }) .attr('class', 'sphere') .attr('d', this.path); // Add graticule const graticule = d3.geoGraticule(); this.gGraticule.append('path') .datum(graticule) .attr('class', 'graticule') .attr('d', this.path) // Now add other layers this.updateLayers(); this.applyZoom(); this.resizeMap(); } private setProjection(type: ProjectionType): void { //console.log('Setting projection:', type); const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; this.projection = d3.geoOrthographic() .scale(Math.min(width, height) / 2.5) .translate([width / 2, height / 2]) .center([0, 0]) .rotate([74, -30, 0]) .clipAngle(90); this.path = d3.geoPath().projection(this.projection); } private updateLayers(): void { //console.log('Updating layers on the map.'); const layerNames = this.dataService.getLayerNames(); layerNames.forEach(layerName => { //console.log(`Processing layer: ${layerName}`); const layer = this.dataService.getLayer(layerName); if (layer && layer.getFeatures()) { if (layerName === 'countries') { this.updateCountriesLayer(layer.getFeatures()); } else if (layerName === 'routes' || layerName.toUpperCase() === 'PA') { this.updateRoutesLayer(layerName, layer.getFeatures()); this.updateAirportsForRoutes(layer.getFeatures()); } } }); } private updateCountriesLayer(features: Feature[]): void { this.gCountries.selectAll('path') .data(features) .join( enter => enter.append('path') .attr('class', (d: Feature) => `${d.geometry.type.toLowerCase()} country`) .attr('d', this.path) .style('fill', '#cccccc') .style('stroke', '#666666') .style('stroke-width', '0.5px'), update => update.attr('d', this.path), exit => exit.remove() ); } private updateRoutesLayer(layerName: string, features: Feature[]): void { this.gRoutes.selectAll(`path.${layerName}`) .data(features, (d: Feature) => d.id) .join( enter => enter.append('path') .attr('class', (d: Feature) => `${d.geometry.type.toLowerCase()} ${layerName}`) .attr('d', this.path) .on('click', (event: MouseEvent, feature: Feature<Geometry, { [name: string]: any }>) => this.selectFeature(event, feature) ) .style('cursor', 'pointer'), update => update.attr('d', this.path), exit => exit.remove() ); } private updateAirportsForRoutes(features: Feature[]): void { const airportsToAdd = new Set<string>(); // Collect all unique airports from the features features.forEach((feature: any) => { if (feature.properties && feature.properties.base && feature.properties.ref) { airportsToAdd.add(feature.properties.base); airportsToAdd.add(feature.properties.ref); } }); // Only add airports that haven't been rendered yet airportsToAdd.forEach(airportCode => { if (!this.renderedAirports.has(airportCode)) { this.addAirport(airportCode); this.renderedAirports.add(airportCode); } }); } private addAirport(airportCode: string): void { const airport = this.dataService.getAirport(airportCode); if (!airport) return; const lon = Number(airport.lon); const lat = Number(airport.lat); if (isNaN(lon) || isNaN(lat)) return; const coords: [number, number] = [lon, lat]; const projectedCoords = this.projection(coords as [number, number]); if (!projectedCoords || isNaN(projectedCoords[0]) || isNaN(projectedCoords[1])) return; // Add airport circle this.gAirports.append('circle') .attr('class', 'airport-circle') .attr('cx', projectedCoords[0]) .attr('cy', projectedCoords[1]) .attr('r', 1) .style('fill', '#add8e6') .style('stroke', 'blue') .style('stroke-width', '2px') .attr('data-airport', airportCode) .attr('vector-effect', 'non-scaling-stroke'); // Add single text label with consistent styling this.gAirports.append('text') .attr('class', 'airport-label') .attr('x', projectedCoords[0] + 7) .attr('y', projectedCoords[1] + 3) .text(airportCode) .style('font-size', '12px') .style('fill', 'blue') .style('stroke', 'none') .attr('data-airport', airportCode) .attr('vector-effect', 'non-scaling-stroke'); } private updateAirportPositions(): void { const zoomScale = this.currentZoomScale ? 1 / this.currentZoomScale : 1; this.gAirports.selectAll('.airport-circle, .airport-label').each((d: any, i, nodes) => { const element = d3.select(nodes[i]); const airportCode = element.attr('data-airport'); const airport = this.dataService.getAirport(airportCode); if (airport) { const coords: [number, number] = [Number(airport.lon), Number(airport.lat)]; const visible = d3.geoDistance(coords, [-this.projection.rotate()[0], -this.projection.rotate()[1]] as [number, number]) < Math.PI / 2; if (visible) { const projectedCoords = this.projection(coords as [number, number]); if (projectedCoords && !isNaN(projectedCoords[0]) && !isNaN(projectedCoords[1])) { if (element.classed('airport-circle')) { element .attr('cx', projectedCoords[0]) .attr('cy', projectedCoords[1]) .attr('r', 5 * zoomScale) .style('display', 'block'); } else { element .attr('x', projectedCoords[0] + 7 * zoomScale) .attr('y', projectedCoords[1] + 3 * zoomScale) .style('font-size', `${12 * zoomScale}px`) .style('display', 'block'); } } } else { element.style('display', 'none'); } } }); this.svg.selectAll('.airport-geometry').attr('vector-effect', 'non-scaling-stroke'); } public resizeMap(): void { //console.log('Resizing map.'); if (this.mapContainer && this.svg) { const width = this.mapContainer.nativeElement.offsetWidth * 0.95; const height = this.mapContainer.nativeElement.offsetHeight * 0.95; this.svg .attr('width', width) .attr('height', height) .attr('viewBox', `0 0 ${width} ${height}`); this.projection .scale(Math.min(width, height) / 2.5) .translate([width / 2, height / 2]); // Update all paths and positions this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } } private selectFeature(event: MouseEvent, feature: Feature): void { console.log('Selecting feature:', feature); if (feature.id) { this.dataService.setSelectedFeatures([feature]); console.log('Selected feature set in DataModel:', feature.id); } else { console.error('Feature ID is undefined, cannot select'); } } private updateMapSelection(features: Feature[] | null): void { this.gRoutes.selectAll('.selected').classed('selected', false); if (features && features.length) { features.forEach(feature => { if (feature.id) { this.gRoutes.selectAll('path') .filter((d: any) => d.id === feature.id) .classed('selected', true) .raise(); } }); } } private applyZoom(): void { //console.log('Applying zoom behavior to the map.'); this.dragHandler = new GlobeDragHandler( this.projection, () => { this.gSphere.selectAll('path').attr('d', this.path); this.gGraticule.selectAll('path').attr('d', this.path); this.gCountries.selectAll('path').attr('d', this.path); this.gRoutes.selectAll('path').attr('d', this.path); this.updateAirportPositions(); } ); this.dragHandler.attachDragBehavior(this.gSphere.select('.sphere')); //this.dragHandler.attachDragBehavior(this.gSphere.select('*')); this.zoom = d3.zoom() .scaleExtent([1, 32]) .on('zoom', (event) => { const { transform } = event; const scaleTransformString = `translate(${transform.x}, ${transform.y}) scale(${transform.k})`; this.gSphere.attr('transform', scaleTransformString); this.gGraticule.attr('transform', scaleTransformString); this.gCountries.attr('transform', scaleTransformString); this.gRoutes.attr('transform', scaleTransformString); this.gAirports.attr('transform', scaleTransformString); this.svg.selectAll('path').attr('vector-effect', 'non-scaling-stroke'); this.currentZoomScale = event.transform.k; this.updateAirportPositions(); }); this.svg.call(this.zoom); } ngOnDestroy(): void { if (this.resizeObserver) this.resizeObserver.disconnect(); if (this.subscription) this.subscription.unsubscribe(); if (this.dragHandler) this.dragHandler.destroy(); if (this.keyboardHandler) this.keyboardHandler.removeEventListener(); // Access property here } }
|   |   |   |   \-- versor.ts: /** * versor.ts * A comprehensive utility class for handling 3D rotations using quaternions and versors. * Implements smooth interpolation and transformation between different rotation representations. */ export class Versor { /** * Converts degrees to radians */ static toRadians(degrees: number): number { return degrees * Math.PI / 180; } /** * Converts radians to degrees */ static toDegrees(radians: number): number { return radians * 180 / Math.PI; } /** * Converts latitude and longitude to 3D Cartesian coordinates on a unit sphere */ static cartesian(lambda: number, phi: number): [number, number, number] { lambda = this.toRadians(lambda); phi = this.toRadians(phi); const cosPhi = Math.cos(phi); return [ cosPhi * Math.cos(lambda), cosPhi * Math.sin(lambda), Math.sin(phi) ]; } /** * Converts 3D Cartesian coordinates to [longitude, latitude] in degrees */ static spherical(cartesian: [number, number, number]): [number, number] { const [x, y, z] = cartesian; return [ this.toDegrees(Math.atan2(y, x)), this.toDegrees(Math.asin(Math.max(-1, Math.min(1, z)))) ]; } /** * Calculates the dot product of two vectors */ static dot(a: number[], b: number[]): number { if (a.length !== b.length) { throw new Error('Vectors must have the same length'); } return Math.max(-1, Math.min(1, a.reduce((sum, _, i) => sum + a[i] * b[i], 0))); } /** * Calculates the cross product of two 3D vectors */ static cross(a: [number, number, number], b: [number, number, number]): [number, number, number] { return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; } /** * Normalizes a vector to unit length */ static normalize(v: number[]): number[] { const length = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0)); if (length === 0) { throw new Error('Cannot normalize zero-length vector'); } return v.map(x => x / length); } /** * Creates a quaternion that rotates vector v0 to align with vector v1 */ static quaternion(v0: [number, number, number], v1: [number, number, number]): [number, number, number, number] { if (!v0 || !v1) { throw new Error('Both vectors are required'); } // Normalize input vectors const normalized0 = this.normalize(v0) as [number, number, number]; const normalized1 = this.normalize(v1) as [number, number, number]; const dot = this.dot(normalized0, normalized1); // If vectors are parallel, return identity quaternion if (dot >= 0.999999) { return [1, 0, 0, 0]; } // If vectors are anti-parallel, rotate 180° around any perpendicular axis if (dot <= -0.999999) { const axis = Math.abs(normalized0[0]) < 0.1 ? this.cross(normalized0, [1, 0, 0]) : this.cross(normalized0, [0, 1, 0]); const normalizedAxis = this.normalize(axis); return [0, ...normalizedAxis] as [number, number, number, number]; } const w = this.cross(normalized0, normalized1); const theta = Math.acos(dot); const wlen = Math.sqrt(w.reduce((sum, x) => sum + x * x, 0)); if (wlen < 1e-10) { return [1, 0, 0, 0]; } const sinHalfTheta = Math.sin(theta / 2); return [ Math.cos(theta / 2), (w[0] / wlen) * sinHalfTheta, (w[1] / wlen) * sinHalfTheta, (w[2] / wlen) * sinHalfTheta ]; } /** * Multiplies two quaternions */ static multiply(a: [number, number, number, number], b: [number, number, number, number]): [number, number, number, number] { return [ a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3], a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2], a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1], a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0] ]; } /** * Converts a quaternion to a rotation matrix */ static quaternionToMatrix(q: [number, number, number, number]): number[] { const [w, x, y, z] = this.normalize(q) as [number, number, number, number]; const xx = x * x, yy = y * y, zz = z * z; const xy = x * y, xz = x * z, yz = y * z; const wx = w * x, wy = w * y, wz = w * z; return [ 1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy), 2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx), 2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy) ]; } /** * Converts a rotation matrix to Euler angles [phi, theta, psi] in degrees */ static matrixToEuler(matrix: number[]): [number, number, number] { const [m11, m12, m13, m21, m22, m23, m31, m32, m33] = matrix; let phi: number, theta: number, psi: number; if (Math.abs(m31) !== 1) { theta = -Math.asin(Math.max(-1, Math.min(1, m31))); const cosTheta = Math.cos(theta); phi = Math.atan2(m32 / cosTheta, m33 / cosTheta); psi = Math.atan2(m21 / cosTheta, m11 / cosTheta); } else { // Gimbal lock case phi = 0; if (m31 === -1) { theta = Math.PI / 2; psi = phi + Math.atan2(m12, m13); } else { theta = -Math.PI / 2; psi = -phi + Math.atan2(-m12, -m13); } } return [ this.toDegrees(phi), this.toDegrees(theta), this.toDegrees(psi) ]; } /** * Creates a quaternion from Euler angles [phi, theta, psi] in degrees */ static eulerToQuaternion(euler: [number, number, number]): [number, number, number, number] { const [phi, theta, psi] = euler.map(this.toRadians); const c1 = Math.cos(phi / 2); const c2 = Math.cos(theta / 2); const c3 = Math.cos(psi / 2); const s1 = Math.sin(phi / 2); const s2 = Math.sin(theta / 2); const s3 = Math.sin(psi / 2); return [ c1 * c2 * c3 + s1 * s2 * s3, s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3 ]; } /** * Interpolates between two quaternions using spherical linear interpolation (slerp) */ static slerp(q1: [number, number, number, number], q2: [number, number, number, number], t: number): [number, number, number, number] { // Normalize quaternions const n1 = this.normalize(q1) as [number, number, number, number]; const n2 = this.normalize(q2) as [number, number, number, number]; // Calculate cosine of angle between quaternions let dot = this.dot(n1, n2); // If quaternions are very close, use linear interpolation if (Math.abs(dot) > 0.9995) { const result = n1.map((x, i) => x + t * (n2[i] - x)); return this.normalize(result) as [number, number, number, number]; } // Ensure shortest path if (dot < 0) { n2.forEach((_, i) => n2[i] = -n2[i]); dot = -dot; } // Clamp dot product to valid range dot = Math.max(-1, Math.min(1, dot)); const theta0 = Math.acos(dot); const theta = theta0 * t; const sinTheta = Math.sin(theta); const sinTheta0 = Math.sin(theta0); const s1 = Math.cos(theta) - dot * sinTheta / sinTheta0; const s2 = sinTheta / sinTheta0; return [ s1 * n1[0] + s2 * n2[0], s1 * n1[1] + s2 * n2[1], s1 * n1[2] + s2 * n2[2], s1 * n1[3] + s2 * n2[3] ]; } /** * Converts a rotation in [longitude, latitude, rotation] format to a quaternion */ static rotationToQuaternion(rotation: [number, number, number]): [number, number, number, number] { const [lambda, phi, gamma] = rotation.map(this.toRadians); const cLambda = Math.cos(lambda / 2); const sLambda = Math.sin(lambda / 2); const cPhi = Math.cos(phi / 2); const sPhi = Math.sin(phi / 2); const cGamma = Math.cos(gamma / 2); const sGamma = Math.sin(gamma / 2); return [ cLambda * cPhi * cGamma - sLambda * sPhi * sGamma, sLambda * cPhi * cGamma + cLambda * sPhi * sGamma, cLambda * sPhi * cGamma - sLambda * cPhi * sGamma, cLambda * cPhi * sGamma + sLambda * sPhi * cGamma ]; } /** * Converts a quaternion to [longitude, latitude, rotation] in degrees */ static quaternionToRotation(q: [number, number, number, number]): [number, number, number] { const normalized = this.normalize(q) as [number, number, number, number]; const [w, x, y, z] = normalized; const sinPhi = 2 * (w * y - z * x); let phi = Math.asin(Math.max(-1, Math.min(1, sinPhi))); const lambda = Math.atan2( 2 * (w * x + y * z), 1 - 2 * (x * x + y * y) ); const gamma = Math.atan2( 2 * (w * z + x * y), 1 - 2 * (y * y + z * z) ); return [ this.toDegrees(lambda), this.toDegrees(phi), this.toDegrees(gamma) ]; } }
|   |   |   +-- map-view
|   |   |   |   +-- map-view.component.html: <div *ngIf="isLoading" class="loading-container"> <img src="assets/spinner.gif" alt="Loading..." /> </div> <div *ngIf="!isLoading" class="app-container"> <app-double-pane> <app-pane class="left-panel"> <app-map #map></app-map> </app-pane> <app-pane class="right-panel"> <ixt-tabset title="Employee Form"> <ixt-tab title="City Pairs"> <app-table></app-table> </ixt-tab> <ixt-tab title="City Editor"> <ixt-table [data]="airportData" [config]="tableConfig"> </ixt-table> </ixt-tab> <ixt-tab title="Style Editor"> <h1></h1> <style-editor></style-editor> </ixt-tab> </ixt-tabset> <!-- <ixt-tabset [tabs]="tabs" [config]="tabConfig" (tabChange)="onTabChange($event)"> <div *ngIf="tabs[0].active" class="tab-content"> </div> <div *ngIf="tabs[1].active" class="tab-content"> <ixt-table [data]="airportData" [config]="tableConfig"> </ixt-table> </div> <div *ngIf="tabs[2].active" class="tab-content"> <style-editor></style-editor> </div> </ixt-tabset> --> </app-pane> </app-double-pane> </div>
|   |   |   |   +-- map-view.component.scss: :host { display: block; height: 100vh; } .app-container { width: 100%; height: 100%; } .loading-container { display: flex; justify-content: center; align-items: center; height: 100vh; } .left-panel, .right-panel { height: 100%; overflow: hidden; } .left-panel { app-map { height: 100%; width: 100%; display: block; } } .right-panel { display: flex; flex-direction: column; } :host ::ng-deep { // IxtTabset styles .tabs { position: relative; z-index: 1000; } .button-row { height: 32px; background: #f5f5f5; margin: 0; padding: 0; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; button { height: 32px !important; color: rgba(0, 0, 0, 0.87) !important; opacity: 1 !important; font-weight: 500; padding: 0 24px; border: none; background: none; cursor: pointer; transition: all 0.3s ease; &.active { border-bottom: 2px solid #1976d2; } &:hover { background-color: rgba(0, 0, 0, 0.04); } } } .content { flex: 1; height: calc(100% - 32px); background-color: #fff; overflow: hidden; } // Table styles .mat-mdc-table { width: 100%; .mat-mdc-row, .mat-mdc-header-row { height: 24px !important; min-height: 24px !important; } .mat-mdc-cell, .mat-mdc-header-cell { padding: 0 8px !important; line-height: 24px !important; } } } .tab-content { height: 100%; overflow: auto; padding: 0; h2 { margin: 4px 8px; font-size: 14px; } } // Component-specific styles app-table, ixt-table, style-editor { display: block; height: 100%; width: 100%; } app-table { overflow: auto; } ixt-table { overflow: hidden; } style-editor { padding: 16px; overflow: auto; } // Notification band .top-band { padding: 8px 16px; background-color: #f8f9fa; border-bottom: 1px solid #e0e0e0; font-size: 14px; color: rgba(0, 0, 0, 0.87); } // Fix for double-pane layout app-double-pane { display: flex; width: 100%; height: 100%; } app-pane { display: flex; flex-direction: column; height: 100%; }
|   |   |   |   \-- map-view.component.ts: import { AfterViewInit, ChangeDetectorRef, Component, OnInit, ViewChild } from '@angular/core'; import { MatPaginator } from '@angular/material/paginator'; import { MatTableDataSource } from "@angular/material/table"; import { MatIconModule } from '@angular/material/icon'; import { MatTooltipModule } from '@angular/material/tooltip'; import { Feature, LineString, FeatureCollection } from 'geojson'; import { Observable } from 'rxjs'; import * as Papa from 'papaparse'; //import { TableConfig } from '@dvanauken/ixtlan'; import { TableConfig } from '@dvanauken/ixtlan/dist/ixtlan'; import { ITabContent, ITabsetConfig } from '@dvanauken/ixtlan/dist/ixtlan'; import { AirportData } from 'src/app/interfaces/airport-data.interface'; import { DataService } from 'src/app/services/data.service'; import { Resources } from 'src/app/services/resources'; import { Layer } from 'src/app/models/layer'; @Component({ selector: 'map-view', templateUrl: './map-view.component.html', styleUrls: ['./map-view.component.scss'] }) export class MapViewComponent implements OnInit, AfterViewInit { @ViewChild(MatPaginator, { static: false }) paginator: MatPaginator; title = 'Airport and Route Manager'; isLoading = true; displayedColumns: string[] = ['code', 'region', 'name', 'city', 'country', 'lat', 'lon']; //airportData = new MatTableDataSource<AirportData>([]); airportData: AirportData[] = []; countries: Layer | null = null; routes: Layer | null = null; airports: Layer | null = null; selectedFeatures$: Observable<Feature[]>; layers: Layer[] = []; formatCoord = (coord: number) => coord.toFixed(1); tableConfig: TableConfig<AirportData> = { columns: [ { key: 'code', header: 'Code' }, { key: 'name', header: 'Name' }, { key: 'city', header: 'City' }, { key: 'country', header: 'Country' }, { key: 'lat', header: 'Latitude' }, { key: 'lon', header: 'Longitude' } ], selectionMode: 'multiple', allowAdd: false, allowEdit: false, allowDelete: false }; tabConfig: ITabsetConfig = { showNotificationBand: true, notificationText: '🗺️ GeoView Navigation', animationDuration: 300 }; tabs: ITabContent[] = [ { id: 'map', title: 'Map', content: '', active: true }, { id: 'airports', title: 'Airports', content: '', active: false }, { id: 'style', title: 'Style Editor', content: '', active: false } ]; constructor( private cdr: ChangeDetectorRef, private dataService: DataService ) { this.selectedFeatures$ = this.dataService.getSelectedFeatures(); } ngOnInit(): void { (async () => { try { const loadedData = await Resources.load(["assets/Airport.json"]); if (loadedData.length === 0 || !loadedData[0].data) { throw new Error('Invalid airport data structure'); } this.dataService.setAirports(loadedData[0].data); console.log('Airports loaded and set in DataService.'); this.airportData = this.dataService.getAirports(); //this.airportData = new MatTableDataSource<AirportData>(this.dataService.getAirports()); //console.log('Loaded airport data for display:', this.airportData.data); const files = await Resources.load(['assets/110m/countries.geojson', 'assets/routes.json', 'assets/pa.csv']); files.forEach(({ data, path }) => { if (path.endsWith('countries.geojson')) { this.dataService.addLayer('countries', new Layer('FeatureCollection', data.features || data)); console.log("countries.geojson:path=" + path + ", data=" + data.features.length); } else if (path.endsWith('routes.json')) { // Ensure `airports[0].data` contains airport data for lookups //const airportData = airports[0].data; const hubs = ['ATL', 'SLC', 'MSP', 'DTW', 'JFK', 'AUS', 'CVG', 'LAX', 'SEA', 'BOS', 'LGA', 'DCA', 'RDU', 'DFW']; // List of DL hubs // Create GeoJSON features for routes based on base and ref lookups using map and filter const features = data .filter((route: { al: string }) => route.al === 'DL') // Filter for routes with `al: DL` .filter((route: { base: string; ref: string }) => !hubs.includes(route.base) && !hubs.includes(route.ref)) // Exclude routes with hubs as base or ref .map((route: { base: string; ref: string; al: string }) => { // Find the base and ref coordinates from airportData const baseAirport = this.dataService.getAirports().find((airport: any) => airport.code === route.base); const refAirport = this.dataService.getAirports().find((airport: any) => airport.code === route.ref); // Return a feature if both airports are found; otherwise, return null return (baseAirport && refAirport) ? { type: 'Feature', id: `${route.base}-${route.ref}-${route.al}`, // Ensure each feature has a unique ID geometry: { type: 'LineString', coordinates: [ [baseAirport.lon, baseAirport.lat], [refAirport.lon, refAirport.lat] ] }, properties: { id: `${route.base}-${route.ref}-${route.al}`, // Ensure each feature has a unique ID Airline: route.al, base: route.base, ref: route.ref, 'City 1': `${baseAirport.city}`, 'City 2': `${refAirport.city}`, 'Coords 1': [this.formatCoord(baseAirport.lon), this.formatCoord(baseAirport.lat)], 'Coords 2': [this.formatCoord(refAirport.lon), this.formatCoord(refAirport.lat)] }, } : null; }) .filter(feature => feature !== null) as GeoJSON.Feature[]; // Filter out null values this.dataService.addLayer('routes', new Layer("routes", features)); } else if (path.endsWith('pa.csv')) { console.log("pa.csv:path=" + path + ", data=" + data.length); // Print sample data for verification console.log('Filtered data sample:', data.filter(row => row['origin'] && row['destination']).slice(0, 3)); const cityPairSet = new Set(); const features = data .filter(row => row['origin'] && row['destination']) .map(row => { const base = (row['origin'] < row['destination']) ? row['origin'] : row['destination']; const ref = (row['origin'] < row['destination']) ? row['destination'] : row['origin']; // Ensure base and ref are not the same if (base === ref) { return null; } // Create a unique key for the city pair const pairKey = `${base}-${ref}-PA`; // Include airline in uppercase in the key if (cityPairSet.has(pairKey)) { return null; // Skip if the pair already exists } cityPairSet.add(pairKey); // Get the airport data directly from DataService const baseAirport = this.dataService.getAirport(base); const refAirport = this.dataService.getAirport(ref); // Ensure both coordinates are valid if (!baseAirport || !refAirport) { return null; } // const originCoords = ; // const destinationCoords = ; return { type: 'Feature', id: pairKey, // Assign the unique pair key with the airline as the id geometry: { type: 'LineString', coordinates: [[baseAirport.lon, baseAirport.lat], [refAirport.lon, refAirport.lat]] }, properties: { id: pairKey, Airline: 'PA', base: base, ref: ref, 'City 1': baseAirport.city, 'City 2': refAirport.city, 'Coords 1': [this.formatCoord(baseAirport.lon), this.formatCoord(baseAirport.lat)], 'Coords 2': [this.formatCoord(refAirport.lon), this.formatCoord(refAirport.lat)] } }; }) .filter(feature => feature !== null) .sort((a, b) => a.id.localeCompare(b.id)); // Sort features by id in alphabetical order // Print the sorted features for verification console.log('Sorted Features:', features.length); // Optional: Add the features to DataService as a new layer this.dataService.addLayer('PA', new Layer("PA", features)); } }); //console.log('All resource loading completed.'); this.dataService.setSelectedLayer("routes"); this.isLoading = false; } catch (err) { //console.error('An error occurred during loading:', err); this.isLoading = false; } })(); } ngAfterViewInit(): void { // setTimeout(() => { // if (this.paginator) { // //this.airportData.paginator = this.paginator; // this.cdr.detectChanges(); // console.log("Paginator linked successfully"); // } else { // console.warn("Paginator not found"); // } // }); } // onTabChange(event: any): void { // if (event.index === 1) { // Airport tab index // setTimeout(() => { // if (this.paginator) { // //this.airportData.paginator = this.paginator; // this.cdr.detectChanges(); // } // }); // } // } onLayerSelect(layerName: string): void { this.dataService.setSelectedLayer(layerName); } onTabChange(tab: ITabContent): void { if (tab.id === 'airports') { setTimeout(() => { if (this.paginator) { this.cdr.detectChanges(); } }); } } }
|   |   |   +-- pane
|   |   |   |   +-- double-pane
|   |   |   |   |   +-- double-pane.component.html: <div #container class="double-pane-container"> <ng-content select="app-pane.left-panel"></ng-content> <div #divider class="divider" (mousedown)="onMouseDown($event)" [style.left]="dividerPosition"></div> <ng-content select="app-pane.right-panel"></ng-content> </div>
|   |   |   |   |   +-- double-pane.component.scss: :host { display: block; width: 100%; height: 100%; } .double-pane-container { display: flex; /* Flex layout for left and right panels */ width: 100%; /* Full width of the container */ height: 100%; /* Full height of the container */ position: relative; /* For positioning the divider */ } .left-panel { flex: 0 0 50%; /* Start with 50% width, allow resizing */ max-width: 50%; /* Prevent overflow */ display: flex; /* Use flex for centering */ justify-content: center; /* Horizontally center the content */ align-items: center; /* Vertically center the content */ overflow: hidden; /* Prevent overflow scrollbars */ } .right-panel { flex: 1; /* Take up remaining space */ height: 100%; /* Full height for the right pane */ overflow: auto; /* Allow scrolling if necessary */ } .divider { position: absolute; top: 0; bottom: 0; width: 5px; background-color: #ccc; cursor: col-resize; z-index: 10; /* Ensure the divider stays on top */ }
|   |   |   |   |   \-- double-pane.component.ts: import { Component, ElementRef, ViewChild, AfterViewInit, AfterContentInit, ContentChildren, QueryList, OnDestroy, ChangeDetectorRef } from '@angular/core'; import { fromEvent, Subscription } from 'rxjs'; import { throttleTime, takeUntil } from 'rxjs/operators'; import { PaneComponent } from '../pane/pane.component'; import { MapComponent } from '../../map/map.component'; // Correct import @Component({ selector: 'app-double-pane', templateUrl: './double-pane.component.html', styleUrls: ['./double-pane.component.scss'] }) export class DoublePaneComponent implements AfterViewInit, AfterContentInit, OnDestroy { @ViewChild('map', { static: false }) mapComponent!: MapComponent; // Use template reference @ViewChild('divider', { static: true }) divider!: ElementRef; @ViewChild('container', { static: true }) container!: ElementRef; @ContentChildren(PaneComponent) panes!: QueryList<PaneComponent>; isDragging = false; leftPaneWidth = 50; dividerPosition = '50%'; private subscriptions: Subscription = new Subscription(); constructor(private cdr: ChangeDetectorRef) {} ngAfterViewInit(): void { //console.log('ngAfterViewInit: Checking if MapComponent is detected.'); //console.log('MapComponent:', this.mapComponent); this.updatePaneWidths(); } ngAfterContentInit() { //console.log('DoublePaneComponent - ngAfterContentInit'); //console.log('Number of panes:', this.panes.length); } ngOnDestroy(): void { this.subscriptions.unsubscribe(); } onMouseDown(event: MouseEvent): void { event.preventDefault(); this.isDragging = true; const moveSubscription = fromEvent<MouseEvent>(document, 'mousemove').pipe( takeUntil(fromEvent(document, 'mouseup')), throttleTime(16) // Approx. 60fps ).subscribe(e => this.resize(e.clientX)); const upSubscription = fromEvent(document, 'mouseup').subscribe(() => { this.isDragging = false; moveSubscription.unsubscribe(); upSubscription.unsubscribe(); }); this.subscriptions.add(moveSubscription); this.subscriptions.add(upSubscription); } resize(x: number): void { const containerRect = this.container.nativeElement.getBoundingClientRect(); const containerWidth = containerRect.width; const newLeftWidth = ((x - containerRect.left) / containerWidth) * 100; this.leftPaneWidth = Math.max(10, Math.min(90, newLeftWidth)); this.dividerPosition = `${this.leftPaneWidth}%`; this.updatePaneWidths(); } private updatePaneWidths(): void { //console.log('Updating pane widths...'); const paneArray = this.panes.toArray(); //console.log('Pane array:', paneArray); if (paneArray.length === 2) { //console.log(`Setting left pane width to ${this.leftPaneWidth}%`); paneArray[0].setWidth(`${this.leftPaneWidth}%`); //console.log(`Setting right pane width to ${100 - this.leftPaneWidth}%`); paneArray[1].setWidth(`${100 - this.leftPaneWidth}%`); this.cdr.detectChanges(); //console.log('Change detection triggered.'); //// Ensure the map component exists and trigger its resize logic //if (this.mapComponent) { // console.log('Calling resizeMap on the MapComponent instance.'); // this.mapComponent.resizeMap(); //} else { // console.warn('MapComponent instance not found.'); //} } else { console.warn('Expected 2 panes, but found:', paneArray.length); } } }
|   |   |   |   +-- pane
|   |   |   |   |   +-- pane.component.html: <ng-content></ng-content>
|   |   |   |   |   +-- pane.component.scss: :host { display: block; height: 100%; overflow: auto; }
|   |   |   |   |   \-- pane.component.ts: import { Component, ElementRef, Renderer2, ChangeDetectorRef, AfterContentInit } from '@angular/core'; @Component({ selector: 'app-pane', templateUrl: './pane.component.html', styleUrls: ['./pane.component.scss'] }) export class PaneComponent implements AfterContentInit { constructor( public elementRef: ElementRef, private renderer: Renderer2, private cdr: ChangeDetectorRef ) {} ngAfterContentInit() { //console.log('PaneComponent - ngAfterContentInit'); //console.log('Pane content:', this.el.nativeElement.innerHTML); } setWidth(width: string) { //console.log('Setting pane width:', width); this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); this.cdr.detectChanges(); // Force change detection } }
|   |   |   |   \-- pane.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { PaneComponent } from './pane/pane.component'; import { DoublePaneComponent } from './double-pane/double-pane.component'; @NgModule({ declarations: [PaneComponent, DoublePaneComponent], imports: [CommonModule], exports: [PaneComponent, DoublePaneComponent] }) export class PaneModule { }
|   |   |   +-- style-editor
|   |   |   |   +-- style-editor.component.html: <div> <button mat-icon-button (click)="addRow()" aria-label="Add row"> <mat-icon>add</mat-icon> </button> </div> <table mat-table [dataSource]="dataSource" class="mat-elevation-z8"> <ng-container matColumnDef="al"> <th mat-header-cell *matHeaderCellDef> AL </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readAl"> <input matInput [(ngModel)]="row.al" /> </ng-container> <ng-template #readAl>{{ row.al }}</ng-template> </td> </ng-container> <ng-container matColumnDef="base"> <th mat-header-cell *matHeaderCellDef> Base </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readBase"> <input matInput [(ngModel)]="row.base" /> </ng-container> <ng-template #readBase>{{ row.base }}</ng-template> </td> </ng-container> <ng-container matColumnDef="ref"> <th mat-header-cell *matHeaderCellDef> Ref </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readRef"> <input matInput [(ngModel)]="row.ref" /> </ng-container> <ng-template #readRef>{{ row.ref }}</ng-template> </td> </ng-container> <ng-container matColumnDef="strokeColor"> <th mat-header-cell *matHeaderCellDef> Stroke Color </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readStrokeColor"> <input matInput type="color" [(ngModel)]="row.strokeColor" /> </ng-container> <ng-template #readStrokeColor> <div [style.background]="row.strokeColor" class="color-preview"></div> </ng-template> </td> </ng-container> <ng-container matColumnDef="fillColor"> <th mat-header-cell *matHeaderCellDef> Fill Color </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readFillColor"> <input matInput type="color" [(ngModel)]="row.fillColor" /> </ng-container> <ng-template #readFillColor> <div [style.background]="row.fillColor" class="color-preview"></div> </ng-template> </td> </ng-container> <ng-container matColumnDef="style"> <th mat-header-cell *matHeaderCellDef> Style </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing; else readStyle"> <mat-select [(value)]="row.style"> <mat-option *ngFor="let s of styles" [value]="s">{{ s }}</mat-option> </mat-select> </ng-container> <ng-template #readStyle>{{ row.style }}</ng-template> </td> </ng-container> <ng-container matColumnDef="actions"> <th mat-header-cell *matHeaderCellDef> Actions </th> <td mat-cell *matCellDef="let row"> <ng-container *ngIf="row.isEditing"> <!-- Save Icon --> <button mat-icon-button (click)="saveRow(row)" aria-label="Save row"> <mat-icon>check</mat-icon> </button> <!-- Cancel Icon --> <button mat-icon-button (click)="cancelEdit(row)" aria-label="Cancel edit"> <mat-icon>close</mat-icon> </button> </ng-container> <ng-container *ngIf="!row.isEditing"> <!-- Edit Icon --> <button mat-icon-button (click)="editRow(row)" aria-label="Edit row"> <mat-icon>edit</mat-icon> </button> </ng-container> </td> </ng-container> <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr> <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> </table>
|   |   |   |   +-- style-editor.component.scss: .color-preview { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #ddd; } /* Make icons flat and apply royal blue color */ .mat-icon-button.flat { background: none; color: royalblue; border: none; box-shadow: none; } .mat-icon-button.flat:hover { background: rgba(65, 105, 225, 0.1); /* Adds a subtle hover effect */ } .mat-icon-button.flat:active { background: rgba(65, 105, 225, 0.2); /* Slightly darker hover on click */ } .icon-blue { color: blue; } .new-entry-row { background-color: #f2f2f2; }
|   |   |   |   +-- style-editor.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing'; import { StyleEditorComponent } from './style-editor.component'; describe('StyleEditorComponent', () => { let component: StyleEditorComponent; let fixture: ComponentFixture<StyleEditorComponent>; beforeEach(() => { TestBed.configureTestingModule({ declarations: [StyleEditorComponent] }); fixture = TestBed.createComponent(StyleEditorComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
|   |   |   |   \-- style-editor.component.ts: import { Component } from '@angular/core'; interface StyleRow { al: string; base: string; ref: string; strokeColor: string; fillColor: string; style: string; isEditing?: boolean; } @Component({ selector: 'style-editor', templateUrl: './style-editor.component.html', styleUrls: ['./style-editor.component.scss'] }) export class StyleEditorComponent { displayedColumns: string[] = ['al', 'base', 'ref', 'strokeColor', 'fillColor', 'style', 'actions']; styles: string[] = ['solid', 'dashed', 'dotted']; // D3 line styles dataSource: StyleRow[] = [ { al: 'SampleAl', base: 'SampleBase', ref: 'SampleRef', strokeColor: '#000000', fillColor: '#FFFFFF', style: 'solid', isEditing: false } ]; addRow() { // Add a new row at the top, in editing mode const newRow: StyleRow = { al: '', base: '', ref: '', strokeColor: '#000000', fillColor: '#FFFFFF', style: 'solid', isEditing: true // Set to true to start editing mode immediately }; this.dataSource = [newRow, ...this.dataSource]; // Assign a new array to trigger change detection } editRow(row: StyleRow) { row.isEditing = true; } saveRow(row: StyleRow) { row.isEditing = false; } cancelEdit(row: StyleRow) { if (!row.al && !row.base && !row.ref) { // Remove row if it's empty and a new entry const index = this.dataSource.indexOf(row); if (index > -1) { this.dataSource.splice(index, 1); } } else { row.isEditing = false; } } }
|   |   |   \-- table
|   |   |       +-- table.component.html: <div class="table-container" #tableContainer> <div class="table-content"> <table> <caption> <div class="table-controls"> <button (click)="onAddNewRow()"> <mat-icon>add_circle</mat-icon> </button> <button (click)="onSaveAll()"> <mat-icon>save</mat-icon> </button> </div> </caption> <thead> <!-- Column Headers with Sort/Filter Icons --> <tr class="header-row"> <th *ngFor="let column of displayedColumns" class="column-header"> <div class="header-content"> <div class="header-title"> {{column}} </div> <div class="header-actions"> <button class="icon-button sort-button" matTooltip="Sort"> <mat-icon class="small-icon">unfold_more</mat-icon> </button> <button class="icon-button filter-button" matTooltip="Toggle Filters" (click)="toggleFilters()" [class.active]="showFilters"> <mat-icon class="small-icon" [class.active]="showFilters">filter_list</mat-icon> </button> </div> </div> </th> <th class="actions-cell column-header"> <div class="header-content"> <div class="header-title">Actions</div> <div class="header-actions"> <button class="icon-button filter-toggle" matTooltip="Toggle All Filters" (click)="toggleFilters()" [class.active]="showFilters"> <mat-icon class="small-icon" [class.active]="showFilters">filter_list</mat-icon> </button> </div> </div> </th> </tr> <!-- Filter Inputs Row - Now with animation classes --> <tr class="filter-row" [@filterAnimation]="showFilters ? 'visible' : 'hidden'"> <th *ngFor="let column of displayedColumns"> <input type="text" class="filter-input" [placeholder]="'Filter ' + column" matTooltip="Enter filter criteria"> </th> <th class="actions-cell"> <button class="clear-filters" matTooltip="Clear all filters"> <mat-icon class="small-icon">clear</mat-icon> </button> </th> </tr> </thead> <tbody> <tr *ngFor="let row of paginatedData; let i = index" [class.selected]="row.selected" (click)="onRowClick(row, i, $event)"> <td *ngFor="let column of displayedColumns"> <ng-container *ngIf="!row.isEditing"> {{row[column]}} </ng-container> <ng-container *ngIf="row.isEditing"> <input *ngIf="column === 'base' || column === 'ref'" [value]="row[column]" (input)="onFieldChange($event.target.value, column, row, i)" (click)="$event.stopPropagation()"> <span *ngIf="column !== 'base' && column !== 'ref'">{{row[column]}}</span> </ng-container> </td> <td class="actions-cell"> <ng-container *ngIf="!row.isEditing"> <button (click)="onEdit(row, i, $event)"> <mat-icon>edit</mat-icon> </button> <button class="delete-button" (click)="onDelete(row, i, $event)"> <mat-icon>delete</mat-icon> </button> </ng-container> <ng-container *ngIf="row.isEditing"> <button (click)="onSave(row, i)"> <mat-icon>save</mat-icon> </button> <button (click)="onCancel(row, i)"> <mat-icon>close</mat-icon> </button> </ng-container> </td> </tr> </tbody> <tfoot> <tr> <td [attr.colspan]="displayedColumns.length + 1"> <div class="pagination-container"> <div class="pagination-controls"> <button class="pagination-button" (click)="goToFirstPage()" [disabled]="pagination.currentPage === 1"> <mat-icon>first_page</mat-icon> </button> <button class="pagination-button" (click)="goToPreviousPage()" [disabled]="pagination.currentPage === 1"> <mat-icon>chevron_left</mat-icon> </button> <div class="pagination-pages"> <button *ngFor="let page of visiblePages" class="pagination-button" [class.active]="page === pagination.currentPage" [class.ellipsis]="page === -1" [disabled]="page === -1" (click)="onPageChange(page)"> {{page === -1 ? '...' : page}} </button> </div> <button class="pagination-button" (click)="goToNextPage()" [disabled]="pagination.currentPage === totalPages"> <mat-icon>chevron_right</mat-icon> </button> <button class="pagination-button" (click)="goToLastPage()" [disabled]="pagination.currentPage === totalPages"> <mat-icon>last_page</mat-icon> </button> </div> <div class="page-size-selector"> <select (change)="onPageSizeChange($event.target.value)"> <option *ngFor="let size of pagination.pageSizeOptions" [value]="size" [selected]="size === pagination.pageSize"> {{size === -1 ? 'All' : size}} </option> </select> <span class="page-size-label">items per page</span> </div> </div> </td> </tr> </tfoot> </table> </div> </div>
|   |   |       +-- table.component.scss: // table.component.scss .table-controls { padding: 10px; display: flex; gap: 10px; align-items: center; button { background: none; border: none; padding: 0; cursor: pointer; color: #1976d2; &:hover { color: #1565c0; } } } .table-container { width: 100%; height: 100%; display: flex; flex-direction: column; font-family: 'Helvetica Neue', Arial, sans-serif; } .table-content { overflow: auto; position: relative; table { width: 95%; margin: 10px auto; border-collapse: collapse; table-layout: fixed; caption { caption-side: top; padding: 10px; .table-controls { display: flex; gap: 10px; align-items: center; justify-content: flex-start; button { background: none; border: none; padding: 4px; cursor: pointer; color: #1976d2; display: flex; align-items: center; justify-content: center; border-radius: 4px; &:hover { background-color: rgba(25, 118, 210, 0.04); color: #1565c0; } mat-icon { font-size: 20px; width: 20px; height: 20px; line-height: 20px; } } } } thead { th { position: sticky; top: 0; z-index: 10; background-color: #f5f5f5; padding: 8px; font-weight: 500; color: #333; border-bottom: 1px solid #e0e0e0; white-space: nowrap; transition: background-color 0.2s; box-shadow: 0 2px 2px -1px rgba(0,0,0,0.4); &:hover { background-color: #eeeeee; } } .header-row { th { padding: 0; } } .column-header { .header-content { display: flex; align-items: center; justify-content: space-between; padding: 8px; min-height: 48px; } .header-title { font-weight: 500; margin-right: 8px; } .header-actions { display: flex; gap: 4px; align-items: center; } .icon-button { background: none; border: none; padding: 4px; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666; transition: all 0.2s; &:hover { background-color: rgba(0, 0, 0, 0.04); color: #333; } .small-icon { font-size: 18px; width: 18px; height: 18px; line-height: 18px; &.active { color: #1976d2; } } } } .filter-row { background-color: #fafafa; transition: all 0.3s ease; &.hidden { display: none; } th { padding: 8px; background-color: #fafafa; border-top: 1px solid #e0e0e0; } .filter-input { width: 100%; padding: 6px 8px; border: 1px solid #e0e0e0; border-radius: 4px; font-size: 12px; background-color: white; transition: border-color 0.2s; &:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 0 1px rgba(25, 118, 210, 0.2); } &::placeholder { color: #999; } } .clear-filters { background: none; border: none; padding: 4px; cursor: pointer; color: #666; display: flex; align-items: center; justify-content: center; width: 100%; &:hover { color: #d32f2f; } } } } tbody { td { padding: 2px; text-align: left; border-bottom: 1px solid #e0e0e0; font-size: 12px; color: #333; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 150px; } tr { &:nth-child(even) { background-color: #ffffff; } &:nth-child(odd) { background-color: #f7f7f7; } &:hover { background-color: #f0f0f0; } &.selected { background-color: #add8e6; font-weight: bold; } } } .actions-cell { min-width: 100px; text-align: right; } tfoot { tr td { padding: 0; } } } // Pagination styles .pagination-container { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background-color: #fff; border-top: 1px solid #e0e0e0; } .pagination-controls { display: flex; align-items: center; gap: 4px; } .pagination-pages { display: flex; gap: 4px; } .pagination-button { min-width: 32px; height: 32px; padding: 0 4px; margin: 0 2px; border: none; background: none; border-radius: 4px; cursor: pointer; color: #1976d2; font-size: 13px; mat-icon { font-size: 18px; width: 18px; height: 18px; line-height: 18px; } &:hover:not(:disabled) { background-color: rgba(0, 0, 0, 0.04); } &:disabled { color: rgba(0, 0, 0, 0.26); cursor: default; } &.active { background-color: #1976d2; color: white; } &.ellipsis { cursor: default; &:hover { background: none; } } } .page-size-selector { display: flex; align-items: center; gap: 8px; select { padding: 4px 8px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: white; cursor: pointer; font-size: 13px; &:focus { outline: none; border-color: #1976d2; } } .page-size-label { color: rgba(0, 0, 0, 0.54); font-size: 13px; } } } .text-center { text-align: center; } .text-right { text-align: right; } .flex-grow { flex-grow: 1; } .ellipsis { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .column-header { .icon-button { &.active { color: #1976d2; background-color: rgba(25, 118, 210, 0.12); } } } .filter-row { background-color: #fafafa; th { border-top: 1px solid #e0e0e0; transition: padding 200ms cubic-bezier(0.4, 0.0, 0.2, 1); .filter-input { opacity: 1; transition: opacity 200ms cubic-bezier(0.4, 0.0, 0.2, 1); } } &.ng-animating { th { overflow: hidden; } } }
|   |   |       \-- table.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild } from '@angular/core'; import { ChangeDetectorRef } from '@angular/core'; import { FeatureCollection, Feature } from 'geojson'; import { DataService } from '../../services/data.service'; import { Subscription } from 'rxjs'; import { trigger, state, style, transition, animate } from '@angular/animations'; interface PaginationConfig { pageSize: number; currentPage: number; totalItems: number; pageSizeOptions: number[]; } @Component({ selector: 'app-table', templateUrl: './table.component.html', styleUrls: ['./table.component.scss'], animations: [ trigger('filterAnimation', [ state('hidden', style({ opacity: 0, height: '0px', minHeight: '0', padding: '0', overflow: 'hidden' })), state('visible', style({ opacity: 1, height: '*', minHeight: '48px' })), transition('hidden <=> visible', [ animate('200ms cubic-bezier(0.4, 0.0, 0.2, 1)') ]) ]) ] }) export class TableComponent implements OnInit, AfterViewInit, OnDestroy { @ViewChild('tableContainer', { static: true }) tableContainer: ElementRef; displayedColumns: string[] = []; dataSource: any[] = []; private resizeObserver!: ResizeObserver; private subscription: Subscription; selectedRows = new Set(); lastClickedRowIndex: number | null = null; editingRows = new Set<number>(); formatCoord = (coord: number) => coord.toFixed(3); showFilters = false; paginatedData: any[] = []; // Add this line pagination: PaginationConfig = { pageSize: 10, currentPage: 1, totalItems: 0, pageSizeOptions: [10, 25, 50, 100, -1] // -1 represents 'All' }; constructor(private dataService: DataService, private cdr: ChangeDetectorRef) {} ngOnInit(): void { this.dataService.setSelectedFeatures([]); this.initTable(); this.subscription = this.dataService.getSelectedFeatures().subscribe(features => { this.updateTableSelection(features); }); } ngAfterViewInit(): void { this.resizeObserver = new ResizeObserver(() => { this.resizeTable(); }); this.resizeObserver.observe(this.tableContainer.nativeElement); } ngOnDestroy(): void { if (this.resizeObserver) { this.resizeObserver.disconnect(); } this.subscription.unsubscribe(); } private initTable(): void { const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer?.getFeatures()?.length > 0) { const features = selectedLayer.getFeatures(); if (features[0].properties) { this.displayedColumns = Object.keys(features[0].properties); this.dataSource = features.map(feature => ({ ...feature.properties, id: feature.id, selected: false, isEditing: false })); this.pagination.totalItems = this.dataSource.length; this.updatePaginatedData(); } } } initializeNewEntry(): any { return { id: 'NEW', Airline: 'DL', base: '', ref: '', 'City 1': '', 'City 2': '', 'Coords 1': '(0.000, 0.000)', 'Coords 2': '(0.000, 0.000)', isEditing: true, isNew: true }; } onAddNewRow(): void { const newEntry = this.initializeNewEntry(); this.dataSource.unshift(newEntry); } onFieldChange(value: string, field: string, row: any, index: number): void { // Sanitize the input const sanitizedValue = value.toUpperCase().replace(/[^A-Z0-9]/g, ''); // Update the specific row's field row[field] = sanitizedValue; // Only trigger the airport lookup if we have a complete code if (sanitizedValue.length === 3) { if (field === 'base') { const baseAirport = this.dataService.getAirport(sanitizedValue); if (baseAirport) { row['City 1'] = baseAirport.city; row['Coords 1'] = `(${this.formatCoord(baseAirport.lon)}, ${this.formatCoord(baseAirport.lat)})`; this.updateId(row); } else { alert('Base airport not found'); row.base = ''; } } else if (field === 'ref') { const refAirport = this.dataService.getAirport(sanitizedValue); if (refAirport) { row['City 2'] = refAirport.city; row['Coords 2'] = `(${this.formatCoord(refAirport.lon)}, ${this.formatCoord(refAirport.lat)})`; this.updateId(row); } else { alert('Ref airport not found'); row.ref = ''; } } } } updateId(row: any): void { if (row.base && row.ref) { const newId = `${row.base}-${row.ref}-DL`; const idExists = this.dataSource.some(r => r.id === newId && r !== row); if (idExists) { alert('Route with this ID already exists'); row.id = row.isNew ? 'NEW' : row.originalData.id; } else { row.id = newId; } } } resizeTable(): void { if (this.tableContainer) { const width = this.tableContainer.nativeElement.offsetWidth; const height = this.tableContainer.nativeElement.offsetHeight; console.log(`Resizing table to ${width}x${height}`); } } onRowClick(row: any, index: number, event: MouseEvent): void { if (this.editingRows.size > 0) { return; // Prevent selection while editing } this.lastClickedRowIndex = index; let newSelection; if (event.shiftKey && this.lastClickedRowIndex !== null) { const start = Math.min(index, this.lastClickedRowIndex); const end = Math.max(index, this.lastClickedRowIndex); newSelection = this.dataSource.slice(start, end + 1); } else if (event.ctrlKey || event.metaKey) { newSelection = [...this.dataService.getSelectedFeatures().value || []]; const idx = newSelection.findIndex(item => item.id === row.id); if (idx > -1) { newSelection.splice(idx, 1); } else { newSelection.push(row); } } else { newSelection = [row]; } this.dataService.setSelectedFeatures(newSelection); } updateTableSelection(features: Feature[] | null): void { if (!features) { console.log('No features to update in table.'); return; } this.dataSource.forEach(row => { const isSelected = features.some(feature => feature && feature.id === row.id); if (isSelected !== row.selected) { row.selected = isSelected; } }); } onEdit(row: any, index: number, event: Event): void { event.stopPropagation(); row.originalData = { ...row }; row.isEditing = true; this.editingRows.add(index); } onSave(row: any, index: number): void { if (row.id === 'NEW' || !row.base || !row.ref) { alert('Please complete all required fields before saving'); return; } const feature = this.createFeatureFromEntry(row); const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer) { if (row.isNew) { this.dataService.addFeature(feature); } else { this.dataService.updateFeature(feature); } this.dataService.addLayer('routes', selectedLayer); row.isEditing = false; row.isNew = false; delete row.originalData; this.editingRows.delete(index); const currentlySelectedFeatures = this.dataService.getSelectedFeatures().value || []; this.dataService.setSelectedFeatures([...currentlySelectedFeatures]); } } onCancel(row: any, index: number): void { if (row.isNew) { this.dataSource = this.dataSource.filter((_, i) => i !== index); } else { Object.assign(row, row.originalData); row.isEditing = false; delete row.originalData; } this.editingRows.delete(index); } onDelete(row: any, index: number, event: Event): void { event.stopPropagation(); if (confirm('Are you sure you want to delete this row?')) { const selectedLayer = this.dataService.getSelectedLayer(); if (selectedLayer && !row.isNew) { this.dataService.removeFeature(row.id); this.dataService.addLayer('routes', selectedLayer); } this.dataSource = this.dataSource.filter((_, i) => i !== index); } } onSaveAll(): void { const selectedLayer = this.dataService.getSelectedLayer(); if (!selectedLayer) { alert('No layer selected'); return; } for (const row of this.dataSource) { if (row.isNew || row.isEditing) { if (row.id === 'NEW' || !row.base || !row.ref) { alert('Please complete all required fields before saving'); return; } const feature = this.createFeatureFromEntry(row); if (row.isNew) { this.dataService.addFeature(feature); } else { this.dataService.updateFeature(feature); } row.isEditing = false; row.isNew = false; delete row.originalData; } } this.editingRows.clear(); this.dataService.addLayer('routes', selectedLayer); const currentlySelectedFeatures = this.dataService.getSelectedFeatures().value || []; this.dataService.setSelectedFeatures([...currentlySelectedFeatures]); } private createFeatureFromEntry(entry: any): Feature { const city1 = this.dataService.getAirport(entry.base); const city2 = this.dataService.getAirport(entry.ref); const coords1 = [city1.lon, city1.lat]; const coords2 = [city2.lon, city2.lat]; return { type: 'Feature', id: entry.id, geometry: { type: 'LineString', coordinates: [ coords1, coords2 ] }, properties: { Airline: entry.Airline, base: entry.base, ref: entry.ref, 'City 1': entry['City 1'], 'City 2': entry['City 2'], 'Coords 1': entry['Coords 1'], 'Coords 2': entry['Coords 2'] }, }; } // Pagination Methods updatePaginatedData(): void { if (this.pagination.pageSize === -1) { // Show all data this.paginatedData = [...this.dataSource]; return; } const startIndex = (this.pagination.currentPage - 1) * this.pagination.pageSize; const endIndex = startIndex + this.pagination.pageSize; this.paginatedData = this.dataSource.slice(startIndex, endIndex); } get totalPages(): number { if (this.pagination.pageSize === -1) return 1; return Math.ceil(this.pagination.totalItems / this.pagination.pageSize); } get visiblePages(): number[] { const totalPages = this.totalPages; const current = this.pagination.currentPage; const pages: number[] = []; if (totalPages <= 7) { // Show all pages if total is 7 or less for (let i = 1; i <= totalPages; i++) pages.push(i); } else { // Always show first page pages.push(1); if (current > 3) pages.push(-1); // Add ellipsis // Show pages around current page for (let i = Math.max(2, current - 1); i <= Math.min(totalPages - 1, current + 1); i++) { pages.push(i); } if (current < totalPages - 2) pages.push(-1); // Add ellipsis // Always show last page pages.push(totalPages); } return pages; } onPageSizeChange(newSize: number): void { this.pagination.pageSize = newSize; this.pagination.currentPage = 1; // Reset to first page this.updatePaginatedData(); } onPageChange(page: number): void { if (page < 1 || page > this.totalPages) return; this.pagination.currentPage = page; this.updatePaginatedData(); } // Navigation methods goToFirstPage(): void { this.onPageChange(1); } goToLastPage(): void { this.onPageChange(this.totalPages); } goToPreviousPage(): void { this.onPageChange(this.pagination.currentPage - 1); } goToNextPage(): void { this.onPageChange(this.pagination.currentPage + 1); } toggleFilters(event?: Event): void { if (event) { event.stopPropagation(); } this.showFilters = !this.showFilters; } }
|   |   +-- enums
|   |   |   \-- projection-type.enum.ts: // src/app/enums/projection-type.enum.ts export enum ProjectionType { Armadillo = 'armadillo', Gnomonic = 'gnomonic', LambertConicConformal = 'lambertConicConformal', Mercator = 'mercator', Orthographic = 'orthographic', TiltedPerspective = 'tiltedPerspective', TransverseMercator = 'transverseMercator', Equirectangular = 'equirectangular', NaturalEarth = 'naturalEarth', AzimuthalEqualArea = 'azimuthalEqualArea', Stereographic = 'stereographic', AlbersUSA = 'albersUSA', Sinusoidal = 'sinusoidal', Mollweide= 'mollweide' }
|   |   +-- guards
|   |   |   \-- auth.guard.ts: // src/app/guards/auth.guard.ts import { Injectable } from '@angular/core'; import { CanActivate, Router } from '@angular/router'; import { AuthService } from '../services/auth.service'; @Injectable({ providedIn: 'root' }) export class AuthGuard implements CanActivate { constructor(private authService: AuthService, private router: Router) {} canActivate(): boolean { if (!this.authService.isAuthenticated()) { this.router.navigate(['/login']); return false; } return true; } }
|   |   +-- interfaces
|   |   |   +-- airport-data.interface.ts: export interface AirportData { code: string; // Airport code (e.g., IATA code) region: number; // Region code or ID, if applicable name: string; // Name of the airport city: string; // City in which the airport is located country: string; // Country in which the airport is located lat: number; // Latitude of the airport lon: number; // Longitude of the airport }
|   |   |   +-- filter-listener.ts: export interface FilterCriteria { [key: string]: any; } export interface FilterListener { /** * Called when a filter is applied. * @param criteria The filter criteria */ onFilter(criteria: FilterCriteria): void; /** * Called when the filter is cleared. */ onClearFilter(): void; }
|   |   |   +-- flight-data.interface.ts: export interface FlightData { flight_number?: string; origin?: string; destination?: string; frequency?: string; days?: string; departure_time?: string; arrival_time?: string; effective_date?: string | null; discontinued_date?: string | null; suspension_start?: string | null; suspension_end?: string | null; notes?: string | null; }
|   |   |   +-- model-listener.ts: import { GeoModel } from '../models/geo-model'; export interface ModelListener { /** * Called when the model data is updated. * @param model The updated GeoJSONModel */ onModelChange(model: GeoModel): void; }
|   |   |   \-- selection-listener.ts: import { Feature } from 'geojson'; export interface SelectionListener { /** * Called when a feature is selected. * @param feature The selected feature */ onSelect(feature: Feature): void; /** * Called when a feature is deselected. * @param feature The deselected feature */ onDeselect(feature: Feature): void; /** * Called when the selection is cleared. */ onClearSelection(): void; }
|   |   +-- models
|   |   |   +-- criteria.model.ts: export interface CriteriaModel { filterString: string; // Add any additional filter criteria properties as needed }
|   |   |   \-- layer.ts: // Importing the GeoJSON Feature type import { Feature } from 'geojson'; export class Layer { public name: string; private features: Feature[]; // An array of GeoJSON Features constructor(name: string, features: Feature[] = []) { this.name = name; this.features = features; } // Method to get all features getFeatures(): Feature[] { return this.features; } // Method to add a feature addFeature(feature: Feature): void { this.features.push(feature); } // Method to find a feature by ID findFeatureById(id: string | number): Feature | undefined { return this.features.find(feature => feature.id === id); } // Method to remove a feature by ID removeFeatureById(id: string | number): void { this.features = this.features.filter(feature => feature.id !== id); } getProperty(index: number): { [key: string]: any } | undefined { const feature = this.features[index]; return feature ? feature.properties : undefined; } // Method to get properties of all features getProperties(): { [key: string]: any }[] { return this.features .map(feature => feature.properties) .filter(properties => properties !== undefined); } // Custom toString() method for the Layer class toString(): string { if (this.features.length === 0) { return `Layer Name: ${this.name}, Number of Features: 0 (No feature data available)`; } // Extract property names from the first feature const propertyNames = this.features[0].properties ? Object.keys(this.features[0].properties) : []; return `Layer Name: ${this.name}, Number of Features: ${this.features.length}, Property Names: ${propertyNames.join(', ')}`; } }
|   |   +-- services
|   |   |   +-- airport.service.ts: import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { AirportData } from '../interfaces/airport-data.interface'; // Update the path as necessary @Injectable({ providedIn: 'root' }) export class AirportService { constructor(private http: HttpClient) {} loadAirportData(): Observable<AirportData[]> { return this.http.get<AirportData[]>('assets/Airport.json'); } }
|   |   |   +-- auth.service.ts: // src/app/services/auth.service.ts import { Injectable } from '@angular/core'; import { Router } from '@angular/router'; @Injectable({ providedIn: 'root' }) export class AuthService { constructor(private router: Router) {} login(username: string, password: string): boolean { if (username === 'admin' && password === 'admin') { localStorage.setItem('isLoggedIn', 'true'); this.router.navigate(['/map']); return true; } return false; } logout() { localStorage.removeItem('isLoggedIn'); this.router.navigate(['/login']); } isAuthenticated(): boolean { return localStorage.getItem('isLoggedIn') === 'true'; } }
|   |   |   +-- data.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { Layer } from '../models/layer'; import { AirportData } from '../interfaces/airport-data.interface'; import { Feature } from 'geojson'; @Injectable({ providedIn: 'root' }) export class DataService { private airports: Map<string, AirportData> = new Map(); // Stores airport data by code private layersMap: Map<string, Layer> = new Map(); private selectedLayerName: string | null = null; private selectedFeatures: BehaviorSubject<Feature[] | null> = new BehaviorSubject([]); // Layer Getters and Setters public addLayer(name: string, layer: Layer): void { this.layersMap.set(name, layer); } public getLayer(name: string): Layer | undefined { return this.layersMap.get(name); } public getLayerNames(): string[] { return Array.from(this.layersMap.keys()); } public getLayers(): Layer[] { return Array.from(this.layersMap.values()); } public getSelectedLayer(): Layer | undefined { if (this.selectedLayerName) { return this.layersMap.get(this.selectedLayerName); } return undefined; } public setSelectedLayer(layerName: string): void { this.selectedLayerName = layerName; const selectedLayer = this.layersMap.get(layerName); if (selectedLayer && selectedLayer.getFeatures()) { //console.log(`Setting selected layer: ${layerName} with ${selectedLayer.getFeatures().length} features`); this.setSelectedFeatures(selectedLayer.getFeatures()); } else { this.setSelectedFeatures([]); // Clear features if the layer is undefined or has no features } } public setSelectedFeatures(features: Feature[]): void { //console.log('DataService.setSelectedFeatures called with features:', features); this.selectedFeatures.next(features); } public getSelectedFeatures(): BehaviorSubject<Feature[]> { return this.selectedFeatures; } // Airport Getters and Setters public getAirports(): AirportData[] { return Array.from(this.airports.values()); } public setAirports(airports: AirportData[]): void { this.airports.clear(); airports.forEach(airport => { this.airports.set(airport.code, airport); }); //console.log('Airports data set in DataService'); } public getAirport(code: string): AirportData | undefined { return this.airports.get(code); } public setAirport(airport: AirportData): void { if (airport && airport.code) { this.airports.set(airport.code, airport); //console.log(`Airport data updated for ${airport.code} in DataService`); } else { //console.error('Invalid airport data provided'); } } // New methods for feature management updateFeature(feature: Feature) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); const index = features.findIndex((f: Feature) => f.id === feature.id); if (index !== -1) { features[index] = feature; //this.getSelectedLayer().setFeatures(features); } } } removeFeature(featureId: string) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); const filteredFeatures = features.filter((f: Feature) => f.id !== featureId); //this.getSelectedLayer().setFeatures(filteredFeatures); } } addFeature(feature: Feature) { if (this.getSelectedLayer()) { const features = this.getSelectedLayer().getFeatures(); features.push(feature); //this.getSelectedLayer().setFeatures(features); } } }
|   |   |   +-- query-processor.spec.ts: // import { processAndSortData } from './queryProcessor'; // describe('Query Processor', () => { // const mockData = [ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]; // it('should filter data with a simple "eq" condition', () => { // const query = { // and: [{ field: 'al', operator: 'eq', value: 'DL' }] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' } // ]); // }); // it('should filter data with "not_in" condition', () => { // const query = { // and: [{ field: 'base', operator: 'not_in', value: ['ATL', 'MSP'] }] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]); // }); // it('should filter data with nested "or" and "and" conditions', () => { // const query = { // or: [ // { field: 'al', operator: 'eq', value: 'UA' }, // { // and: [ // { field: 'al', operator: 'eq', value: 'DL' }, // { field: 'ref', operator: 'in', value: ['SEA', 'ORD'] } // ] // } // ] // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'SLC', ref: 'SEA' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'UA', base: 'DEN', ref: 'IAH' } // ]); // }); // it('should sort data based on the "base" field in ascending order', () => { // const query = { // sort: { field: 'base', order: 'asc' } // }; // const result = processAndSortData(mockData, query); // expect(result).toEqual([ // { al: 'DL', base: 'ATL', ref: 'JFK' }, // { al: 'UA', base: 'DEN', ref: 'IAH' }, // { al: 'AA', base: 'LAX', ref: 'DFW' }, // { al: 'DL', base: 'MSP', ref: 'ORD' }, // { al: 'DL', base: 'SLC', ref: 'SEA' } // ]); // }); // });
|   |   |   +-- query-processor.ts: // export type QueryCondition = { // field: string; // operator: 'eq' | 'in' | 'not_in'; // value: any; // }; // export type Query = { // and?: QueryCondition[] | Query[]; // or?: QueryCondition[] | Query[]; // sort?: { field: string; order: 'asc' | 'desc' }; // }; // // Function to evaluate a single condition // function evaluateCondition(item: any, condition: QueryCondition): boolean { // switch (condition.operator) { // case 'eq': // return item[condition.field] === condition.value; // case 'in': // return Array.isArray(condition.value) && condition.value.includes(item[condition.field]); // case 'not_in': // return Array.isArray(condition.value) && !condition.value.includes(item[condition.field]); // default: // throw new Error(`Unsupported operator: ${condition.operator}`); // } // } // // Function to process a query with nested logic // export function processQuery(data: any[], query: Query): any[] { // if (query.and) { // return data.filter(item => query.and!.every(subQuery => Array.isArray(subQuery) ? processQuery([item], subQuery).length > 0 : evaluateCondition(item, subQuery))); // } // if (query.or) { // return data.filter(item => query.or!.some(subQuery => Array.isArray(subQuery) ? processQuery([item], subQuery).length > 0 : evaluateCondition(item, subQuery))); // } // return data; // } // // Function to apply sorting // export function sortData(data: any[], sort: { field: string; order: 'asc' | 'desc' }): any[] { // return data.sort((a, b) => { // if (sort.order === 'asc') return a[sort.field] > b[sort.field] ? 1 : -1; // return a[sort.field] < b[sort.field] ? 1 : -1; // }); // } // // Main function to process and sort data based on query // export function processAndSortData(data: any[], query: Query): any[] { // let filteredData = processQuery(data, query); // if (query.sort) { // filteredData = sortData(filteredData, query.sort); // } // return filteredData; // }
|   |   |   \-- resources.ts: import * as Papa from 'papaparse'; export class Resources { static async load(filePaths: string[]): Promise<any[]> { try { const results = []; for (const path of filePaths) { let data; if (path.endsWith('.json') || path.endsWith('.geojson')) { const response = await fetch(path); if (!response.ok) throw new Error(`Failed to load ${path}`); data = await response.json(); } else if (path.endsWith('.csv')) { const response = await fetch(path); if (!response.ok) throw new Error(`Failed to load ${path}`); const csvText = await response.text(); data = Papa.parse(csvText, { header: true, skipEmptyLines: true, }).data; } results.push({ data, path }); } return results; } catch (err) { console.error('Error during resource loading:', err); throw err; } } }
|   |   +-- utils
|   |   |   \-- geo-feature.util.ts: import { Feature, LineString } from 'geojson'; import * as d3 from 'd3-geo'; import { AirportService } from '../services/airport.service'; import { AirlineService } from '../services/airline.service'; export function createGreatCircleFeature( cityPair: any, airportService: AirportService, airlineService: AirlineService ): Feature<LineString> | null { //console.log('Looking up base airport:', cityPair.base); const baseAirport = airportService.getAirportByCode(cityPair.base); //console.log('Looking up ref airport:', cityPair.ref); const refAirport = airportService.getAirportByCode(cityPair.ref); if (!baseAirport || !refAirport) { //console.error('Airport not found for base or ref:', cityPair.base, cityPair.ref); return null; } const baseCoords: [number, number] = [baseAirport.lon, baseAirport.lat]; const refCoords: [number, number] = [refAirport.lon, refAirport.lat]; const greatCircle = d3.geoInterpolate(baseCoords, refCoords); const steps = 50; const pathCoords = Array.from({ length: steps + 1 }, (_, i) => greatCircle(i / steps)); const feature: Feature<LineString> = { type: 'Feature', geometry: { type: 'LineString', coordinates: pathCoords }, properties: { base: baseAirport.code, ref: refAirport.code, baseName: baseAirport.name, refName: refAirport.name, airline: airlineService.getAirlineByCode(cityPair.al)?.name || 'Unknown Airline', distance: d3.geoDistance(baseCoords, refCoords), layer: 'puck' } }; return feature; }
|   |   +-- app-routing.module.ts: // src/app/app-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { MapViewComponent } from './components/map-view/map-view.component'; import { LoginComponent } from './components/login/login.component'; import { AuthGuard } from './guards/auth.guard'; const routes: Routes = [ { path: '', redirectTo: '/login', pathMatch: 'full' }, { path: 'login', component: LoginComponent }, { path: 'map', component: MapViewComponent, canActivate: [AuthGuard] }, { path: 'logout', component: LoginComponent } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }
|   |   +-- app.component.html: <!-- src/app/app.component.html --> <div *ngIf="isLoading" class="loading-container"> <img src="assets/spinner.gif" alt="Loading..."> </div> <div *ngIf="!isLoading" class="app-container"> <router-outlet></router-outlet> </div>
|   |   +-- app.component.scss: :host { display: block; height: 100vh; } .app-container { width: 100%; height: 100%; } .loading-container { display: flex; justify-content: center; align-items: center; height: 100vh; } .left-panel, .right-panel { height: 100%; overflow: hidden; } .left-panel { app-map { height: 100%; width: 100%; display: block; } } .right-panel { display: flex; flex-direction: column; } :host ::ng-deep { // IxtTabset styles .tabs { position: relative; z-index: 1000; } .button-row { height: 32px; background: #f5f5f5; margin: 0; padding: 0; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; button { height: 32px !important; color: rgba(0, 0, 0, 0.87) !important; opacity: 1 !important; font-weight: 500; padding: 0 24px; border: none; background: none; cursor: pointer; transition: all 0.3s ease; &.active { border-bottom: 2px solid #1976d2; } &:hover { background-color: rgba(0, 0, 0, 0.04); } } } .content { flex: 1; height: calc(100% - 32px); background-color: #fff; overflow: hidden; } // Table styles .mat-mdc-table { width: 100%; .mat-mdc-row, .mat-mdc-header-row { height: 24px !important; min-height: 24px !important; } .mat-mdc-cell, .mat-mdc-header-cell { padding: 0 8px !important; line-height: 24px !important; } } } .tab-content { height: 100%; overflow: auto; padding: 0; h2 { margin: 4px 8px; font-size: 14px; } } // Component-specific styles app-table, ixt-table, style-editor { display: block; height: 100%; width: 100%; } app-table { overflow: auto; } ixt-table { overflow: hidden; } style-editor { padding: 16px; overflow: auto; } // Notification band .top-band { padding: 8px 16px; background-color: #f8f9fa; border-bottom: 1px solid #e0e0e0; font-size: 14px; color: rgba(0, 0, 0, 0.87); } // Fix for double-pane layout app-double-pane { display: flex; width: 100%; height: 100%; } app-pane { display: flex; flex-direction: column; height: 100%; }
|   |   +-- app.component.ts: // src/app/app.component.ts import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent { isLoading = false; // Set to false since we'll handle loading in individual components }
|   |   \-- app.module.ts: import { NgModule, APP_INITIALIZER } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { HttpClientModule } from '@angular/common/http'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component'; import { MatPaginatorModule } from '@angular/material/paginator'; import { MatSortModule } from '@angular/material/sort'; // GeoView Components import { MapComponent } from './components/map/map.component'; import { MapViewComponent } from './components/map-view/map-view.component'; // Make sure this is imported import { TableComponent } from './components/table/table.component'; import { MatTooltipModule } from '@angular/material/tooltip'; import { DataService } from './services/data.service'; import { PaneModule } from './components/pane/pane.module'; import { MatTabsModule } from '@angular/material/tabs'; import { MatTableModule } from '@angular/material/table'; import { MatIconModule } from '@angular/material/icon'; import { AirportTableComponent } from './components/airport-table/airport-table.component'; import { StyleEditorComponent } from './components/style-editor/style-editor.component'; import { CommonModule } from '@angular/common'; import { IxtTableModule, IxtTabsetModule } from '@dvanauken/ixtlan/dist/ixtlan'; import { LoginComponent } from './components/login/login.component'; import { AuthService } from './services/auth.service'; import { AuthGuard } from './guards/auth.guard'; @NgModule({ declarations: [ AppComponent, MapComponent, TableComponent, AirportTableComponent, StyleEditorComponent, LoginComponent, MapViewComponent, // Make sure this is declared ], imports: [ CommonModule, BrowserModule, HttpClientModule, FormsModule, ReactiveFormsModule, AppRoutingModule, PaneModule, MatTabsModule, MatTableModule, MatPaginatorModule, MatSortModule, MatIconModule, MatTooltipModule, BrowserAnimationsModule, IxtTableModule, IxtTabsetModule ], providers: [ DataService, AuthService, AuthGuard ], bootstrap: [AppComponent], }) export class AppModule {}
